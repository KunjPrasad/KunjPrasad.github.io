<!--
    Productionizing Backend Development - Request and response glossary, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<title>Productionizing Backend Development - Request and response glossary</title>
		<meta name="description" content="Glossary for the book on Productionizing Backend Development containing concepts and terms related to request and response made to and from a web server.">
		<meta name="author" content="Kunj Prasad">
	
		<!-- Meta with information that otherwise should have come in request headers -->
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Pragma" content="no-cache">
		<meta http-equiv="Cache-Control" content="no-cache">
		
		<!-- Browser related meta -->
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1">
		<meta http-equiv="X-UA-Compatible" content="IE=Edge">
		
		<!-- OpenGraph related meta -->
		<meta property="og:url" content="https://kunjprasad.github.io/productionizing/productionizing-backend-development/glossary/req-resp.html">
		<meta property="og:site_name" content="Productionizing Backend Development book on Kunj Prasad's website">
		<!-- Not yet added image: <meta property="og:image" content="https://kunjprasad.github.io/assets/social_media_logo.png"> -->
		<meta property="og:title" content="Productionizing Backend Development - Request and response glossary">
		<meta property="og:description" content="Glossary for the book on Productionizing Backend Development containing concepts and terms related to request and response made to and from a web server.">
		<meta property="og:locale" content="en_US">
		<meta property="og:type" content="article">
		<meta property="article:publisher" content="Kunj Prasad">
		<meta property="article:published_time" content="2022-01-24T00:00:00+00:00">
		<meta property="article:modified_time" content="2022-01-24T00:00:00+00:00">
		
		<link rel="stylesheet" href="/utilities/common-styles.css" type="text/css">
	</head>
	
	<body>
	
		<header>
			<h1>Productionizing Backend Development - Request and response glossary</h1>
			<ol class="breadcrumb-container">
				<li><a href="/productionizing/productionizing-backend-development/">Home</a></li>
				<li><a href="/productionizing/productionizing-backend-development/glossary/">Glossary</a></li>
				<li>Request and response glossary</li>
			</ol>
		</header>
		
		<div id="note-status" class="note-status-sticky-header alert"><!-- The content here is filled dynamically by the script and gives information on notes, and file uploads, or unsaved changes --></div>
		
		<nav>
			<h2>Table of contents</h2>
			<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#rpc">Remote procedure call, or RPC</a><ul>
					<li><a href="#rmi">Remote method invocation, or RMI</a></li>
					<li><a href="#web-services">Web services</a></li>
					<li><a href="#soap">Simple Object Access Protocol, or SOAP</a></li>
					<li><a href="#rest">Representational State Transfer, or REST</a></li>
				</ul></li>
				<li><a href="#web-app-server">Web servers and Application servers</a></li>
				<li><a href="#http">HyperText Transfer Proptocol, or HTTP</a><ul>
					<li><a href="#request-url">Request URL</a><ul>
						<li><a href="#context-root">Context root</a></li>
						<li><a href="#path-param">Path parameter</a></li>
						<li><a href="#query-param">Query parameter</a></li>
						<li><a href="#slug">Slug</a></li>
					</ul></li>
					<li><a href="#request-method">Request method</a><ul>
						<li><a href="#idempotent-request-method">Idempotent request method</a></li>
						<li><a href="#safe-request-method">Safe request method</a></li>
					</ul></li>
					<li><a href="#headers">Headers</a><ul>
						<li><a href="#cookies">Cookies</a></li>
					</ul></li>
					<li><a href="#request-response-body">Request and response body</a></li>
					<li><a href="#response-status">Response status</a></li>
				</ul></li>
				<li><a href="#advanced-http-communication">Advanced HTTP based communication</a><ul>
					<li><a href="#long-polling">Long Polling</a></li>
					<li><a href="#websocket">Websocket</a></li>
					<li><a href="#sse">Server Sent Events (or, SSE)</a></li>
					<li><a href="#compare-longpolling-websocket-sse">Long  polling vs Websocket vs SSE</a></li>
				</ul></li>
				<li><a href="#oltp-olap">OLTP and OLAP</a></li>
			</ul>
		</nav>
		
		<main>
			<h2 id="introduction">Introduction</h2>
				<p id="1618696259">This page lists the various terms that relate to request and response. Only necessary terms are covered that show up when handling of REST calls.</p>
				
			<h2 id="rpc">Remote procedure call, or RPC</h2>
				<p id="1608922545">See article about RPC at <a href="https://www.w3.org/History/1992/nfs_dxcern_mirror/rpc/doc/Introduction/WhatIs.html" target="_blank" rel="noopener noreferrer">W3</a> and <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener noreferrer">Wikipedia</a>. RPC is a <strong>technique</strong> for building distributed systems by allowing a program on one machine (client) to call a subroutine on another machine (server) without knowing that the invoked subroutine is occurring on a different machine. Thus, it provides concepts for achieving a <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response" target="_blank" rel="noopener noreferrer">request–response</a> communication. On the client side, it is coded as if it the call being made is a normal (local) procedure call and without the programmer explicitly coding the details for the remote interaction, or hardware and OS details of remote server. That is, the programmer writes essentially the same code whether the subroutine is local to the executing program, or remote. Note that RPC is <strong>not</strong> a transport protocol.</p>
				<p id="1608922546">RPC can be achieved by locally (local, meaning at the client application side) combining all information needed by the server some a message format and sending it to remote server. The remote server unpacks the message to identify the code to run and parameters to the code. It executes the method and then returns the result back to the client application (Reference: <a href="https://en.wikipedia.org/wiki/Remote_procedure_call#Message_passing" target="_blank" rel="noopener noreferrer">Wikipedia</a>). The process of combining necessary information in the message, done by client application when it sends the initial request, or by the server when it sends the response, is called "marshalling". The reverse process of retrieving the information contained in the message, done by the server when it receives the request from client application, and by the client application when it receives the response from the server, is called "unmarshalling" where the parameters are recreated from the message. The common rule agreed upon by both the client and the server, determining how to pack or unpack necessary information in a message is called the "protocol" of the communication. Marshalling of information is needed to convert data that exists in a client application computer's memory into a binary form that can then be sent to another computer, i.e., the server, over the network. For example, consider a date object formed by code <code>new Date("2019-12-20")</code>. This is an "object" which exists in computer's memory and has access to various object methods, like, <code>isBefore(...)</code>, <code>isAfter(...)</code>, etc. One way to marshall this date object is to convert the date to string <code>2019-12-20</code>, which UTF-8 encoded to bytes <code>50, 48, 49, 57, 45, 49, 50, 45, 50, 48</code>, that can be transferred over network as <code>00110010</code> for <code>50</code>, <code>00110000</code> for <code>48</code>, etc. The server converts the sequence of 0s and 1s to bytes, which are then UTF-8 encoded to form the string that can be used to create a similar date "object" at server side.</p>
			
				<h3 id="rmi">Remote method invocation, or RMI</h3>
					<p id="1608922555">See article about RMI at <a href="https://en.wikipedia.org/wiki/Java_remote_method_invocation" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html" target="_blank" rel="noopener noreferrer">Oracle</a>. With the development of object oriented programming, an extension of RPC was developed wherein the complete objects are passed between client and server. This bypasses the overhead of marshalling/unmarshalling and makes the communication more performant. However, it also constrains the interaction to be between a client and server running same programming language because both the client and server must understand the class definition and corresponding binary data representing the object being exchanged. Should one of them choose to use a different language at any time an for any reason, the communication breaks. This restricts the popularity of RMIs.</p>
				
				<h3 id="web-services">Web services</h3>
					<p id="1608925640">See article about web service in <a href="https://en.wikipedia.org/wiki/Web_service" target="_blank" rel="noopener noreferrer">Wikipedia</a>. Stating simply, a web service is a <a href="#rpc">RPC</a> that uses <a href="#http">Hypertext Transfer Protocol or HTTP</a> as a protocol for communication between the client application and the server. This allows a client application to send a request to server for processing data, reusing the same infrastructure as used for internet. Since the server is using HTTP, so it must listen for incoming HTTP requests, execute methods depending on url and method of the request, and read parameters from url and body of the request. The client application also must make a properly structured HTTP request to a server to achieve the desired result.</p>
				
				<h3 id="soap">Simple Object Access Protocol, or SOAP</h3>
					<p id="1608925630">See article about SOAP at <a href="https://en.wikipedia.org/wiki/SOAP" target="_blank" rel="noopener noreferrer">Wikipedia</a>. Consider a <a href="#rpc">RPC</a> where the protocol for arranging information in a message is separated from the protocol used for communication between two machines. The former protocol controls the arrangement of input parameters in request body before it is then sent to server, and also decides on how to extract the response data from response returned by the server, including, to identify if the processing failed with an error. SOAP is one such protocol for communication with web service. It is an official messaging protocol specification used for exchanging structured information in the implementation of web services and maintained by <a href="https://www.w3.org/TR/soap12/" target="_blank" rel="noopener noreferrer">W3C</a>. In SOAP, the request and response message is structured in a standard XML format, and the and the message is transmitted between machines using application layer protocols, most often <a href="#http">HTTP</a>. Since the communication between the client and server is done via a XML message, so, unlike <a href="#rmi">RMI</a>, it is allowed for the two to be running different programming languages, and still be able to communicate with each other.</p>
				
				<h3 id="rest">Representational State Transfer, or REST</h3>
					<p id="1608927383">See article about REST at <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f" target="_blank" rel="noopener noreferrer">Medium</a>. To begin with, realize that REST is an architecture and not a protocol. It provides a set of guidelines for designing web APIs enabling a client to discover and execute relevant services provided by a server. However, it does not police adherence to the architecture considerations. A web service designed with REST architectural considerations are called RESTful web services. I've always seen RESTful services being mentioned in context of communication over <a href="#http">HTTP</a> and I am not aware if they can be used in other scenarios. Personally, I find that the best way to understand and appreciate REST designs is by understanding the <a href="https://en.wikipedia.org/wiki/Richardson_Maturity_Model" target="_blank" rel="noopener noreferrer">Richardson maturity model</a>. An example of migrating from zero REST to Level-3 REST and the benfit it provides is covered in <a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="noopener noreferrer">this article from Martin Fowler</a>. Some articles comparing <a href="#soap">SOAP</a> (recall, SOAP is a protocol) vs REST can be found at <a href="https://stackify.com/soap-vs-rest/" target="_blank" rel="noopener noreferrer">Stackify</a> and <a href="https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest" target="_blank" rel="noopener noreferrer">Red Hat</a>. Currently, a large percentage of web APIs follow REST because of its intuitiveness, simplicity and ease of change. That being said, many business prefer having a list of available APIs that can be used. To meet this requirement, <a href="https://swagger.io/resources/open-api/" target="_blank" rel="noopener noreferrer">OpenAPI specifications</a> and <a href="https://swagger.io/" target="_blank" rel="noopener noreferrer">Swagger</a> can be used (They are further discussed in a <a href="/productionizing/productionizing-backend-development/glossary/housekeeping.html#openapi">section</a> within the housekeeping glossary).</p>
					
			<h2 id="web-app-server">Web servers and Application servers</h2>
				<p id="1609003848">See article about web servers at <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_web_server" target="_blank" rel="noopener noreferrer">Mozilla</a>. As mentioned above, a <a href="#web-services">web service</a> can be used to request data and/or trigger a processing at a server using <a href="#http">HTTP</a> for communication. The data being served can either be static files, like, images, html, css, etc. files. It can also be dynamic data, like, calendar page for logged in user, which depends on the user making the call. The requests made to the server can also trigger some processing, like, making a new calendar entry. Generally, when talking about a web server, it means a static web server that serves static content. Separate from it is an application server which is a combination of web server and additional business logic that allows returning dynamic content to users in response to HTTP calls. An application server can also manage database connections and also support calls other that via HTTP (i.e. RMI calls). For more difference between the web and application servers, see articles at <a href="https://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server/35360821#35360821" target="_blank" rel="noopener noreferrer">StackOverflow</a> and <a href="https://www.ibm.com/cloud/learn/web-server-vs-application-server" target="_blank" rel="noopener noreferrer">IBM</a>.</p>
			
			<h2 id="http">HyperText Transfer Proptocol, or HTTP</h2>
				<p id="1608922565">See article about HTTP at <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener noreferrer">IETF</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" rel="noopener noreferrer">Mozilla</a>. HTTP is an <a href="https://en.wikipedia.org/wiki/Application_layer" target="_blank" rel="noopener noreferrer">application layer</a> protocol designed within the framework of the Internet protocol suite, i.e. as a protocol enabling a <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response" target="_blank" rel="noopener noreferrer">request–response</a> communication. Its definition presumes an underlying and reliable <a href="https://en.wikipedia.org/wiki/Transport_layer" target="_blank" rel="noopener noreferrer">transport layer protocol</a>, for which the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener noreferrer">Transmission Control Protocol (TCP)</a> is commonly used. Servers and esources that can be communicated to via HTTP are identified and located on the network by <a href="https://en.wikipedia.org/wiki/URL" target="_blank" rel="noopener noreferrer">Uniform Resource Locators (URLs)</a>. HTTP allows sending/receiving headers as part of request/response containing different metadat about the request/response. HTTP in itself is stateless and there is no link between two requests being successively carried out on the same connection. However, it allows servers to set <a href="#cookies">HTTP cookies</a> via headers which can then be used to have stateful sessions. HTTPS is an extension of http wherein the communication is encrypted to secure it against various attacks. It is covered in a <a href="/productionizing/productionizing-backend-development/glossary/security.html#man-in-middle">section</a> under the security glossary.</p>
				
				<h3 id="request-url">Request URL</h3>
					<p id="1608993702">For details about URL, see <a href="https://tools.ietf.org/html/rfc2616#section-3.2" target="_blank" rel="noopener noreferrer">IETF specification</a> and <a href="https://en.wikipedia.org/wiki/URL" target="_blank" rel="noopener noreferrer">Wikipedia</a>. URLs are used to identify servers and resources on the web so that a request-response communication can then be initiated. As an example, consider the url <code>https://www.example.com:8000/root/parent/1234/child/?param1=value1&amp;param2=value2</code>. Here, the initial <code>https</code> is called "url-scheme", <code>www.example.com</code> is the "domain" of the website, <code>8000</code> is the "port" of server that is listening for HTTP requests (it may not be necessary to provide a port if the domain is configured accordingly), <code>/root/parent/1234/child/</code> is the "url path" (by convention, the last "/" in url path is optional) and <code>param1=value1&amp;param2=value2</code> are "url query parameters". Additional discussion on url is covered below.</p>
					
					<h4 id="context-root">Context root</h4>
						<p id="1609006646">One physical machine / computer can be made to host multiple web applications. This may be done either to achieve proper resource utilization, or, maybe because multiple applications were bundled together and all deployed at the same time. In either case, it becomes necessary to add a mechanism to identify that if a HTTP request comes to the server, then to which application amongst the many on the server should the request be sent to for further processing. This is done by adding a context root to each application which is the portion of url the comes immediately after the domain name. For most cases, it is left empty (i.e., just "/") because a single application is deployed in the server. In the url <code>https://www.example.com/root/parent/1234/child/ABCD/</code>, the context root would be <code>/root</code>, if configured so for the application. For more details, see <a href="https://docs.oracle.com/cd/E19830-01/819-4725/abmdq/index.html" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://www.baeldung.com/spring-boot-context-path" target="_blank" rel="noopener noreferrer">here</a> (Disclosure: I've seen context root being used only with java web applications).</p>
					
					<h4 id="path-param">Path parameter</h4>
						<p id="1609007236">Consider the url path <code>https://www.example.com/root/parent/1234/child/ABCD/</code> for which the application server responds by returning a text "1234 ABCD". It does so by comparing the url path against a configured template, like <code>https://www.example.com/root/parent/{parent-id}/child/{child-id}/</code>, identifying the values "1234" for parent-id and "ABCD" for child-id, and forming a final response by coming the parent and child id(s) together. In this example, {parent-id} and {child-id} are called "path parameters" because these values are obtained from the url-path and used as parameters by the method that is executed on the application server. It is also possible to provide object-valued or multiple entries in a single path parameter by separating the different values in a path parameter using semicolon, or period, or comma (Reference: <a href="https://swagger.io/docs/specification/describing-parameters/#path-parameters" target="_blank" rel="noopener noreferrer">Swagger docs</a> identifying different ways to express object or array valued path parameter).</p>
					
					<h4 id="query-param">Query parameter</h4>
						<p id="1609008266">Consider the url <code>https://www.example.com/root/parent/?start=12</code>. Let's say this url intends to look for all "parent" entries for which the "parent-id" starts with "12", like, "1234" (as used in previous example, and also..), "1244", "1289", etc. but not entries like "2378", "2147", etc. When a response to a url can return multiple resources, then query parameter(s) is used to filter down the results. The query paramters are added after url-path. Adding a "?" identifies the beginning of query-parameter and so, the url path finishes before it. Multiple query parameters can be used to filter on different criteria and are joined together by "&amp;", like <code>?start=12&amp;end=34</code>. This should now return "1234" but not return "1244", nor "1289". It is also possible to pass multiple values for a single query parameter by repeating the parameter, like, <code>?start=12&amp;start=23</code>. Now, this should also return "2378" which was previously discarded, but still not return "2147". (Reference: <a href="https://swagger.io/docs/specification/describing-parameters/#query-parameters" target="_blank" rel="noopener noreferrer">Swagger</a>)</p>
					
					<h4 id="slug">Slug</h4>
						<p id="1609008276">I consider this <a href="https://stackoverflow.com/questions/427102/what-is-a-slug-in-django/427201#427201" target="_blank" rel="noopener noreferrer">StackOverflow answer </a> as the best reference for about the need for a "slug". The term "slug", as used in relation to a url, comes from the world of newspaper production. It's an informal name given to a story during the production process. As the story winds its path from the reporter through to editor through to the "printing presses", this is the name it is referenced by, e.g., "Have you fixed those errors in the 'kate-and-william' story?", where, 'kate-and-william' is the slug. The slug can be used to make a more human readable url that can be used to locate the resource, like <code>https://www.example.com/archives/kate-and-william</code>.</p>
				
				<h3 id="request-method">Request method</h3>
					<p id="1609036000">See details about HTTP Request methods, also called HTTP verbs, at <a href="https://tools.ietf.org/html/rfc2616#section-5.1.1" target="_blank" rel="noopener noreferrer">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" target="_blank" rel="noopener noreferrer">Mozilla</a> and <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" target="_blank" rel="noopener noreferrer">Wikipedia</a>. The request method indicates a desired action to be performed for a given resource (resource identified by the url). The most commonly used verbs are <code>POST, GET, PUT, PATCH, DELETE</code>. "GET" is used to fetch a resource, "POST" to create a new resource, "PUT" is to replace the existing resource with the newly provided one, "PATCH" to update an existing resource and "DELETE" to delete a resource. A <a href="#request-body">request body</a> can be sent with POST, PUT, PATCH calls. Although not technically disallowed, sending a request body with DELETE calls is very rare  (Reference: <a href="https://stackoverflow.com/questions/299628/is-an-entity-body-allowed-for-an-http-delete-request" target="_blank" rel="noopener noreferrer">StackOverflow</a>). For GET calls, the request body is conventionally ignored and should not be sent (Reference: <a href="https://stackoverflow.com/questions/978061/http-get-with-request-body" target="_blank" rel="noopener noreferrer">StackOverflow</a>). Instead, url, with path-parameters and query-parameters should be constructed in a manner that the HTTP GET call returns desired results.</p>
					
					<h4 id="idempotent-request-method">Idempotent request method</h4>
						<p id="1609036019">See details about idempotent HTTP methods at <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank" rel="noopener noreferrer">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Glossary/idempotent" target="_blank" rel="noopener noreferrer">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Idempotent_methods_and_web_applications" target="_blank" rel="noopener noreferrer">Wikipedia</a>. Requests methods are labeled as being idempotent if an identical request can be made once or several times in a row and it leaves the server in the same state. <code>GET, PUT, DELETE</code> fall in this category. In calling "DELETE" multiple times, it will return 200 response status (discussed later) for the first time and 404 for subsequent calls. It is still considered as being idempotent because the state of data on server should always remain the same. Note that "idempotence" for corresponding request method isn't a constraint enforced by HTTP, but is a conventional guidance on how the application method should behave.</p>
					
					<h4 id="safe-request-method">Safe request method</h4>
						<p id="1609036099">See details about safe request method at <a href="https://tools.ietf.org/html/rfc2616#section-9.1.1" target="_blank" rel="noopener noreferrer">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank" rel="noopener noreferrer">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_methods" target="_blank" rel="noopener noreferrer">Wikipedia</a>. A HTTP method is safe if it doesn't alter the state of the server, i.e. if it is a read-only operation. These methods, by definition, are also idempotent. "GET" calls fall into the category of safe method. Note that "safety" for corresponding request method isn't a constraint enforced by HTTP, but is a conventional guidance on how the application method should behave.</p>
				
				<h3 id="headers">Headers</h3>
					<p id="1609038553">See details about headers at <a href="https://tools.ietf.org/html/rfc2616#section-5.3" target="_blank" rel="noopener noreferrer">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener noreferrer">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="noopener noreferrer">Wikipedia</a>. The request-header fields allow the client to pass additional information about the request and the client itself, to the server. Similarly, there are response-header fields that allow the server to pass additional information about the response, access to resource and server. It is highly recommended to go throught the list of standard request and response headers. Custom headers (i.e., ones specific to the web application being used, and not not standard to HTTP) can be added in request or returned in response if needed. It used to be customary to prefix the name of these header with "X-" but the recommendation has since been removed and instead, it is suggested to simply name the custom headers properly (references: <a href="https://stackoverflow.com/questions/3561381/custom-http-headers-naming-conventions" target="_blank" rel="noopener noreferrer">StackOverflow</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener noreferrer">Mozilla</a>). Note that choosing to still use "X-" prefix isn't something that will break HTTP communication, but is just something not recommended anymore. Some security related headers (for <a href="/productionizing/productionizing-backend-development/glossary/security.html#cookie-token-auth">authentication</a>, <a href="/productionizing/productionizing-backend-development/glossary/security.html#cors">cors</a>) are discussed in sections of the security glossary.</p>
	
					<h4 id="cookies">Cookies</h4>
						<p id="1609041933">See details about HTTP Cookies at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank" rel="noopener noreferrer">Mozilla</a>, <a href="https://www.kaspersky.com/resource-center/definitions/cookies" target="_blank" rel="noopener noreferrer">Kapersky</a>, <a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank" rel="noopener noreferrer">Wikipedia</a> and at this <a href="https://flaviocopes.com/cookies/" target="_blank" rel="noopener noreferrer">article</a>. A HTTP cookie is a small piece of data that a server sends to the user's web browser. It is a special kind of request header in that a browser stores it and sends it back to the server every time a request is made to same website, thereby enabling identification if two requests came from the same browser. In doing so, cookies enables adding statefulness by remembering stateful data in a client-server interaction over a <a href="#1608922565">stateless HTTP protocol</a>. For example, a user may want their previous settings, preferences to be persisted across multiple HTTP calls so that they are asked about it just once and not every time. A cookie can also be used to check if the user has logged in (IMPORTANT: Note that a simple cookie-only based authentication is susceptible to <a href="/productionizing/productionizing-backend-development/glossary/security.html#csrf">CSRF</a> attacks, as discussed in security glossary). The server can set new cookies or modify the value of existing cookies by sending one or multiple <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener noreferrer">"Set-cookie"</a> response headers to set/update the cookies. Various attributes and expiry period can be added to customize the behavior and scope of a cookie. As mentioned <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Security" target="_blank" rel="noopener noreferrer">here</a>, a cookie must be secured using <code>HttpOnly, Samesite, Secure</code> attributes whenever possible. With the passing of data privacy laws, like <a href="https://gdpr.eu/cookies/" target="_blank" rel="noopener noreferrer">GDPR</a>, one must be careful in storing and using cookies and not use them indiscriminately.</p>
				
				<h3 id="request-response-body">Request and response body</h3>
					<p id="1609041974">See details about request and response body at <a href="https://tools.ietf.org/html/rfc2616#section-7" target="_blank" rel="noopener noreferrer">IETF</a>. Request body can be used to transfer message from the client application to server when sending a request. Response body can be used to transfer message from the server to client application when sending a response. In either case, <a href="#headers">request or response headers</a> like <code>Content-Type, Content-Length, Content-Encoding</code>, etc. are used to provide information on how to convert the bytes in request or response body into a meaningful message.</p>
	
				<h3 id="response-status">Response status</h3>
					<p id="1609085465">See details about response status code at <a href="https://tools.ietf.org/html/rfc2616#section-6.1.1" target="_blank" rel="noopener noreferrer">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noopener noreferrer">Mozilla</a>. A response status code along with a small text decription is provided with every HTTP response. They are grouped in 5 classes: informational responses (100–199), successful responses (200–299), redirects (300–399), client errors (400–499), server errors (500–599). It is up to the application to return proper response code for proper communication to user. Each response code also maps to a corresponding text that gives a brief description about the response code. The text is also sent in the response. For example: 201 Created, 400 Bad Request, etc. In this example, "Created" and "Bad Request" is the text corresponding to response code "201" and "400".</p>
				
			<h2 id="advanced-http-communication">Advanced HTTP based communication</h2>
				<p>HTTP based request-response type communication is generally used in a way where a client sends a request to server, which is processed at server (generally within 0.1- 1 second) and then a response is returned. This section covers some advanced communication techniques using HTTP.</p>
	
				<h3 id="long-polling">Long Polling</h3>
					<p id="1609087160"><a href="https://en.wikipedia.org/wiki/Polling_(computer_science)" target="_blank" rel="noopener noreferrer">Polling</a> refers to actively sampling the status of an external device/application by a client program as a synchronous activity. Think of the scenario where you're driving to some destination and a fellow passenger keeps asking "are we there yet?". In this case, that passenger is the "client", who is "polling" the driver to identify a status update for the resource. In this example, the driver is the "server", and the resource is status to the question if the destination has been reached. The delay between successive calls is the polling interval. Long polling (reference: <a href="https://tools.ietf.org/id/draft-loreto-http-bidirectional-07.html" target="_blank" rel="noopener noreferrer">IETF</a>, <a href="https://en.wikipedia.org/wiki/Push_technology#Long_polling" target="_blank" rel="noopener noreferrer">Wikipedia</a>) is when server accepts the request and keeps it pending till a response is available, at which time it is sent. Consider same example as above, but after the first question, the "client" passenger and "server" driver have an understanding that the driver will respond once they have an update, and in the mean time, the passenger will eagerly wait for response from driver. Long polling techniques can be quick to add but they have their own drawbacks (reference: <a href="https://stackoverflow.com/questions/21676324/hard-downsides-of-long-polling" target="_blank" rel="noopener noreferrer">StackOverflow</a>)</p>
			
				<h3 id="websocket">Websocket</h3>
					<p id="1609087200">See details about websockets at <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noopener noreferrer">Mozilla</a>. WebSocket is a computer communications protocol, providing <a href="https://en.wikipedia.org/wiki/Duplex_(telecommunications)#FULL-DUPLEX" target="_blank" rel="noopener noreferrer">full-duplex</a> communication channels over a single TCP connection. WebSocket is distinct from HTTP, for one, it uses "ws://" and "wss://" scheme instead of HTTP's "http://" and "https://". However, despite being different, a WebSocket "is designed to work over HTTP ports 443 and 80 as well as to support HTTP proxies and intermediaries," making it compatible with the HTTP protocol (reference: <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener noreferrer">RFC 6455</a>). To achieve compatibility, the WebSocket handshake uses the <a href="https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header" target="_blank" rel="noopener noreferrer">HTTP Upgrade header</a> to change from the HTTP protocol to the WebSocket protocol. This is also of benefit for environments that block non-web Internet connections using a firewall. By providing a standardized way for the server to send content to the client without being first requested by the client, and allowing messages to be passed back and forth while keeping the connection open, the WebSocket protocol enables two-way client-server interaction with lower overhead than half-duplex alternatives such as HTTP polling and also facilitates real-time data transfer from and to the server. More example of websocket can be seen in this article at <a href="https://spring.io/guides/gs/messaging-stomp-websocket/" target="_blank" rel="noopener noreferrer">Spring</a>, <a href="https://lucumr.pocoo.org/2012/9/24/websockets-101/" target="_blank" rel="noopener noreferrer">here</a>, <a href="https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7" target="_blank" rel="noopener noreferrer">SessionStack</a>, <a href="https://blog.teamtreehouse.com/an-introduction-to-websockets" target="_blank" rel="noopener noreferrer">Treehouse</a>.</p>
			
				<h3 id="sse">Server Sent Events (or, SSE)</h3>
					<p id="1609092373">See details about SSE at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" target="_blank" rel="noopener noreferrer">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/Server-sent_events" target="_blank" rel="noopener noreferrer">Wikipedia</a> and <a href="https://javascript.info/server-sent-events" target="_blank" rel="noopener noreferrer">here</a>. Some implementation examples can be seen at <a href="https://medium.com/conectric-networks/a-look-at-server-sent-events-54a77f8d6ff7" target="_blank" rel="noopener noreferrer">Medium</a>, <a href="https://spring.io/blog/2017/03/08/spring-tips-server-sent-events-sse" target="_blank" rel="noopener noreferrer">Spring</a>, <a href="https://www.baeldung.com/spring-server-sent-events" target="_blank" rel="noopener noreferrer">here</a> and at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener noreferrer">Mozilla</a>. SSE enables a client to receive automatic updates from a server via HTTP connection; Also, the Server-Sent Events EventSource API is standardized as part of HTML5 by the W3C. Unlike websockets, SSE are sent over HTTP and not via a different protocol. However, this only allows a server to send a stream response, but not for client to send data to server after initiatingthe call.</p>
			
				<h3 id="compare-longpolling-websocket-sse">Long  polling vs Websocket vs SSE</h3>
					<p id="1609092300">Various articles can be found over the internet comparing long polling vs websocket vs SSE, for example, at <a href="https://medium.com/system-design-blog/long-polling-vs-websockets-vs-server-sent-events-c43ba96df7c1" target="_blank" rel="noopener noreferrer">Medium</a>, <a href="https://codeburst.io/polling-vs-sse-vs-websocket-how-to-choose-the-right-one-1859e4e13bd9" target="_blank" rel="noopener noreferrer">Codeburst</a>, <a href="https://www.educative.io/courses/grokking-the-system-design-interview/gx7wZzWn5Vj" target="_blank" rel="noopener noreferrer">Educative (paywall)</a>. Briefly, long polling can be good to have in initial development stages since it is nothing different from ordinary HTTP calls, except allowing for long connections. The drawback is that this adds larger server overhead and isn't very reliable. SSE should be preferred when a streaming response is needed from server after client has initiated a request, but client will no longer be sending any data from their side. For example, you ordered pizza - and want to get a very detailed second-by-second update status. Here, you as the "client" will not be sending any information after making the initial call, but the response requires streamed response from server (..just to mention, if the business case indicates that user would be ok with receiving response, say, every 3 minutes, then rather than using SSE, or even long polling, it'd be preferable to simply have the  website or app make a request every 3 minutes). However, if a "chat" like feature is needed and where the data transferred can be very frequent, then a websocket is useful (think of ordering pizza, and then being able to talk with the chef, kitchen staff!! Fancy pizza!).</p>
			
			<h2 id="oltp-olap">OLTP and OLAP</h2>
				<p id="1613521031">The difference between OLTP vs OLAP is covered in articles at <a href="https://stackoverflow.com/questions/21900185/what-are-oltp-and-olap-what-is-the-difference-between-them" target="_blank" rel="noopener noreferrer">StackOverflow</a> and <a href="https://www.stitchdata.com/resources/oltp-vs-olap/" target="_blank" rel="noopener noreferrer">here</a>. OLTP, or "On-line Transaction Processing", is characterized by a large number of short on-line transactions. Such operations have a strong emphasis being on "short", i.e. the user sees a response very soon after making a request. On the other hand, OLAP, or "On-line Analytical Processing" involves processing of historical data via complex aggregations. Such operations are not made very often because, (1) nobody wants to make a request and wait for a long time before getting response, and, (2) the actual reason - the response data only changes negligibly within a small time, and so, there's no reason to make such requests often. Note that OLTP and OLAP is categorization of request being processed by the server, based on the efforts needed to process the request. However, both requests can be web requests, sent using HTTP, etc., and those are not the factors that differentiate OLTP vs OLAP.</p>
		</main>
		
		<footer></footer>
		
		<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
		<script type="module">
			import {onNonHomepageLoad} from "../scripts.js";
			$(document ).ready(onNonHomepageLoad);
		</script>
		
	</body>
	
</html>
