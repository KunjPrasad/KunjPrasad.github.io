<!--
    HTML book section: Request and response related term glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Request and response related terms</h2>
	<p>This page lists the various terms that relate to request and response. Since the scope of this book is to cover backend handling of REST calls, it may not cover all of the terms. Nonetheless, it is important for a backend software developer to be aware of these terms and what they mean.</p>
	
	<h3>Remote procedure call, or RPC</h3>
	<p id="1608922545">See article about RPC at <a href="https://www.w3.org/History/1992/nfs_dxcern_mirror/rpc/doc/Introduction/WhatIs.html" target="_blank">W3</a> and <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">Wikipedia</a>. RPC is a <strong>technique</strong> for building distributed systems by allowing a program on one machine (client) to call a subroutine on another machine (server) without knowing that the invoked subroutine is occurring on a different machine. Thus, it provides concepts for achieving a <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response" target="_blank">request–response</a> communication. On the client side, it is coded as if it the call being made is a normal (local) procedure call and without the programmer explicitly coding the details for the remote interaction, or hardware and OS details of remote server. That is, the programmer writes essentially the same code whether the subroutine is local to the executing program, or remote. Hence, RPC is not a transport protocol. One way to achieve this is by combining all local parameters passed to the method (local means, at client side) in a message format (the processing forming message is called "marshalling") and sending it to remote server, which then unpacks the message to obtain individual parameters (the process of unpacking parameters from message is called "unmarshalling"), executes the invoked method and then returns the result, performing the same communication steps in reverse order (Reference: <a href="https://en.wikipedia.org/wiki/Remote_procedure_call#Message_passing" target="_blank">Wikipedia</a>).</p>
	
	<h4>Remote method invocation, or RMI</h4>
	<p id="1608922555">See article about RMI at <a href="https://en.wikipedia.org/wiki/Java_remote_method_invocation" target="_blank">Wikipedia</a>, <a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html" target="_blank">Oracle</a>. With the development of object oriented programming, an extension of RPC was developed wherein the complete objects are passed between client and server. This bypasses the overhead of marshalling/unmarshalling and makes the communication more performant. However, it also constrains the interaction to be between a client and server running same programming language because both the client and server must understand the class definition and corresponding binary data representing the object being exchanged. Should one of them choose to use a different language at any time an for any reason, the communication breaks. This restricts the popularity of RMIs.</p>
	
	<h4>Web services</h4>
	<p id="1608925640">See article about web service in <a href="https://en.wikipedia.org/wiki/Web_service" target="_blank">Wikipedia</a>. Consider RPC invocation but instead of directly identifying a method that must be run on the remote server, a web technology such as HTTP is used for transferring machine-readable file formats such as XML and JSON, and which has an effect of invoking desired method on the remote server. At this point, the remote server is acting as a web service.</p>
	
	<h4>Simple Object Access Protocol, or SOAP</h4>
	<p id="1608925630">See article about SOAP at <a href="https://en.wikipedia.org/wiki/SOAP" target="_blank">Wikipedia</a>. SOAP is a official messaging protocol specification used for exchanging structured information in the implementation of web services and maintained by <a href="https://www.w3.org/TR/soap12/" target="_blank">W3C</a>. In short, consider starting with RMI, but instead of sending the object in a binary form, it is instead serialized-to/deserialized-from a standard XML format and the message is transmitted between machines using application layer protocols, most often Hypertext Transfer Protocol or HTTP (discussed later); This makes SOAP as a tool to performing RPCs on web services. Additionally, by doing off with transfer of binary objects as done in RMI, servers running different programming language can now easily interact with each other.</p>
	
	<h4>Representational State Transfer, or REST</h4>
	<p id="1608927383">See article about REST at <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">Wikipedia</a>, <a href="https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f" target="_blank">Medium</a>. To begin with, realize that REST is an architecture and not a protocol. So, REST provides a set of guidelines for designing web APIs, but does not police adherence to the architecture considerations. Personally, I find that the best way to understand and appreciate REST designs is by understanding the <a href="https://en.wikipedia.org/wiki/Richardson_Maturity_Model" target="_blank">Richardson maturity model</a>. An example of migrating from zero REST to Level-3 REST and the benfit it provides is covered in <a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">this article from Martin Fowler</a>. Some articles comparing SOAP vs REST can be found at <a href="https://stackify.com/soap-vs-rest/" target="_blank">Stackify</a> and <a href="https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest" target="_blank">Red Hat</a>. Currently, a large percentage of web APIs follow REST because of its simplicity and ease of change. That being said, the idea of API discovery via endpoint as promoted by REST is not something that many business like and instead prefer having a list of available APIs that can be readily used. To handle this requirement alongwith having RESTful endpoints, <a href="https://swagger.io/resources/open-api/" target="_blank">OpenAPI specifications</a> and <a href="https://swagger.io/" target="_blank">Swagger</a> are used. They are further discussed under housekeeping glossary.</p>
	
	<h3>HyperText Transfer Proptocol, or HTTP</h3>
	<p id="1608922565">See article about HTTP at <a href="https://tools.ietf.org/html/rfc2616" target="_blank">IETF</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">Wikipedia</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank">Mozilla</a>. HTTP is an <a href="https://en.wikipedia.org/wiki/Application_layer" target="_blank">application layer</a> protocol designed within the framework of the Internet protocol suite, i.e. as a protocol enabling a <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response" target="_blank">request–response</a> communication. Its definition presumes an underlying and reliable <a href="https://en.wikipedia.org/wiki/Transport_layer" target="_blank">transport layer protocol</a> and <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank">Transmission Control Protocol (TCP)</a> is commonly used. Resources that can be communicated to via HTTP are identified and located on the network by <a href="https://en.wikipedia.org/wiki/URL" target="_blank">Uniform Resource Locators (URLs)</a>. HTTP allows sending/receiving headers as part of request/response containing different metadat about the request/response. HTTP in itself is stateless and there is no link between two requests being successively carried out on the same connection. However, it allows servers to set HTTP cookies via headers which can then be used to have stateful sessions. HTTPS is an extension of http wherein the communication is encrypted to secure it against various attacks. It is covered under security glossary.</p>
	
	<h3>Request url</h3>
	<p id=""></p>
	
	<h4>Root context</h4>
	<p id=""></p>
	
	<h4>Path parameter</h4>
	<p id=""></p>
	
	<h4>Query parameter</h4>
	<p id=""></p>
	
	<h4>Matrix parameter</h4>
	<p id=""></p>
	
	<h4>Slug</h4>
	<p id=""></p>
	
	<h3>Headers</h3>
	<p id="">Say CORS is later in security. Custom headers starting with X-</p>
	
	<h4>Request headers</h3>
	<p id="">Say CORS is later in security. Say authentication headers later in security</p>
	
	<h3>Response headers</h3>
	<p id="">Say CORS is later in security</p>
	
	<h3>Request and response body</h3>
	<p id=""></p>
	
	<h3>Response status</h3>
	<p id=""></p>
	
	<h3>Cookies</h3>
	<p id="">
	Say session id cookie discussed in security.
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
	</p>
	
	<h3>Websocket</h3>
	<p id="">https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7    https://en.wikipedia.org/wiki/WebSocket   https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API  ;  heartbeat  ;  As a part of HTML5 the WebSocket API allows a web server and client to communicate over a full-duplex TCP connection.</p>
	
	<h3>Long Polling</h3>
	<p id=""></p>
	
	<h3> Server push</h3>
	<p id="">https://blogs.akamai.com/2017/03/http2-server-push-the-what-how-and-why.html#:~:text=For%20example%2C%20a%20client%20requests,in%20the%20proxy's%20local%20cache.</p>
	
	<h3>Server Sent Events (or, SSE)</h3>
	<p id="">https://medium.com/conectric-networks/a-look-at-server-sent-events-54a77f8d6ff7    https://javascript.info/server-sent-events    https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events  - have different content-type; diff. between long polling, websocket, sse</h3>
</article>
