<!--
    HTML book section: Request and response related term glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Request and response related terms</h2>
	<p>This page lists the various terms that relate to request and response. Since the scope of this book is to cover backend handling of REST calls, it may not cover all of the terms. Nonetheless, it is important for a backend software developer to be aware of these terms and what they mean.</p>
	
	<h3>Remote procedure call, or RPC</h3>
	<p id="1608922545">See article about RPC at <a href="https://www.w3.org/History/1992/nfs_dxcern_mirror/rpc/doc/Introduction/WhatIs.html" target="_blank">W3</a> and <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">Wikipedia</a>. RPC is a <strong>technique</strong> for building distributed systems by allowing a program on one machine (client) to call a subroutine on another machine (server) without knowing that the invoked subroutine is occurring on a different machine. Thus, it provides concepts for achieving a <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response" target="_blank">request–response</a> communication. On the client side, it is coded as if it the call being made is a normal (local) procedure call and without the programmer explicitly coding the details for the remote interaction, or hardware and OS details of remote server. That is, the programmer writes essentially the same code whether the subroutine is local to the executing program, or remote. Hence, RPC is not a transport protocol. One way to achieve this is by combining all local parameters passed to the method (local means, at client side) in a message format (the processing forming message is called "marshalling") and sending it to remote server, which then unpacks the message to obtain individual parameters (the process of unpacking parameters from message is called "unmarshalling"), executes the invoked method and then returns the result, performing the same communication steps in reverse order (Reference: <a href="https://en.wikipedia.org/wiki/Remote_procedure_call#Message_passing" target="_blank">Wikipedia</a>).</p>
	
	<h4>Remote method invocation, or RMI</h4>
	<p id="1608922555">See article about RMI at <a href="https://en.wikipedia.org/wiki/Java_remote_method_invocation" target="_blank">Wikipedia</a>, <a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html" target="_blank">Oracle</a>. With the development of object oriented programming, an extension of RPC was developed wherein the complete objects are passed between client and server. This bypasses the overhead of marshalling/unmarshalling and makes the communication more performant. However, it also constrains the interaction to be between a client and server running same programming language because both the client and server must understand the class definition and corresponding binary data representing the object being exchanged. Should one of them choose to use a different language at any time an for any reason, the communication breaks. This restricts the popularity of RMIs.</p>
	
	<h4>Web services</h4>
	<p id="1608925640">See article about web service in <a href="https://en.wikipedia.org/wiki/Web_service" target="_blank">Wikipedia</a>. Consider RPC invocation but instead of directly identifying a method that must be run on the remote server (called web server, more on it below), a web technology such as HTTP  (more about HTTP is discussed later) is used for transferring machine-readable file formats such as XML and JSON, and which has an effect of invoking desired method on the remote server. At this point, the remote server is acting as a web service.</p>
	
	<h4>Simple Object Access Protocol, or SOAP</h4>
	<p id="1608925630">See article about SOAP at <a href="https://en.wikipedia.org/wiki/SOAP" target="_blank">Wikipedia</a>. SOAP is a official messaging protocol specification used for exchanging structured information in the implementation of web services and maintained by <a href="https://www.w3.org/TR/soap12/" target="_blank">W3C</a>. In short, consider starting with RMI, but instead of sending the object in a binary form, it is instead serialized-to/deserialized-from a standard XML format and the message is transmitted between machines using application layer protocols, most often Hypertext Transfer Protocol or HTTP (discussed later); This makes SOAP as a tool to performing RPCs on web services. Additionally, by doing off with transfer of binary objects as done in RMI, servers running different programming language can now easily interact with each other.</p>
	
	<h4>Representational State Transfer, or REST</h4>
	<p id="1608927383">See article about REST at <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">Wikipedia</a>, <a href="https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f" target="_blank">Medium</a>. To begin with, realize that REST is an architecture and not a protocol. So, REST provides a set of guidelines for designing web APIs, but does not police adherence to the architecture considerations. Personally, I find that the best way to understand and appreciate REST designs is by understanding the <a href="https://en.wikipedia.org/wiki/Richardson_Maturity_Model" target="_blank">Richardson maturity model</a>. An example of migrating from zero REST to Level-3 REST and the benfit it provides is covered in <a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">this article from Martin Fowler</a>. Some articles comparing SOAP vs REST can be found at <a href="https://stackify.com/soap-vs-rest/" target="_blank">Stackify</a> and <a href="https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest" target="_blank">Red Hat</a>. Currently, a large percentage of web APIs follow REST because of its simplicity and ease of change. That being said, the idea of API discovery via endpoint as promoted by REST is not something that many business like and instead prefer having a list of available APIs that can be readily used. To handle this requirement alongwith having RESTful endpoints, <a href="https://swagger.io/resources/open-api/" target="_blank">OpenAPI specifications</a> and <a href="https://swagger.io/" target="_blank">Swagger</a> are used. They are further discussed under housekeeping glossary.</p>
	
	<h3>Web servers and Application servers</h3>
	<p id="1609003848">See article about web servers at <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_web_server" target="_blank">Mozilla</a>. Consider a client making request to a server, to which the server responds by loading resources. The web server connects to the Internet (i.e., it is identifiable via a url) and supports data interchange over HTTP request-response calls with other devices connected to the web, making it a HTTP server. In serving the content to user, it can either act as a static web server returning static html, css, etc. files. Generally, when talking about a web server, it means a static web server. Separate from it is an application server which is a combination of web server and additional business logic that allows returning dynamic content to users in response to HTTP calls. An application server can also manage database connections and also support calls other that via HTTP (i.e. RMI calls). For more difference between the web and application servers, see articles at <a href="https://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server/35360821#35360821" target="_blank">StackOverflow</a> and <a href="https://www.ibm.com/cloud/learn/web-server-vs-application-server" target="_blank">IBM</a>.</p>
	
	<h3>HyperText Transfer Proptocol, or HTTP</h3>
	<p id="1608922565">See article about HTTP at <a href="https://tools.ietf.org/html/rfc2616" target="_blank">IETF</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">Wikipedia</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank">Mozilla</a>. HTTP is an <a href="https://en.wikipedia.org/wiki/Application_layer" target="_blank">application layer</a> protocol designed within the framework of the Internet protocol suite, i.e. as a protocol enabling a <a href="https://en.wikipedia.org/wiki/Request%E2%80%93response" target="_blank">request–response</a> communication. Its definition presumes an underlying and reliable <a href="https://en.wikipedia.org/wiki/Transport_layer" target="_blank">transport layer protocol</a> and <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank">Transmission Control Protocol (TCP)</a> is commonly used. Resources that can be communicated to via HTTP are identified and located on the network by <a href="https://en.wikipedia.org/wiki/URL" target="_blank">Uniform Resource Locators (URLs)</a>. HTTP allows sending/receiving headers as part of request/response containing different metadat about the request/response. HTTP in itself is stateless and there is no link between two requests being successively carried out on the same connection. However, it allows servers to set HTTP cookies via headers which can then be used to have stateful sessions. HTTPS is an extension of http wherein the communication is encrypted to secure it against various attacks. It is covered under security glossary.</p>
	
	<h4>Request URL</h4>
	<p id="1608993702">For details about URL, see <a href="https://tools.ietf.org/html/rfc2616#section-3.2" target="_blank">IETF specification</a> and <a href="https://en.wikipedia.org/wiki/URL" target="_blank">Wikipedia</a>. URLs are used to identify resources (i.e. servers) on the web so that a request-response communication can then be initiated. As an example, consider the url <span class="code-span">https://www.example.com/root/parent/1234/child/?param1=value1&param2=value2</span>. Note that adding a trailing "/" is optional, so,  <span class="code-span">https://www.example.com/root/parent/1234/child/</span> is same as <span class="code-span">https://www.example.com/root/parent/1234/child</span> (i.e., without "/" at end). The initial <span class="code-span">https</span> is called url-scheme. In the example, <span class="code-span">www.example.com</span> is the domain of the website. The remaining portion of url is covered below.</p>
	
	<h5>Context root</h5>
	<p id="1609006646">Traditionally, one physical machine was made to host multiple application for proper resource utilization; Or, multiple applications were bundled together and all deployed at the same time. In either case, it becomes necessary to add mechanism for the application server to identify which application to send the request to for further processing. This was done by adding a context root to each application which is the portion of url the comes immediately after the domain name. For most cases, it is left empty (i.e., just "/") because a single application is deployed. In the url <span class="code-span">https://www.example.com/root/parent/1234/child/ABCD/</span>, the context root would be <span class="code-span">/root</span>, if configured so for the application. For more details, see <a href="https://docs.oracle.com/cd/E19830-01/819-4725/abmdq/index.html" target="_blank">here</a> and <a href="https://www.baeldung.com/spring-boot-context-path" target="_blank">here</a> (Disclosure: I've seen context root being used only with java web applications. I am not sure if it applies to other servers).</p>
	
	<h5>Path parameter</h5>
	<p id="1609007236">Consider the url <span class="code-span">https://www.example.com/root/parent/1234/child/ABCD/</span>. If this url were being served by a static web server, then likely this is implemented by having a directory called "parent", within which there is another directory called "1234", within which there is a directory called "child", and finally it contains a file named "ABCD". What about if we search for "5555" instead of "1234", or "QQQQ" instead of "ABCD". From a perspective of static web server, this would require having different entries that could then be served. From the perspective of an application server, there needs to be some database wherein these values can be queried and the corresponding result returned. Thus, the url can be given a generic form of something like <span class="code-span">https://www.example.com/root/parent/{parent-id}/child/{child-id}/</span>, where, parent-id and child-id can have different values. These are called url path parameters. It is also possible to provide object-valued or multiple entries in path-parameter and there are different ways to do so, like, using semicolon, or period, or comma (Reference: <a href="https://swagger.io/docs/specification/describing-parameters/#path-parameters" target="_blank">Swagger</a>).</p>
	
	<h5>Query parameter</h5>
	<p id="1609008266">Consider the url <span class="code-span">https://www.example.com/root/parent/?start=12</span>. Let's say this url means to look for all "parent" entries for which the "parent-id" start with "12", like, "1234" (as used in previous example, and also..), "1244", "1289", etc. but not entries like "2378", "2147", etc. When a url can response multiple resources, then query parameter(s) is used to filter down the results. The query paramters are added after url-path. Adding a "?" identifies the beginning of query-parameter and so, the url path finishes before it. Multiple query parameters can be used to filter on different criteria and are joined together by "&amp;", like <span class="code-span">?start=12&amp;end=34</span>. This should now return "1234" but not return "1244", nor "1289". It is also possible to pass multiple values for a single query parameter by separating using comma, like, <span class="code-span">?start=12,23</span>, which should now also return "2378" which was previously discarded, but still not return "2147". (Reference: <a href="https://swagger.io/docs/specification/describing-parameters/#query-parameters" target="_blank">Swagger</a>)</p>
	
	<h5>Slug</h5>
	<p id="1609008276">I consider this <a href="https://stackoverflow.com/questions/427102/what-is-a-slug-in-django/427201#427201" target="_blank">StackOverflow answer </a> as the best reference for this term. The term "slug", as used in relation to a url, comes from the world of newspaper production. It's an informal name given to a story during the production process. As the story winds its path from the reporter through to editor through to the "printing presses", this is the name it is referenced by, e.g., "Have you fixed those errors in the 'kate-and-william' story?", where, 'kate-and-william' is the slug. The slug can be used as part of the URL to locate the story, like <span class="code-span">https://www.example.com/archives/kate-and-william</span>.</p>
	
	<h4>Request method</h4>
	<p id="1609036000">See details about HTTP Request methods at <a href="https://tools.ietf.org/html/rfc2616#section-5.1.1" target="_blank">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" target="_blank">Mozilla</a> and <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" target="_blank">Wikipedia</a>. They indicate a desired action to be performed for a given resource (identified by the url). These request methods can also be referred to as HTTP verbs. The most commonly used verbs are <span class="code-span">POST, GET, PUT, PATCH, DELETE</span>. "GET" is used to fetch a resource, "POST" to create a new resource, "PUT" is to replace the existing resource with the newly provided one, "PATCH" to update an existing resource and "DELETE" to delete a resource. A request body (discussed later) can be sent with POST, PUT, PATCH calls. Even though a request body can be sent with DELETE calls, in common uses it is not sent (..once again, it is not that sending request body with DELTE call is wrong - <a href="https://stackoverflow.com/questions/299628/is-an-entity-body-allowed-for-an-http-delete-request" target="_blank">reference</a>. While sending a request body with GET calls is not disallowed, it should not be done (<a href="https://stackoverflow.com/questions/978061/http-get-with-request-body" target="_blank">reference</a>). Instead, url, with path-parameters and query-parameters should be constructed in a manner that the HTTP GET call returns desired results.</p>
	
	<h5>Idempotent request method</h5>
	<p id="1609036019">See details about idempotent HTTP methods at <a href="https://tools.ietf.org/html/rfc2616#section-9.1.2" target="_blank">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Glossary/idempotent" target="_blank">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Idempotent_methods_and_web_applications" target="_blank">Wikipedia</a>. Requests methods are labeled as being idempotent if an identical request can be made once or several times in a row and it leaves the server in the same state. <span class="code-span">GET, PUT, DELETE</span> fall in this category. In calling "DELETE" multiple times, it will return 200 response status (discussed later) for the first time and 404 for subsequent calls. It is still considered as being idempotent because the state of data on server should always remain the same. Note that "idempotence" for corresponding request method isn't a constraint enforced by HTTP, but is a guidance on how the backend method should comply. Having a non-compliant behavior will likely lead to present or future friction in understanding between the client and server.</p>
	
	<h5>Safe request method</h5>
	<p id="1609036099">See details about safe request method at <a href="https://tools.ietf.org/html/rfc2616#section-9.1.1" target="_blank">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Glossary/safe" target="_blank">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_methods" target="_blank">Wikipedia</a>. An HTTP method is safe if it doesn't alter the state of the server, i.e. if it is a read-only operation. These methods, by definition, are also idempotent. "GET" calls fall into the category of safe method. Note that "idempotence" for corresponding request method isn't a constraint enforced by HTTP, but is a guidance on how the backend method should comply. Having a non-compliant behavior will likely lead to present or future friction in understanding between the client and server.</p>
	
	<h4>Headers</h4>
	<p id="1609038553">See details about headers at <a href="https://tools.ietf.org/html/rfc2616#section-5.3" target="_blank">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank">Wikipedia</a>. The request-header fields allow the client to pass additional information about the request, and about the client itself, to the server. Similarly, there are response-header fields that allow the server to pass additional information about the response which cannot be placed in the response status or response body. These header fields give information about the server and about further access to the resource identified by the url. Custom headers (i.e., ones not standard to HTTP and specific to the web application) can be added in request or returned in response if needed. It was customary to prefix them with "X-" but the recommendation has since been removed and instead, it is suggested to simply name the custom headers properly (references: <a href="https://stackoverflow.com/questions/3561381/custom-http-headers-naming-conventions" target="_blank">StackOverflow</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank">Mozilla</a>). Note that choosing to still use "X-" prefix isn't something that will break HTTP communication, but is just something not recommended anymore. Some special security related headers are discussed later in security glossary.</p>
	
	<h5>Cookies</h5>
	<p id="1609041933">See details about HTTP Cookies at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank">Mozilla</a>, <a href="https://www.kaspersky.com/resource-center/definitions/cookies" target="_blank">Kapersky</a>, <a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank">Wikipedia</a> and at this <a href="https://flaviocopes.com/cookies/" target="_blank">article</a>. A HTTP cookie is a small piece of data that a server sends to the user's web browser. It is a special kind of request header in that a browser stores it and sends it back to the server every time a request is made to same website, thereby enabling identification if two requests came from the same browser. In doing so, cookies enables adding statefulness by remembering stateful data in a client-server interaction over a stateless HTTP protocol. For example, a user may want their previous settings, preferences to be persisted across multiple calls so that it is asked just once and not every time. A similar use-case is using cookie to authenticate only once if a user has logged in and to not continuously ask for their username and password (However, a simple cookie-only authentication is susceptible to CSRF attacks discussed in security glossary). In response, a server can send one or multiple <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" target="_blank">"Set-cookie"</a> headers to set/update the cookies. Various attributes and expiry period can be added to customize the behavior and scope of the cookie. As mentioned <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Security" target="_blank">here</a>, there are also suggested methods to secure cookies using <span class="code-span">HttpOnly, Samesite, Secure</span> attributes.</p>
	
	<h4>Request and response body</h4>
	<p id="1609041974">See details about request and response body at <a href="https://tools.ietf.org/html/rfc2616#section-7" target="_blank">IETF</a>. Request and response messages may transfer an entity if not otherwise restricted by the request method or response status code. An entity consists of entity-header fields and an entity-body. The entity-body is the main source for transferring data back and forth between the client and server in web communication. However, understanding what data is sent requires obtaining related entity-headers like <span class="code-span">Content-Type, Content-Length, Content-Encoding</span>, etc. Using different values for "Content-Type" allows sending data in different format to server, or for server to respond in different format (like, xml, json, file upload, multiples and mix of json and files).</p>
	
	<h4>Response status</h4>
	<p id="1609085465">See details about response status code at <a href="https://tools.ietf.org/html/rfc2616#section-6.1.1" target="_blank">IETF</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank">Mozilla</a>. A response status code along with a small text decription is provided with every HTTP response. They are grouped in 5 classes: informational responses (100–199), successful responses (200–299), redirects (300–399), client errors (400–499), server errors (500–599). It is up to the application to return proper response code for proper communication to user. Each response code also maps to a corresponding text that gives a brief description about the response code. The text is also sent in the response. For example: 201 Created, 400 Bad Request, etc. In this example, "Created" and "Bad Request" is the text corresponding to response code "201" and "400".</p>
	
	<h3>Advanced HTTP based communication</h3>
	<p>HTTP based request-response type communication is generally used in a way where a client sends a request to server, which is processed at server (generally within 0.1- 1 second) and then a response is returned. This section covers some advanced communication techniques using HTTP.</p>
	
	<h4>Long Polling</h4>
	<p id="1609087160"><a href="https://en.wikipedia.org/wiki/Polling_(computer_science)" target="_blank">Polling</a> refers to actively sampling the status of an external device/application by a client program as a synchronous activity. Think of the scenario where you're driving to some destination and a fellow passenger keeps asking "are we there yet?". In this case, that passenger is the "client", who is "polling" the driver to identify a status update for the resource. In this example, the driver is the "server", and the resource is status to the question if the destination has been reached. The delay between successive calls is the polling interval. Long polling (reference: <a href="https://tools.ietf.org/id/draft-loreto-http-bidirectional-07.html" target="_blank">IETF</a>, <a href="https://en.wikipedia.org/wiki/Push_technology#Long_polling" target="_blank">Wikipedia</a>) is when server accepts the request and keeps it pending till a response is available, at which time it is sent. Consider same example as above, but after the first question, the "client" passenger and "server" driver have an understanding that the driver will respond once they have an update, and in the mean time, the passenger will eagerly wait for response from driver. Long polling techniques can be quick to add but they have their own drawbacks (reference: <a href="https://stackoverflow.com/questions/21676324/hard-downsides-of-long-polling" target="_blank">StackOverflow</a>)</p>
	
	<h4>Websocket</h4>
	<p id="1609087200">See details about websockets at <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">Wikipedia</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank">Mozilla</a>. WebSocket is a computer communications protocol, providing <a href="https://en.wikipedia.org/wiki/Duplex_(telecommunications)#FULL-DUPLEX" target="_blank">full-duplex</a> communication channels over a single TCP connection. WebSocket is distinct from HTTP, for one, it uses "ws://" and "wss://" scheme instead of HTTP's "http://" and "https://". However, despite being different, a WebSocket "is designed to work over HTTP ports 443 and 80 as well as to support HTTP proxies and intermediaries," making it compatible with the HTTP protocol (reference: <a href="https://tools.ietf.org/html/rfc6455" target="_blank">RFC 6455</a>). To achieve compatibility, the WebSocket handshake uses the <a href="https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header" target="_blank">HTTP Upgrade header</a> to change from the HTTP protocol to the WebSocket protocol. This is also of benefit for environments that block non-web Internet connections using a firewall. By providing a standardized way for the server to send content to the client without being first requested by the client, and allowing messages to be passed back and forth while keeping the connection open, the WebSocket protocol enables two-way client-server interaction with lower overhead than half-duplex alternatives such as HTTP polling and also facilitates real-time data transfer from and to the server. More example of websocket can be seen in this article at <a href="https://spring.io/guides/gs/messaging-stomp-websocket/" target="_blank">Spring</a>, <a href="https://lucumr.pocoo.org/2012/9/24/websockets-101/" target="_blank">here</a>, <a href="https://blog.sessionstack.com/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path-584e6b8e3bf7" target="_blank">SessionStack</a>, <a href="https://blog.teamtreehouse.com/an-introduction-to-websockets" target="_blank">Treehouse</a>.</p>
	
	<h4>Server Sent Events (or, SSE)</h4>
	<p id="1609092373">See details about SSE at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" target="_blank">Mozilla</a>, <a href="https://en.wikipedia.org/wiki/Server-sent_events" target="_blank">Wikipedia</a> and <a href="https://javascript.info/server-sent-events" target="_blank">here</a>. Some implementation examples can be seen at <a href="https://medium.com/conectric-networks/a-look-at-server-sent-events-54a77f8d6ff7" target="_blank">Medium</a>, <a href="https://spring.io/blog/2017/03/08/spring-tips-server-sent-events-sse" target="_blank">Spring</a>, <a href="https://www.baeldung.com/spring-server-sent-events" target="_blank">here</a> and at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank">Mozilla</a>. SSE enables a client to receive automatic updates from a server via HTTP connection; Also, the Server-Sent Events EventSource API is standardized as part of HTML5 by the W3C. Unlike websockets, SSE are sent over HTTP and not via a different protocol. However, this only allows a server to send a stream response, but not for client to send data to server after initiatingthe call.</p>
	
	<h4>Long  polling vs Websocket vs SSE</h4>
	<p id="1609092300">Various articles can be found over the internet comparing long polling vs websocket vs SSE, for example, at <a href="https://medium.com/system-design-blog/long-polling-vs-websockets-vs-server-sent-events-c43ba96df7c1" target="_blank">Medium</a>, <a href="https://codeburst.io/polling-vs-sse-vs-websocket-how-to-choose-the-right-one-1859e4e13bd9" target="_blank">Codeburst</a>, <a href="https://www.educative.io/courses/grokking-the-system-design-interview/gx7wZzWn5Vj" target="_blank">Educative (paywall)</a>. Briefly, long polling can be good to have in initial development stages since it is nothing different from ordinary HTTP calls, except allowing for long connections. The drawback is that this adds larger server overhead and isn't very reliable. SSE should be preferred when a streaming response is needed from server after client has initiated a request, but client will no longer be sending any data from their side. For example, you ordered pizza - and want to get a very detailed second-by-second update status. Here, you as the "client" will not be sending any information after making the initial call, but the response requires streamed response from server (..just to mention, if the business case indicates that user would be ok with receiving response, say, every 3 minutes, then rather than using SSE, or even long polling, it'd be preferable to simply have the  website or app make a request every 3 minutes). However, if a "chat" like feature is needed and where the data transferred can be very frequent, then a websocket is useful (think of ordering pizza, and then being able to talk with the chef, kitchen staff!! Fancy pizza!).</p>
</article>
