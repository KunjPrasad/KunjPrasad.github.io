<!--
    HTML book section: Data storage related term glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<aside class="shown-individually-but-hidden-in-ebook"><i><strong>Read it in ebook <a href="/productionizing/productionizing-backend-development/#1611200362">here</a></strong></i></aside>
	
	<nav class="article-toc">
		<h2>Table of contents</h2>
		<a href="#1618627233" data-nav-id="1611200362">Data storage related terms</a>
		<ul>
			<li><a href="#1611200928" data-nav-id="1611200362">Why data storage?</a></li>
			<li><a href="#1611201475" data-nav-id="1611200362">Memory</a></li>
			<li><a href="#1611202564" data-nav-id="1611200362">Secondary storage</a></li>
			<li><a href="#1611499255" data-nav-id="1611200362">File system storage</a></li>
			<li><a href="#1608527531" data-nav-id="1611200362">Database</a><ul>
				<li><a href="#1608528587" data-nav-id="1611200362">Relational database, or RDBMS</a><ul>
					<li><a href="#1611407572" data-nav-id="1611200362">Database normalization</a></li>
				</ul></li>
				<li><a href="#1608529017" data-nav-id="1611200362">Non relational database, or NoSQL database</a></li>
				<li><a href="#1611510000" data-nav-id="1611200362">Schema</a></li>
				<li><a href="#1611510020" data-nav-id="1611200362">Transaction</a></li>
				<li><a href="#1611510040" data-nav-id="1611200362">CAP theorem</a></li>
				<li><a href="#1611510050" data-nav-id="1611200362">Relational vs Non relational database</a></li>
				<li><a href="#1611508641" data-nav-id="1611200362">Database vs File system</a></li>
			</ul></li>
			<li><a href="#1608530099" data-nav-id="1611200362">Cache</a></li>
		</ul>
	</nav>
	
	<h2>Data storage related terms</h2>
	<p id="1618627233">This page lists the various terms that relate to data storage. Although data storage is part of supporting infrastructure needed to host the web application, it is a bg topic in itself and so, it is discussed separately to cover the various related terms. </p>
	
	<h3>Why data storage?</h3>
	<p id="1611200928">An application capable of supporting a business must be able to interact with individual customer and provide services needed by them individually. Serving same set of data to everyone and everytime (..like this ebook) can't grow as a business because it ignores individual needs of someone who'd be willing to pay for the customized service. Additionally, recall that <a href="#1608922565" data-nav-id="1608303678">HTTP requests are in themselves stateless</a>., Thus, it is necessary to have a "data-repository" where user data can be save, and served back to the user at a later time.</p>
	
	<h3>Memory</h3>
	<p id="1611201475">(Reference: <a href="https://en.wikipedia.org/wiki/Computer_memory" target="_blank">Wikipedia</a>) Memory refers to a device that is used to store information for immediate use in a computer. The term "memory" is often synonymous with the term <a href="https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage" target="_blank">"primary storage"</a>. It operates at a high speed and is directly available to the CPU. An example of computer memory is a <a href="https://en.wikipedia.org/wiki/Random-access_memory" target="_blank">random-access memory</a> that allows data items to be read or written in almost the same amount of time irrespective of the physical location of data inside the memory. The flip side of this awesomeness is that it is very costly. As soon as the business gains some traction and the user data starts to increase, then it becomes exteremely costly to store all the data in memory. Worse, the data in memory is volatile and is lost when the power goes out.</p>
	
	<h3>Secondary storage</h3>
	<p id="1611202564"><a href="https://en.wikipedia.org/wiki/Computer_data_storage#Secondary_storage" target="_blank">Secondary storage</a> differs from <a href="#1611201475" data-nav-id="1611200362">primary storage</a> in that it is not directly accessible by the CPU. The computer usually uses its input/output channels to access secondary storage and transfer the desired data to primary storage. The data access rate for secondary storage is much less compared to that for primary storage, or memory. Although they are slow, secondary storage has a huge advantage of being non-volatile, i.e. it retains data when its power is shut off. Also, secondary storages are much cheaper compared to memory for storage of similar size data. For these reasons, secondary storage is primarily used to store data for a web application. In modern computers, <a href="https://en.wikipedia.org/wiki/Hard_disk_drive" target="_blank">hard disk drives (HDDs)</a> or <a href="https://en.wikipedia.org/wiki/Solid-state_drive" target="_blank">solid-state drives (SSDs)</a> are usually used as secondary storage. The access time per byte for HDDs or SSDs is typically measured in milliseconds (one thousandth seconds), while the access time per byte for primary storage is measured in nanoseconds (one billionth seconds). In between SSDs and HDDs, SSDs have smaller access time compared to HDDs, but are more costly; SSDs are still less costly compared to memory. For this reason, a web application may be designed to store frequently accessed or modified data in SSD storage, and move archived or unchanging data to HDDs. Other common options for secondary storage devices include USB flash drives, rotating optical storage devices (like, CDs and DVDs). </p>

	<h3>File system storage</h3>
	<p id="1611499255">(Reference: <a href="https://en.wikipedia.org/wiki/File_system" target="_blank">Filesystem</a>)  A file system or filesystem controls how data is stored and retrieved from storage. Without a file system, data placed in a storage medium would be one large body of data with no way to tell where one piece of data stops and the next begins. By separating the data into pieces and giving each piece a name, the data is easily isolated and identified. The file system is responsible for organizing files and directories, and keeping track of which areas of the media belong to which file and which are not being used. Various terms used in a computer file system closely follows the method of storing and retrieving paper documents before the advent of computers. For example, each group of data is called a "file", and collection of related data forms a "directory". This being said, the way a working computer file system works is more as a notebook with pages on which data can be ritten and an index section containing a mapping of file name and corresponding page number sequence.</p>
	<p id="1611502622">To understand it with an example, consider yourself as a note keeper. Let's say the first note you make is from your friends who asks you to save "This is the friend's note" with name "friend.txt". You do this by writing "This is the friend's note|" text on page-1 of your notebook, and marking in index that "friend.txt" entries are on page-1. The index in this example maps to an <a href="https://en.wikipedia.org/wiki/Inode" target="_blank">inode</a> in a <a href="https://en.wikipedia.org/wiki/Unix-like" target="_blank">Unix-like</a> file system, and the page maps to <a href="https://en.wikipedia.org/wiki/Disk_sector" target="_blank">disk sector</a>, and the file system in this example is you! Why the "|" sign at end - is discussed later. The reminder of page-1 is wasted space because you cannot use it to write any other note. This is called <a href="https://en.wikipedia.org/wiki/Slack_space" target="_blank">slack space</a>. At least on windows, I know that you can right click on a file, go down to "Properties" and then look at the number under "Size" and "Size on disk"; former will always be less than or equal to the latter. Sometime later, your friend asks you to get the note for "friend.txt". You first look at the index and see that the entry is on page-1. You go to page-1, read up to the first "|" sign, which is "This is friend's note|", and then return everything before the "|" sign. So you return "This is friend's note". That's the role of "|" sign, it marks the end of your note. In computer, the corollary is a <a href="https://en.wikipedia.org/wiki/Null-terminated_string" target="_blank">null termination character</a>. So you only read up to it. Alternately, in your index, you can store additional information about the total length of the file and then having "|" will not be needed. In computer file syetem, this maps to storing <a href="https://en.wikipedia.org/wiki/File_system#Metadata" target="_blank">metadata</a> in fle system. Additional uses of "|" sign is discussed later. Also note that if your friend asks to get the note for "new-note.txt", then you look at the index and don't find any entries, so you just say that you don't have that value.</p>
	<p id="1611503723">Your friend comes back and asks you to delete "friend.txt", so the index entry for page-1 is cleared. However, you do not clear the actual "This is friend's note|" data on page-1 because anyways if you're asked for "friend.txt" note, you won't find the entry in index and will say that the note is not found. So why waste extra time and energy actually clearing the data. Your friend now now asks you to write "new-note" and save it under "new-note.txt". You see page-1 is available and you write onto it "new-note|". But page-1 already had some old data. With new note written on same page, page-1 now reads "new-note|riend's note|", with new data overwritting the old data only as much needed. You also make an entry in the index that "new-note.txt" is on page-1. When your friend asks for "new-note.txt" data, you check the index to see that it is on page-1. On page-1, you now only read up to the first "|" sign, i.e. "new-note|", and return everything before "|", i.e. you return "new-note". Here, everything after the first "|", i.e. "riend's note|" is garbage data. Similar handling of data also happens in a computer file system where storage data is not proactively deleted when a file is deleted (<a href="https://searchstorage.techtarget.com/definition/solid-state-storage-SSS-garbage-collection" target="_blank">reference</a>).</p>
	<p id="1611503730">Now your sister asks you to store a poem under "sister.txt". It take complete page-2, page-3 and small part of page-4. In the index, you mark "sister.txt" with value 2, 3, 4. Just a small referesh, here, page-4 also has a slack space. Let's say your friend asks you to update "new-note.txt" and gives a long todo list to store. You write it on page-1. Then you notice that pages 2-4 are already filled and so you write the remaining story on page 5. You update the index with "new-note.txt" having values on page-1 and page- 5. Note that even though you can retrieve the "new-note.txt" and return it back to your friend as a single text, it is not necessary that it be stored in consecutive pages. You simply compensate for it by sequentially reading the data chunks regardless of whether they are consecutive or not. For whatever reason, you could have stored the todo list starting with page-5 and then write the remaining on page-1, and that's still ok because then, you'll read page-5 before page-1, and the index entry will also be updated correspondingly. For a computer file system to read thecomplete data stored in non consecutive disk sectors requires "hopping" from one to another sector and this is something that <a href="https://en.wikipedia.org/wiki/Solid-state_drive" target="_blank">SSDs</a> do faster than <a href="https://en.wikipedia.org/wiki/Hard_disk_drive" target="_blank">HDDs</a>, and that's why former is faster than latter. Let's say that your sister now asks you to delete "sister.txt". If you look at your friend's note, i.e. "new-note.txt", on how it's stored, you'll notice that even though it is a single file, it is starts on page-1 and then continues on page-5. There is no longer any non-garbage data on pages 2-4. Had your asked you to make the todo list after your sister deleted her poem, it would have been on pages 1-2. This is corollary to <a href="https://en.wikipedia.org/wiki/File_system_fragmentation" target="_blank">disk fragmentation</a>. Fragmentation naturally occurs when a file system has been in use for some time, and it hurts average speed of data retrieval from disk. At least for HDDs, having data on consecutive disck sectors reads much faster than if they are on different sectors.</p>

	<h3>Database</h3>
	<p id="1608527531">See article about databases on <a href="https://en.wikipedia.org/wiki/Database" target="_blank">Wikipedia</a> and on <a href="https://www.oracle.com/database/what-is-database/" target="_blank">Oracle</a>. When talking about a database, it is seen as a software enabling stage of user data that is structured in some manner, on server's <a href="#1611202564" data-nav-id="1611200362">secondary storage</a>. For example, let's say you are watching a Batman movie, and the corresponding data is <code>(you, Batman-movie)</code>. At a later time, maybe you'd be watching a Superman movie and your friend is the one who's now watching the Batman movie that you previously watched. The 2 new data are: <code>(you, Superman-movie)</code> and <code>(your-friend, Batman-movie)</code>. Here, a database is a software that enables collecting the information of movies being watched and the user watching it. Let's say that our "movie-viewer" tracking table in the database ends up having millions of entries and that is slowing down our ability to search for a particular data. To enable storing large amounts of data while keeping the read and write operations effiient, a database table can be <a href="https://www.sqlshack.com/database-table-partitioning-sql-server/" target="_blank">"sharded" or "partitioned" into smaller units</a> that deal with the table data in a smaller range. For example, if the movie name starts with A-N, then search in database table partition#1, else search in partition#2. So, just by the movie name, we'll know that the entry for "Batman-movie" (watched by you and later, by your friend) is in partition#1, and the entry for Superman-movie watched by you is in partition#2. Thus, in this example, the application's search speed became double after introduction of data partition (..somewhat like first step of <a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank">bucket sort</a>). Additionally, a "replica" of entire database can be made to provide fail-safe against data loss if for any reason the data in the database is lost or corrupted. Discussion on database vs file system is covered in a <a href="#1611508641" data-nav-id="1611200362">later section</a> after having understood about different database related terms.</p>

	<h4>Relational database, or RDBMS</h4>
	<p id="1608528587">See article about relational database on <a href="https://en.wikipedia.org/wiki/Relational_database" target="_blank">Wikipedia</a>. The "relational" adjective is used because the data stored within the database in a manner to bring out the relations between different pieces. Many relational database systems use SQL (Structured Query Language) for querying and maintaining the relational data in the database. Using the example of users and movies in previous section, note that the data contains "Batman-movie" twice because there is just 1 such movie which is watched twice. Is there a way to make this data feature visible? Maybe instead of just storing individual data as-is, we can make 3 "database-tables" of <code>viewer, movie, views</code>, with "viewer" table containing <code>you, your-friend</code> data, "movie" table containing <code>Batman-movie, Superman-movie</code> data, and "movie-view" containing <code>(viewer-1, movie-1), (viewer-1, movie-2), (viewer-2, movie-1)</code> data. This breakdown is now able to better convey the idea that the Batman-movie watched by you and your-friend is the same movie, and, is able to do so by bring out the relationship between various data elements.</p>
	<p id="1611406053">In addition to capturing and making visible the relationship between different data pieces, this also reduces data duplication. For example, if it is realized later that the "Batman-movie" is better identified instead as a "Batgirl-movie", then updating the data requires touching only 1 row in one table. Had the data been stored as-is and not in relational form, making this change would have required going through the entire database to make this update. Capturing data-relations also allows extending the data-model to easily include new relations. For example, let's say we want to capture the lead actors in the movie. Now, a new "actor" table can be made containing the actor name, and link to the movie they are in; And this can be done without touching the "movie", "viewer" or "movie-view" table. Here's a question: Can movie-actors be movie-viewers? Yes! So likely the "viewer" and "actor" table is having duplicate data. What is the best way to organize the data? For now, I'll say that answering the question depends on what the business needs are; That being said, there are different ways to break data. In doing so, one must understand and apply concepts from <a href="#1611407572" data-nav-id="1611200362">database normalization</a> discussed later.</p>
	<p id="1611408137">With its awesome advantages, storing data relationship also comes with a disadvantage that it can hurt performance. With above example, let's say that our business model is that user provides us with some "movie-view-id", and we return details about the movie and viewer. Now, everytime this call is made, the database with first look in "movie-view" table to get an entry for the provided "movie-view-id", which will be like <code>(viewer-1, movie-1)</code>. However, the user doesn't understand what "viewer-1" or "movie-1" means. So, the database will first go to "viewer" table to get the information for "viewer-1", which is <code>you</code>, and then to "movie" table to get the information for "movie-1", which is <code>Batman-movie</code>. Combining these data pieces, the user can now be told that the entry they are looking for is <code>(you, Batman-movie)</code>. Contrast it with the case if the data wasn't normalized and there was just one table with duplicated (viewer, movie) entry. It would have required just 1 database call to get the required information compared to making 3 calls and then <a href="https://en.wikipedia.org/wiki/Join_(SQL)" target="_blank">"joining"</a> the data-pieces together. That being said, relation database makes extensive use of <a href="https://en.wikipedia.org/wiki/Database_index" target="_blank">indexes</a> to speed up joins.</p>
	
	<h5>Database normalization</h4>
	<p id="1611407572">See article about database normalization on <a href="https://en.wikipedia.org/wiki/Database_normalization" target="_blank">Wikipedia</a>. Database normalization is the process of structuring the data stored in a relational database in order to reduce data redundancy and improve data integrity. Reducing data redundancy is important so that if the data is changed, then their will be just one unique place where the change needs to be made. If there is data redundancy, then all other places where the data is stored would need to be synced as soon as a change is made at any one place, and this is cumbersome and error prone. Or maybe the changes are not all done in single <a href="#1611510020" data-nav-id="1611200362">transaction</a> and so there can be small edge cases where they get out of sync. Presence of unsynced data can further snowball and wreak havoc on the consistency of data in other columns. While there are use cases for using a denormalized table, it is generally the case that using normalized design is better.</p>
	<p id="1613523454">The <a href="https://en.wikipedia.org/wiki/Database_normalization" target="_blank">Wikipedia</a> article is a great reference to understand about normalization, and particularly helpful is the <a href="https://en.wikipedia.org/wiki/Database_normalization#Example_of_a_step_by_step_normalization" target="_blank">example</a> section showing how to achieve different normal forms. Rather than repeating the same information and not doing a good job at it in a misguided attempt to shorten this important and length discussion, I strongly encourage the readers to refer to the article. In here, I would like to provide an alternate understanding of the normal forms. I did not see the "normal forms" being presented in this manner anywhere else, so there's a slight risk that I may be incorrect, or maybe I don't know of a proper reference. It does sound correct to me, but I ask readers to exercise caution. So, here it is: Using the <a href="https://en.wikipedia.org/wiki/Database_normalization#Example_of_a_step_by_step_normalization" target="_blank">example in the Wikipedia article</a>, application of 1NF can be seen as defining a "data" row in a database as something that should map to a "single" real world object and not have multiplicty within it. If some kind of data-multiplicity needs to be modeled, then that should instead be done by using a foreign key relation. With every real world object, some features can be defined that make it unique. For example, the name of this book "Productionizing backend development" is unique. But what if I write a new edition of same book? Then the combination of book name and its edition is unique. What defines a real world object as unique depends on the object and how it is used in context of business application, but there will always be some unique aspect to data. 2NF form can be seen as implying that other columns for a give database table row must relate to the "whole" unique combination. So, if (name, edition) defines the uniqueness of a book, then other columns in book table except the name and edition, must relate to the (name, edition) value, and not just to name or to edition alone. 3NF can be seen as making 2NF stricter and implying that all other columns for a database table row that don't form part of the unique combination, they must only relate to the unique combination and not have any relation to any other columns. Thus, except the columns used in the unique combination, other columns for a row can take any possible value. This helps in better identifying the features of real world object that makes it unique and different from others. 4NF onwards the focus not goes to the unique combination. 4NF can be seen as requiring that the unique combination cannot be decomposed further into independent tables. 5NF makes this stricter and requires that the columns in unique combination should not have any relations; Each column of unique combination can take any value possible. As mentioned in the Wikipedia article, a database table in 5NF is one that is truly "normalized". Going to 6NF is based on realization that every column can itself be changed to a 1-column table (along with an extra id rown in each table), and the data-record table simple contains foreign key to these extremely slim tables. For a record-based design, as is the case with the <a href="#1613521031" data-nav-id="1608303678">OLTP</a> requests, this creates performance unnecessary overheads. I agree with the article's suggestion of going up to 5NF, i.e. fifth normal form, when designing database schema.</p>
	<p id="1613709139">To highlight an important point that was quickly mentioned above and wasn't emphasized more: <strong>When designing your tables, always seek to identify the combination of fields in a record that make it unique.</strong> It may not be always possible, but that's for very very few cases, but much more often than not, it should be possible to do so. Since real world data almost always have a unique reason on why it is made, having a unique combination in a data record is a way of acknowledging the cause for creating the data. This also aligns with one of the main goals of database normalization which is to remove data redundancy. An additional benefit of doing so is that it provides stability under concurrent request processing, i.e., if multiple requests comes to server at same time to add same data, then only the first of those requests will get processed. Any subsequent ones will fal because the database will report failure of uniqueness constraint since a record with intended data already exists in the database.</p>

	<h4>Non relational database, or NoSQL database</h4>
	<p id="1608529017">See article about non relational database on <a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank">Wikipedia</a>, <a href="https://www.mongodb.com/nosql-explained" target="_blank">MongoDB</a> and <a href="https://aws.amazon.com/nosql/" target="_blank">AWS</a>. In the previous discussion on relational database, it is identified that doing so promote data integrity and reduces data duplication (<a href="#1611406053" data-nav-id="1611200362">here</a>), but it comes at cost of performance (<a href="#1611408137" data-nav-id="1611200362">here</a>). Non-relational database takes the other route, prioritizing performance over relations. Although most articles further decompose non relational database further in four subtypes, i.e. as a key–value pair store, wide column or a column-family store, document-store or graph store, I believe that the non-relation database is best seen as a key-value store. Period. If the value becomes a xml or json document containing multiple fields then the non-relational database becomes a <a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank">document-oriented database</a>. If instead of one "document", the database allows for multiple documents with similar structure and that can be identified based on a certain value, then it becomes a <a href="https://en.wikipedia.org/wiki/Wide-column_store" target="_blank">column-family store</a>. Take a key-value pair non-relational database and also store the relations between any 2 values (Reference: <a href="https://neo4j.com/developer/graph-db-vs-rdbms/#rdbms-graph-model" target="_blank">Neo4j docs</a>), and it becomes a <a href="https://en.wikipedia.org/wiki/Graph_databases" target="_blank">graph database</a>. At the end of day, each non-relaion database will require you to give it a key, for which it will give a "value" back. I will add that different non-relational database are tuned to solving a specific problem and using a Graph database where a document database is needed, or vice versa is not recommended. It is the special utilities that each of them provide that make one more preferable than others when targeting a particular business need. However, on a theoretical level, all of them share the common feature of being a key-value store in some way. Since the primary use case for using a non-relational databases is to achieve a quick store or retrieval of high volume key-value like data coming at very high rate, the non-relational databases are designed so that it can be scaled out horizontally in a very quick and easy manner. Similar to their relational counterpart, the non-relational database can be "partitioned", so that the key value lying in a particular range is stored in a particular node; Doing so further helps with improving the database performance.</p>

	<h4>Schema</h4>
	<p id="1611510000">The first step towards database design is to identify the structure of the information to be held in the database, also called the <a href="https://en.wikipedia.org/wiki/Conceptual_schema" target="_blank">conceptual data model</a>. Using the business requirements as inputs, this step aims to identify real-world entities with which the business will interact, and the relationships and constraints among/within entities. <a href="https://martinfowler.com/bliki/DomainDrivenDesign.html" target="_blank">Domain driven design</a> is applied in this stage. In the next step, the conceptual data model entities are further developed to <a href="#1611407572" data-nav-id="1611200362">normalize</a> the structure, or they can be denormalized if that matches business needs. Individual properties associated with each entity is identified, and the relations and constrainst among/within entities is defined in terms of these columns. This is the <a href="https://en.wikipedia.org/wiki/Logical_schema" target="_blank">logical data model</a>. Finally, database specific commands are used to create tables, thereby, realizing the logical data model. The <a href="https://en.wikipedia.org/wiki/Database_schema" target="_blank">database schema</a> is this final structure that mirrors the logical data model and is described in a formal language supported by the database. At this point, the database is ready to receive user data.</p>
	<p id="1611510010">In addition to tables, columns, constraints and relations, the database schema defines many other terms. One important term used extensively in backend development is an "index". A <a href="https://en.wikipedia.org/wiki/Database_index" target="_blank">database index</a> is a data structure, separate from tables, that is constructed using values of one or more columns for all rows. It improves the speed of data retrieval operations on a database table by identifying the row(s) containing a particular value for the column(s). Since it is a separate structure, it costs additonal space and it also needs to be updated everytime a new row is added/deleted. They are particularly useful if the business application has more reads than writes. In relational databases, an index is automatically made for the primary key because it helps with speeding up <a href="https://en.wikipedia.org/wiki/Join_(SQL)" target="_blank">joining</a> different relations. Note that while the use of indexes is standard in relational database to achieve performance boost, its use among the non relational databases is not consistent (Reference: <a href="https://stackoverflow.com/questions/10085022/do-nosql-databases-use-or-need-indexes" target="_blank">Stackoverflow</a>). As discussed <a href="#1608529017" data-nav-id="1611200362">previously</a>, all non relational databases can be thought of as a key-value store. Their primary use case is that they'll be provided with a particular key, for which they need to return the corresponding value. This allows them to store a large amount of data and at a fast throughput rate. That being said, specific non relational database implementation may choose to provide custom utilities, one of them being the ability to create index over content of the values. Most likely, it is because the value (for a given key) is in a semi-structured form and allows creating indexes; Or, because the database is designed for use cases where the total count of individual keys won't be so large to preclude having some indexing data structure; Or because the column being indexed on will not have lot of unique values. Even when a database implementation allows creating index, it is strongly suggested to rethink if an index should be made and used for the volume and throughput of data that the application will see because doing so for non relational databases will immediately start showing up in degraded performance.</p>
	
	<h4>Transaction</h4>
	<p id="1611510020">A <a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank">database transaction</a> symbolizes a logical unit of work, made up of one or multiple operations, performed against a database. This operations in a transaction can include either only reading data from database, or making changes to database entries, or do both read and write operations. A database transaction, by definition, must be atomic (it must either complete in its entirety or have no effect whatsoever), consistent (it must conform to existing constraints in the database), isolated (it must not affect other transactions) and durable (it must get written to persistent storage). Atomicity and durability properties of a transaction enables data reliability in recovering from failures, i.e. if the database stops working and is then restarted, then the data in the databse would represent a transaction as either been applied or not applied in its entirity. The isolation property enables having a reliable outcome as a result of concurrent read and/or write operations done "concurrently" on the database; That being said, a fully concurrent safe processing is also slow on performance and so, SQL standard itself allows for different isolation levels having corresponding performance behavior, with <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_uncommitted" target="_blank">uncommitted reads</a> being very quick but allowing for unsafe data read, and <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Serializable" target="_blank">serializable processing</a> being slowest and strongest among the isolation levels. Note that the default behavior of almost all database is to NOT perform the transaction with the strongest isolation guarentee. These four properties are commonly referred using the acronym of <a href="https://en.wikipedia.org/wiki/ACID" target="_blank">ACID</a> properties.</p>
	<p id="1612128885">A really good reference to understand about how ACID guarantees are preserved for a transaction is <a href="http://web.archive.org/web/20120827100207/http://www.cbare.org/writing/Transactions/transactions.html" target="_blank">here</a>, and the link was itself obtained from <a href="https://stackoverflow.com/questions/3466632/database-transactions-how-do-they-work" target="_blank">this StackOverflow post</a>. A "transaction manager" is the central component that enables transaction processing. It can be used in the database itself to enable database changes being carried ot as a transaction. If needed, a manager can also be used in the application code to coordinate a <a href="https://en.wikipedia.org/wiki/Distributed_transaction" target="_blank">distributed transaction</a> involving multiple database, or message queue, or any other components enabling transaction. Managers for distributed transactions leverage different mechanisms like <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank">2 Phase commit</a> or a more robust <a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank">3 phase commit</a> to ensure that corresponding changes are made in all components involved in the distributed transaction. Within a transaction, isolation in achieved by using read/write locks at table or page or row level; It can also be simulated on the database record by either using optimistic locking or pessimistic locking depending on the use case (locking reference: <a href="https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking" target="_blank">a StackOverflow post</a>, <a href="https://convincedcoder.com/2018/09/01/Optimistic-pessimistic-locking-sql/" target="_blank">a blog post</a>). Atomicity and durability is enabled primarily via use of a <a href="https://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank">write ahead log</a>.</p>
	<p id="1612131223">What about non relational databases having transactions? - This is where the field of non-relational databases become so big that having a single answer is not possible. As discussed in <a href="https://stackoverflow.com/questions/2608103/is-there-any-nosql-data-store-that-is-acid-compliant/22105320" target="_blank">this StackOverflow post</a>, there are certain non relational databases that allow transactions with ACID guarantee. That being said, most of the online discussions on non-relational databases allowing transactions with ACID guarantee mix it up with discussion of CAP theorem (discussed next), which, to me, is not a correct path to follow. Due to the two concepts getting repeatedly mixed when discussing non-relational database,this question is revisited under the discussion on CAP theorem.</p>
	
	<h4>CAP theorem</h5>
	<p id="1611510040">The <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank">CAP theorem</a>, also named Brewer's theorem, states that it is impossible <strong>for a distributed data store</strong> to simultaneously provide more than two out of the following three guarantees: Consistency (i.e., every read receives the most recent write or an error), Availability (i.e., every request receives a non-error response, without the guarantee that it contains the most recent write), and Partition tolerance (i.e., the system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes). Since in the real world cases, systems partition failures are rare, so the design generally comes down to identifying whether sacrificing consistency or availability would be in best interest of the business use case. A quick note: the "consistency" as defined in the CAP theorem is very different from the consistency guaranteed in <a href="#1611510020" data-nav-id="1611200362">ACID database transactions</a>, see this <a href="https://en.wikipedia.org/wiki/Consistency_(database_systems)#As_a_CAP_trade-off" target="_blank">reference</a>.</p>
	<p id="1612134800">As discussed <a href="#1608529017" data-nav-id="1611200362">previously</a>, the primary use case for using a non-relational databases is to achieve a quick store or retrieval of high volume data coming at very high rate, and also that they can primarily be seen as a key-value store. For this reason, non-relational databases are designed so that it can be scaled out horizontally in a very quick and easy manner, and because of the "distributed" nature, CAP theorem applies to non-relational databases. What is unfortunate though is that application of CAP is used as a reason to justify that non-relational databases don't provide ACID guarantees! If each node forming the distributed non-relational database is made to perform data updates via <a href="#1612128885" data-nav-id="1611200362">a distributed transaction, as described above</a>, then the non-relational database will be able to provide ACID guarantees, but it will then come with terribly huge performance degradation because 2PC is a blocking protocol. Non-relational databases are also set up with the use case that some or more nodes will keep failing but the system should be robust enough to stay up. (To my limited knowledge..) Hence, alternate protocols like <a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)" target="_blank">Paxos</a> and <a href="https://en.wikipedia.org/wiki/Raft_(algorithm)" target="_blank">RAFT</a> are used for distributed datastore nodes to conflict resolution with each other and to form consensus on state of the data. <a href="https://stackoverflow.com/questions/2608103/is-there-any-nosql-data-store-that-is-acid-compliant/3014601#3014601" target="_blank">This StackOverflow answer</a> is one of the few posts I've seen that clarifies the air between ACID vs CAP which otherwise fills lot of other online discussions.</p>
	<p id="1612134871">Another ACID vs CAP confusion to avoid when referring to the posts about non-relational database, is that when a claim is made, like, the non-relation database has row level atomicity, or column level atomicity, etc. then it should not be taken as implying that non-relational databases provide ACID guarantees but with different atomicity, nor that they allow transactions. For one, ACID guarantees are associated with transaction and not the database. However, the atomicity level as mentioned for the database must be kept in consideration when designing the application logic and it must be ensured that any edge cases will not end up ngatively affecting the business use case any more than some allowed limit.</p>
	
	<h4>Relational vs Non relational database</h5>
	<p id="1611510050">With the database category being named as "relational" or "non-relational", it seems very easy to make a <a href="https://www.vocabulary.com/dictionary/reductive" target="_blank">reductive argument</a> that if relations are needed, use relational database, and use non-relational ones for semi-structured or unstructured data because they don't enforce relations! But what if I use Oracle database, a relational database, and make a table containing 2 columns, a numeric "id" and a text storing column where I store xml or json? It is storing semi-structured information now. Even better, it can store both xml and json! Relational database is about storing relations, and graph database also stores relations, and latter is non-relational database. Or how about I use a non-relation database, like Cassandra, which is a column family store, and programmatically store data within it in a normalized form? I can, and the database will store it. And opposite to it, I can take an Oracle database and make denormalized tables, and use it to store denormalized data, and it will still work. So, what's the difference between the two? To me, the difference between the two is not about "what is one that is not in another", but instead, "what one can do better, out of the box, without less work from developers, that the other", an also which suits the use case better. If your business requires good data integrity and an ability to expand database tables as the business grows and the data model gets richer and complex, go with relational database. If your business is getting hosed with data, and the user just expects you to save it, then using a key-value store is a good way to proceed. Another important question to ask is if your business processing needs require having a <a href="#1611510020" data-nav-id="1611200362">multi-table transaction allowing ACID guarantees</a>? That is provided by relational databases. If using distributed databases, whcih happens when using non-relational databases, then ensure that the business requirements are compatible with <a href="#1611510040" data-nav-id="1611200362">CAP</a> restrictions. One more note: this <a href="https://medium.com/moveax/how-postgresql-replication-works-6288b3e6000e" target="_blank">Medium post</a> describes how replication works for PostgreSQL. Going over it is highly instructive to gain an understanding of related terms discussed above.</p>
	
	<h4>Database vs File system</h4>
	<p id="1611508641">Here's a question: In <a href="#1608527531" data-nav-id="1611200362">above example of database</a>, why don't I simply make a directory called "database", and within it I store 3 files, "watch-1" file containing data (you, Batman-movie), "watch-2" file containing data (you, Superman-movie), and "watch-3" file containing data (your-friend, Batman-movie). It seems like all needs met by a database are captured and there isn't any more a need to pay any company for their proprietary database software. To me, the best answers for <a href="#1608527531" data-nav-id="1611200362">database</a> vs <a href="#1611499255" data-nav-id="1611200362">file system</a> are mentioned in these 2 StackOverflow posts: <a href="https://stackoverflow.com/questions/38120895/database-vs-file-system-storage/64654674#64654674" target="_blank">here</a> and <a href="https://stackoverflow.com/questions/38120895/database-vs-file-system-storage/43910719#43910719" target="_blank">here</a>. A huge benefit provided by database software is that rather than making huge amount of small files and bogging down the OS and filesystem performance, it manages the data storage to be able to save millions of record and without hurting filesystem performance. It also provides additional services that can be used out of the box, like having a <a href="#1611510020" data-nav-id="1611200362">transaction with ACID guarantees</a>, creation and automatic update of <a href="#1611510010" data-nav-id="1611200362">indexes</a> to improve search performance, performance optimization by using system memory to store frequently used data and relatively easier management of <a href="#1611510000" data-nav-id="1611200362">database schema</a>. It is these additional services compared to a filesystem that using database is preferable for storing small data pieces.</p>
	
	<h3>Cache</h3>
	<p id="1608530099">See article about cahces on <a href="https://en.wikipedia.org/wiki/Cache_(computing)" target="_blank">Wikipedia</a>, <a href="https://aws.amazon.com/caching/" target="_blank">AWS</a>. A cache is a <strong>hardware or software</strong> component that stores data so that future requests for that data can be served faster; the data stored in a cache might be the result of an earlier computation or a copy of data stored elsewhere. An important precaution when using cache is to ensure that stale data is not being sent to user in a manner unexpected by user. Hardware components can include adding a hard disk drive (HDD) if one wasn't previously available, or upgrading from a HDD to solid state drive (SSD) or memory. Caches can be set up anywhere there is a temporal correlation in responses. It enables speeding up the overall processing by returning a previous copy of the response ather than the alternate process of re-computing the response result from zero. A "cache hit" occurs when the requested data can be found in a cache, while a cache miss occurs when it cannot. For the cache to improve the overall processing response, its size should be of the order of request rate multiplied by the temporal correlation period of the response. Hence, for a highly repeating request, having even a small size cache would be sufficent to notice improvements, but for high request rate or not repeating request, even a large size cache wouldn't be helpful. As the cache gets full, it starts to remove old (i.e., least recently used) or unused (i.e., least frequently used) data on a "cache miss", so that new data can be stored, with the expectation that it will get requested for again. The process of removing data from cache is called "evication".Reuse of cache data defines its "hit rate". Optimizing a cache involves analyzing the way cahce is used to ensure a high hit rate and with a low eviction rate (to get the benefit of cache use rather than terms getting constantly evicted and then re-loaded). A cache can also be distributed wherein one cache node returns data corresponding to a particular "shard" or "partition" of entire dataset. A cache can be added at various places during request processing, like, to store data pulled from database, or to store user profile for corresponding cookie, or even <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank">at front end to reuse previous responses</a>. They can even be used as in-memory NoSQL datastore (<a href="https://www.infoq.com/news/2011/11/distributed-cache-nosql-data-sto/" target="_blank">reference</a>).</p>
	
</article>