<!--
    HTML book section: Data storage related term glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Data storage related terms</h2>
	<p>This page lists the various terms that relate to data storage. Although data storage is part of supporting infrastructure needed to host the web application, it is a bg topic in itself and so, it is discussed separately to cover the various related terms. </p>
	
	<h3>Why data storage?</h3>
	<p id="1611200928">An application capable of supporting a business must be able to interact with individual customer and provide services needed by them individually. Serving same set of data to everyone and everytime (..like this ebook) can't grow as a business because it ignores individual needs of someone who'd be willing to pay for the customized service. Additionally, recall that <a href="#1608922565" data-nav-id="1608303678">HTTP requests are in themselves stateless</a>., Thus, it is necessary to have a "data-repository" where user data can be save, and served back to the user at a later time.</p>
	
	<h3>Memory</h3>
	<p id="1611201475">(Reference: <a href="https://en.wikipedia.org/wiki/Computer_memory" target="_blank">Wikipedia</a>) Memory refers to a device that is used to store information for immediate use in a computer. The term "memory" is often synonymous with the term <a href="https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage" target="_blank">"primary storage"</a>. It operates at a high speed and is directly available to the CPU. An example of computer memory is a <a href="https://en.wikipedia.org/wiki/Random-access_memory" target="_blank">random-access memory</a> that allows data items to be read or written in almost the same amount of time irrespective of the physical location of data inside the memory. The flip side of this awesomeness is that it is very costly. As soon as the business gains some traction and the user data starts to increase, then it becomes exteremely costly to store all the data in memory. Worse, the data in memory is volatile and is lost when the power goes out.</p>
	
	<h3>Secondary storage</h3>
	<p id="1611202564"><a href="https://en.wikipedia.org/wiki/Computer_data_storage#Secondary_storage" target="_blank">Secondary storage</a> differs from <a href="#1611201475" data-nav-id="1611200362">primary storage</a> in that it is not directly accessible by the CPU. The computer usually uses its input/output channels to access secondary storage and transfer the desired data to primary storage. The data access rate for secondary storage is much less compared to that for primary storage, or memory. Although they are slow, secondary storage has a huge advantage of being non-volatile, i.e. it retains data when its power is shut off. Also, secondary storages are much cheaper compared to memory for storage of similar size data. For these reasons, secondary storage is primarily used to store data for a web application. In modern computers, <a href="https://en.wikipedia.org/wiki/Hard_disk_drive" target="_blank">hard disk drives (HDDs)</a> or <a href="https://en.wikipedia.org/wiki/Solid-state_drive" target="_blank">solid-state drives (SSDs)</a> are usually used as secondary storage. The access time per byte for HDDs or SSDs is typically measured in milliseconds (one thousandth seconds), while the access time per byte for primary storage is measured in nanoseconds (one billionth seconds). In between SSDs and HDDs, SSDs have smaller access time compared to HDDs, but are more costly; SSDs are still less costly compared to memory. For this reason, a web application may be designed to store frequently accessed or modified data in SSD storage, and move archived or unchanging data to HDDs. Other common options for secondary storage devices include USB flash drives, rotating optical storage devices (like, CDs and DVDs). </p>

	<h3>File system storage</h3>
	<p id="1611499255">(Reference: <a href="https://en.wikipedia.org/wiki/File_system" target="_blank">Filesystem</a>)  A file system or filesystem controls how data is stored and retrieved from storage. Without a file system, data placed in a storage medium would be one large body of data with no way to tell where one piece of data stops and the next begins. By separating the data into pieces and giving each piece a name, the data is easily isolated and identified. The file system is responsible for organizing files and directories, and keeping track of which areas of the media belong to which file and which are not being used. Various terms used in a computer file system closely follows the method of storing and retrieving paper documents before the advent of computers. For example, each group of data is called a "file", and collection of related data forms a "directory". This being said, the way a working computer file system works is more as a notebook with pages on which data can be ritten and an index section containing a mapping of file name and corresponding page number sequence.</p>
	<p id="1611502622">To understand it with an example, consider yourself as a note keeper. Let's say the first note you make is from your friends who asks you to save "This is the friend's note" with name "friend.txt". You do this by writing "This is the friend's note|" text on page-1 of your notebook, and marking in index that "friend.txt" entries are on page-1. The index in this example maps to an <a href="https://en.wikipedia.org/wiki/Inode" target="_blank">inode</a> in a <a href="https://en.wikipedia.org/wiki/Unix-like" target="_blank">Unix-like</a> file system, and the page maps to <a href="https://en.wikipedia.org/wiki/Disk_sector" target="_blank">disk sector</a>, and the file system in this example is you! Why the "|" sign at end - is discussed later. The reminder of page-1 is wasted space because you cannot use it to write any other note. This is called <a href="https://en.wikipedia.org/wiki/Slack_space" target="_blank">slack space</a>. At least on windows, I know that you can right click on a file, go down to "Properties" and then look at the number under "Size" and "Size on disk"; former will always be less than or equal to the latter. Sometime later, your friend asks you to get the note for "friend.txt". You first look at the index and see that the entry is on page-1. You go to page-1, read up to the first "|" sign, which is "This is friend's note|", and then return everything before the "|" sign. So you return "This is friend's note". That's the role of "|" sign, it marks the end of your note. In computer, the corollary is a <a href="https://en.wikipedia.org/wiki/Null-terminated_string" target="_blank">null termination character</a>. So you only read up to it. Alternately, in your index, you can store additional information about the total length of the file and then having "|" will not be needed. In computer file syetem, this maps to storing <a href="https://en.wikipedia.org/wiki/File_system#Metadata" target="_blank">metadata</a> in fle system. Additional uses of "|" sign is discussed later. Also note that if your friend asks to get the note for "new-note.txt", then you look at the index and don't find any entries, so you just say that you don't have that value.</p>
	<p id="1611503723">Your friend comes back and asks you to delete "friend.txt", so the index entry for page-1 is cleared. However, you do not clear the actual "This is friend's note|" data on page-1 because anyways if you're asked for "friend.txt" note, you won't find the entry in index and will say that the note is not found. So why waste extra time and energy actually clearing the data. Your friend now now asks you to write "new-note" and save it under "new-note.txt". You see page-1 is available and you write onto it "new-note|". But page-1 already had some old data. With new note written on same page, page-1 now reads "new-note|riend's note|", with new data overwritting the old data only as much needed. You also make an entry in the index that "new-note.txt" is on page-1. When your friend asks for "new-note.txt" data, you check the index to see that it is on page-1. On page-1, you now only read up to the first "|" sign, i.e. "new-note|", and return everything before "|", i.e. you return "new-note". Here, everything after the first "|", i.e. "riend's note|" is garbage data. Similar handling of data also happens in a computer file system where storage data is not proactively deleted when a file is deleted (<a href="https://searchstorage.techtarget.com/definition/solid-state-storage-SSS-garbage-collection" target="_blank">reference</a>).</p>
	<p id="1611503730">Now your sister asks you to store a poem under "sister.txt". It take complete page-2, page-3 and small part of page-4. In the index, you mark "sister.txt" with value 2, 3, 4. Just a small referesh, here, page-4 also has a slack space. Let's say your friend asks you to update "new-note.txt" and gives a long todo list to store. You write it on page-1. Then you notice that pages 2-4 are already filled and so you write the remaining story on page 5. You update the index with "new-note.txt" having values on page-1 and page- 5. Note that even though you can retrieve the "new-note.txt" and return it back to your friend as a single text, it is not necessary that it be stored in consecutive pages. You simply compensate for it by sequentially reading the data chunks regardless of whether they are consecutive or not. For whatever reason, you could have stored the todo list starting with page-5 and then write the remaining on page-1, and that's still ok because then, you'll read page-5 before page-1, and the index entry will also be updated correspondingly. For a computer file system to read thecomplete data stored in non consecutive disk sectors requires "hopping" from one to another sector and this is something that <a href="https://en.wikipedia.org/wiki/Solid-state_drive" target="_blank">SSDs</a> do faster than <a href="https://en.wikipedia.org/wiki/Hard_disk_drive" target="_blank">HDDs</a>, and that's why former is faster than latter. Let's say that your sister now asks you to delete "sister.txt". If you look at your friend's note, i.e. "new-note.txt", on how it's stored, you'll notice that even though it is a single file, it is starts on page-1 and then continues on page-5. There is no longer any non-garbage data on pages 2-4. Had your asked you to make the todo list after your sister deleted her poem, it would have been on pages 1-2. This is corollary to <a href="https://en.wikipedia.org/wiki/File_system_fragmentation" target="_blank">disk fragmentation</a>. Fragmentation naturally occurs when a file system has been in use for some time, and it hurts average speed of data retrieval from disk. At least for HDDs, having data on consecutive disck sectors reads much faster than if they are on different sectors.</p>

	<h3>Database</h3>
	<p id="1608527531">See article about databases on <a href="https://en.wikipedia.org/wiki/Database" target="_blank">Wikipedia</a> and on <a href="https://www.oracle.com/database/what-is-database/" target="_blank">Oracle</a>. When talking about a database, it is seen as a software enabling stage of user data that is structured in some manner, on server's <a href="#1611202564" data-nav-id="1611200362">secondary storage</a>. For example, let's say you are watching a Batman movie, and the corresponding data is <code>(you, Batman-movie)</code>. At a later time, maybe you'd be watching a Superman movie and your friend is the one who's now watching the Batman movie that you previously watched. The 2 new data are: <code>(you, Superman-movie)</code> and <code>(your-friend, Batman-movie)</code>. Here, a database is a software that enables collecting the information of movies being watched and the user watching it. Let's say that our "movie-viewer" tracking table in the database ends up having millions of entries and that is slowing down our ability to search for a particular data. To enable storing large amounts of data while keeping the read and write operations effiient, a database table can be "sharded" or "partitioned" into smaller units that deal with the table data in a smaller range. For example, if the movie name starts with A-N, then search in database table partition#1, else search in partition#2. So, just by the movie name, we'll know that the entry for "Batman-movie" (watched by you and later, by your friend) is in partition#1, and the entry for Superman-movie watched by you is in partition#2. Thus, in this example, the application's search speed became double after introduction of data partition (..somewhat like first step of <a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank">bucket sort</a>). Additionally, a "replica" of entire database can be made to provide fail-safe against data loss if for any reason the data in the database is lost or corrupted. Discussion on database vs file system is covered in a <a href="#1611508641" data-nav-id="1611200362">later section</a> after having understood about different database related terms.</p>

	<h4>Relational database, or RDBMS</h4>
	<p id="1608528587">See article about relational database on <a href="https://en.wikipedia.org/wiki/Relational_database" target="_blank">Wikipedia</a>. The "relational" adjective is used because the data stored within the database in a manner to bring out the relations between different pieces. Many relational database systems use SQL (Structured Query Language) for querying and maintaining the relational data in the database. Using the example of users and movies in previous section, note that the data contains "Batman-movie" twice because there is just 1 such movie which is watched twice. Is there a way to make this data feature visible? Maybe instead of just storing individual data as-is, we can make 3 "database-tables" of <code>viewer, movie, views</code>, with "viewer" table containing <code>you, your-friend</code> data, "movie" table containing <code>Batman-movie, Superman-movie</code> data, and "movie-view" containing <code>(viewer-1, movie-1), (viewer-1, movie-2), (viewer-2, movie-1)</code> data. This breakdown is now able to better convey the idea that the Batman-movie watched by you and your-friend is the same movie, and, is able to do so by bring out the relationship between various data elements.</p>
	<p id="1611406053">In addition to capturing and making visible the relationship between different data pieces, this also reduces data duplication. For example, if it is realized later that the "Batman-movie" is better identified instead as a "Batgirl-movie", then updating the data requires touching only 1 row in one table. Had the data been stored as-is and not in relational form, making this change would have required going through the entire database to make this update. Capturing data-relations also allows extending the data-model to easily include new relations. For example, let's say we want to capture the lead actors in the movie. Now, a new "actor" table can be made containing the actor name, and link to the movie they are in; And this can be done without touching the "movie", "viewer" or "movie-view" table. Here's a question: Can movie-actors be movie-viewers? Yes! So likely the "viewer" and "actor" table is having duplicate data. What is the best way to organize the data? For now, I'll say that answering the question depends on what the business needs are; That being said, there are different ways to break data. In doing so, one must understand and apply concepts from <a href="#1611407572" data-nav-id="1611200362">database normalization</a> discussed later.</p>
	<p id="1611408137">With its awesome advantages, storing data relationship also comes with a disadvantage that it can hurt performance. With above example, let's say that our business model is that user provides us with some "movie-view-id", and we return details about the movie and viewer. Now, everytime this call is made, the database with first look in "movie-view" table to get an entry for the provided "movie-view-id", which will be like <code>(viewer-1, movie-1)</code>. However, the user doesn't understand what "viewer-1" or "movie-1" means. So, the database will first go to "viewer" table to get the information for "viewer-1", which is <code>you</code>, and then to "movie" table to get the information for "movie-1", which is <code>Batman-movie</code>. Combining these data pieces, the user can now be told that the entry they are looking for is <code>(you, Batman-movie)</code>. Contrast it with the case if the data wasn't normalized and there was just one table with duplicated (viewer, movie) entry. It would have required just 1 database call to get the required information compared to making 3 calls and then <a href="https://en.wikipedia.org/wiki/Join_(SQL)" target="_blank">"joining"</a> the data-pieces together. That being said, relation database makes extensive use of <a href="https://en.wikipedia.org/wiki/Database_index" target="_blank">indexes</a> to speed up joins.</p>
	
	<h5>Database normalization</h4>
	<p id="1611407572">See article about database normalization on <a href="https://en.wikipedia.org/wiki/Database_normalization" target="_blank">Wikipedia</a>. Database normalization is the process of structuring the data stored in a relational database in order to reduce data redundancy and improve data integrity. The Wikipedia article is a great reference, particularly the <a href="https://en.wikipedia.org/wiki/Database_normalization#Example_of_a_step_by_step_normalization" target="_blank">example</a> section. Rather than repeating the same information and not doing a good job at it in a misguided attempt to shorten this important and length discussion, I strongly encourage the readers to refer to the article. In here, I would like to provide an alternate understanding of the normal forms. I did not see the "normal forms" being presented in this manner anywhere else, so there's a slight risk that I may be incorrect, or maybe I don't know of a proper reference. It does sound correct to me, but I ask readers to exercise caution. So, here it is: Using the <a href="https://en.wikipedia.org/wiki/Database_normalization#Example_of_a_step_by_step_normalization" target="_blank">example in the Wikipedia article</a>, application of 1NF can be seen as defining a "data" row in a database as something that should map to a "single" real world object and not have multiplicty within it. If some kind of data-multiplicity needs to be modeled, then that should instead be done by using a foreign key relation. With every real world object, some features can be defined that make it unique. For example, the name of this book "Productionizing backend development" is unique. But what if I write a new edition of same book? Then the combination of book name and its edition is unique. What defines a real world object as unique depends on the object and how it is used in context of business application, but there will always be some unique aspect to data. 2NF form can be seen as implying that other columns for a give database table row must relate to the "whole" unique combination. So, if (name, edition) defines the uniqueness of a book, then other columns in book table except the name and edition, must relate to the (name, edition) value, and not just to name or to edition alone. 3NF can be seen as making 2NF stricter and implying that all other columns for a database table row that don't form part of the unique combination, they must only relate to the unique combination and not have any relation to any other columns. Thus, except the columns used in the unique combination, other columns for a row can take any possible value. This helps in better identifying the features of real world object that makes it unique and different from others. 4NF onwards the focus not goes to the unique combination. 4NF can be seen as requiring that the unique combination cannot be decomposed further into independent tables. 5NF makes this stricter and requires that the columns in unique combination should not have any relations; Each column of unique combination can take any value possible. As mentioned in the Wikipedia article, a database table in 5NF is one that is truly "normalized". To me, 6NF takes normalization farther than needed by separating out every column in separate table, and then forming the real world object by joining all the columns - this is too granular!! I suggest aspiring up to 5NF, i.e. fifth normal form.</p>

	<h4>Non relational database, or NoSQL database</h4>
	<p id="1608529017">See article about non relational database on <a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank">Wikipedia</a>, <a href="https://www.mongodb.com/nosql-explained" target="_blank">MongoDB</a> and <a href="https://aws.amazon.com/nosql/" target="_blank">AWS</a>. in the previous discussion on relational database, it is identified that doing so promote data integrity and reduces data duplication (<a href="#1611406053" data-nav-id="1611200362">here</a>), but it comes at cost of performance (<a href="#1611408137" data-nav-id="1611200362">here</a>). Non-relational database takes the other route, prioritizing performance over relations. Although most articles further decompose non relational database further in four subtypes, i.e. as a key–value pair store, wide column or a column-family store, document-store or graph store, I believe that the non-relation database is best seen as a key-value store. Period. If the value becomes a xml or json document containing multiple fields then the non-relational database becomes a <a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank">document-oriented database</a>. If instead of one "document", the database allows for multiple documents with similar structure and that can be identified based on a certain value, then it becomes a <a href="https://en.wikipedia.org/wiki/Wide-column_store" target="_blank">column-family store</a>. Take a key-value pair non-relational database and also store the relations between any 2 values (Reference: <a href="https://neo4j.com/developer/graph-db-vs-rdbms/#rdbms-graph-model" target="_blank">Neo4j docs</a>), and it becomes a <a href="https://en.wikipedia.org/wiki/Graph_databases" target="_blank">graph database</a>. At the end of day, each non-relaion database wil require you to give it a key, for which it will give a "value" back. I will add that different non-relational database are tuned to solving a specific problem and using a Graph database where a document database is needed, or vice versa is not recommended. It is the special utilities that each of them provide that make one more preferable than others when targeting a particular business need. However, on a theoretical level, all of them share the common feature of being a key-value store in some way.</p>
	
	
	
	
	
	
	
	<h4>Schema</h4>
	<p id="1611510000"></p>
	See https://en.wikipedia.org/wiki/Database#Design_and_modeling -- mention that schema comes after design is decided based on business and normalization considerations.
	
	<h4>Indexes</h4>
	<p id="1611510010"></p>
	Primary + foreign key
	extra index to improve search
	Can be used both by sql and nosql.. but it's use case is better defined for sql compared to nosql
	
	<h4>Transaction</h4>
	<p id="1611510020"></p>
	distributed transaction (https://en.wikipedia.org/wiki/Distributed_transaction) and 2 phase commit (https://en.wikipedia.org/wiki/Two-phase_commit_protocol)
	consensus mechanism: Paxos; primary/replica; paxos vs 2phase commit (https://stackoverflow.com/questions/27304887/paxos-vs-two-phase-commit)
	
	<h4>ACID</h5>
	<p id="1611510030"></p>
	When talking about ACID compliance, be sure to watch for the unit that shows compliance: is it column level, row level or transaction level. NoSQL like cassandra has transaction, but atomicity is row level
	
	Understand ACID when said in context of NoSQL
	https://stackoverflow.com/questions/2608103/is-there-any-nosql-data-store-that-is-acid-compliant/22105320  -- any system with primary/replica will run into the issue
	https://neo4j.com/developer/graph-db-vs-nosql/
	
	<h4>CAP</h5>
	<p id="1611510040"></p>
	realize that CAP is for distributed system.. ACID is for transaction. Both can come up when doing transaction on distributed system. having one does not prelude the other. 
	Think of using NoSQL with log-ahead and a single node having all changes - that can still apply ACID.
	"A" in cap -- see https://en.wikipedia.org/wiki/Consistency_(database_systems)#As_a_CAP_trade-off
	
	
	
	
	
	<h4>Relational vs Non relational database</h5>
	<p id="1611510050">With the database category being named as "relational" or "non-relational", it seems very easy to make a <a href="https://www.vocabulary.com/dictionary/reductive" target="_blank">reductive argument</a> that if relations are needed, use relational database, and use non-relational ones for semi-structured or unstructured data because they don't enforce relations! But what if I use Oracle database, a relational database, and make a table containing 2 columns, a numeric "id" and a text storing column where I store xml or json? It is storing semi-structured information now. Even better, it can store both xml and json! Relational database is about storing relations, and graph database also stores relations, and latter is non-relational database. Or how about I use a non-relation database, like Cassandra, which is a column family store, and programmatically store data within it in a normalized form? I can, and the database will store it. And opposite to it, I can take an Oracle database and make denormalized tables, and use it to store denormalized data, and it will still work. So, what's the difference between the two? To me, the difference between the two is not about "what is one that is not in another", but instead, "what one can do better, out of the box, without less work from developers, that the other", an also which suits the use case better. If your business requires good data integrity and an ability to expand database tables as the business grows and the data model gets richer and complex, go with relational database. If your business is getting hosed with data, and the user just expects you to save it, then using a key-value store is a good way to proceed. Also, how does you business processing get affected by <a href="#1611510030" data-nav-id="1611200362">ACID</a> and <a href="#1611510040" data-nav-id="1611200362">CAP</a> requirements will affect the type of database you'd want to use.</p>
	
	<h4>Database vs File system</h4>
	<p id="1611508641">Here's a question: In <a href="#1608527531" data-nav-id="1611200362">above example of database</a>, why don't I simply make a directory called "database", and within it I store 3 files, "watch-1" file containing data (you, Batman-movie), "watch-2" file containing data (you, Superman-movie), and "watch-3" file containing data (your-friend, Batman-movie). It seems like all needs met by a database are captured and there isn't any more a need to pay any company for their proprietary database software. To me, the best answers for <a href="#1608527531" data-nav-id="1611200362">database</a> vs <a href="#1611499255" data-nav-id="1611200362">file system</a> are mentioned in these 2 StackOverflow posts: <a href="https://stackoverflow.com/questions/38120895/database-vs-file-system-storage/64654674#64654674" target="_blank">here</a> and <a href="https://stackoverflow.com/questions/38120895/database-vs-file-system-storage/43910719#43910719" target="_blank">here</a>. A huge benefit provided by database software is that rather than making huge amount of small files and bogging down the OS and filesystem performance, it manages the data storage to be able to save millions of record and without hurting filesystem performance. It also provides additional services that can be used out of the box, like <a href="#1611510030" data-nav-id="1611200362">ACID</a> guarantees, creation and automatic update of <a href="#1611510010" data-nav-id="1611200362">indexes</a> to improve search performance, performance optimization by using system memory to store frequently used data and relatively easier management of <a href="#1611510000" data-nav-id="1611200362">database schema</a>. It is these additional services compared to a filesystem that using database is preferable for storing small data pieces.</p>
	
	
	
	
	
	<h3>Cache</h3>
	
	<!--
	
	TODO
	
	Link to file system example.. disk cache
	
	Realize cache is a generic term.. its an abstraction -- for taking some storage mechanism and gearing it towards performance by sacrificing persistence (because persistence is handled by database)
	https://stackoverflow.com/questions/22890195/data-caching-vs-nosql
	https://www.infoq.com/news/2011/11/distributed-cache-nosql-data-sto
	-->
	
	<p id="1608530099">See article about cahces on <a href="https://en.wikipedia.org/wiki/Cache_(computing)" target="_blank">Wikipedia</a>, <a href="https://aws.amazon.com/caching/" target="_blank">AWS</a>. The simplest way to think about a cache is to consider it as an in-memory Map object, i.e. for a given key, it returns a value. Cached data is kept in memory so that it can be used rather than making a database or network call. However, since memory hardware is much more expensive that a disk storage, so cached data should be such that it is small in size and still provide performance gains by getting reused multiple times. Identifying what data should be cached depends on the business use case. keep small. The process of removing data from cache is called "evication". This can be done by removing the "least recently used" data, or the "least frequently used" data. Reuse of cache data is called its "hit rate". Optimizing a cache involves analyzing the way cahce is used to ensure a high hit rate (to get same data being queried multiple times and so it is returned from cache rather than from database) with a low eviction rate (to get the benefit of cache use rather than terms getting constantly evicted and then re-loaded). A cache can also be distributed wherein one machine hosting the cache returns data corresponding to a particular "shard" or "partition" of entire dataset, and/or can host a "replica" to shard data owned by a different machine. Even though "Cache" is mentioned under the database section in here, note that a cache is a general term. A cache can be added at various stages, like, to store data pulled from database, or to store user profile for corresponding cookie, or even <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank">at front end to reuse previous responses</a>. However, when adding cache, ensure that stale data is not being sent to user in a manner unexpected by user.</p>
	
</article>