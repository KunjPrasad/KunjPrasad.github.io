<!--
    Productionizing Backend Development - Security glossary, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<title>Productionizing Backend Development - Security glossary</title>
		<meta name="description" content="Glossary for the book on Productionizing Backend Development containing concepts and terms related to securing data in transit, data in rest and securing web service requests.">
		<meta name="author" content="Kunj Prasad">
	
		<!-- Meta with information that otherwise should have come in request headers -->
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Pragma" content="no-cache">
		<meta http-equiv="Cache-Control" content="no-cache">
		
		<!-- Browser related meta -->
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1">
		<meta http-equiv="X-UA-Compatible" content="IE=Edge">
		
		<!-- OpenGraph related meta -->
		<meta property="og:url" content="https://kunjprasad.github.io/productionizing/productionizing-backend-development/glossary/security.html">
		<meta property="og:site_name" content="Productionizing Backend Development book on Kunj Prasad's website">
		<!-- Not yet added image: <meta property="og:image" content="https://kunjprasad.github.io/assets/social_media_logo.png"> -->
		<meta property="og:title" content="Productionizing Backend Development - Security glossary">
		<meta property="og:description" content="Glossary for the book on Productionizing Backend Development containing concepts and terms related to securing data in transit, data in rest and securing web service requests.">
		<meta property="og:locale" content="en_US">
		<meta property="og:type" content="article">
		<meta property="article:publisher" content="Kunj Prasad">
		<meta property="article:published_time" content="2022-01-24T00:00:00+00:00">
		<meta property="article:modified_time" content="2022-01-24T00:00:00+00:00">
		
		<link rel="stylesheet" href="/utilities/common-styles.css" type="text/css">
	</head>
	
	<body>
	
		<header>
			<h1>Security glossary</h1>
			<ol class="breadcrumb-container">
				<li><a href="/productionizing/productionizing-backend-development/">Home</a></li>
				<li><a href="/productionizing/productionizing-backend-development/glossary/">Glossary</a></li>
				<li>Security glossary</li>
			</ol>
		</header>
		
		<div id="note-status" class="note-status-sticky-header alert"><!-- The content here is filled dynamically by the script and gives information on notes, and file uploads, or unsaved changes --></div>
		
		<nav>
			<h2>Table of contents</h2>
			<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#authentication">Authentication</a><ul>
					<li><a href="#password-strength">Password strength</a></li>
					<li><a href="#salting">Salting</a></li>
				</ul></li>
				<li><a href="#authorization">Authorization</a><ul>
					<li><a href="#permission-bits">Permission bits</a></li>
					<li><a href="#acl">Access control list, or ACL</a></li>
				</ul></li>
				<li><a href="#sec-data-transit">Securing data in transit</a><ul>
					<li><a href="#man-in-middle">Man-in-the-middle attack, and need for HTTPS</a></li>
					<li><a href="#dns-over-https">DNS over HTTPS</a></li>
				</ul></li>
				<li><a href="#sec-data-rest">Securing data at rest</a><ul>
					<li><a href="#data-disposal">Data disposal</a></li>
					<li><a href="#key-rotation">Key rotation</a></li>
				</ul></li>
				<li><a href="#sec-web-request">Securing web service request</a><ul>
					<li><a href="#authentication-sec-web-request">Authentication security of web request</a><ul>
						<li><a href="#basic-auth">Basic authentication</a></li>
						<li><a href="#bearer-auth">Bearer authentication (or Token authentication)</a></li>
						<li><a href="#cookie-auth">Cookie based authentication</a></li>
						<li><a href="#token-vs-cookie-auth">Token vs cookie based authentication</a></li>
						<li><a href="#custom-header-auth">Custom authentication headers</a></li>
					</ul></li>
					<li><a href="#authorization-sec-web-request">Authorization security of web request</a><ul>
						<li><a href="#rbac">Role based access control, or RBAC</a></li>
						<li><a href="#rate-limit">Rate limiting, or Throttling</a></li>
						<li><a href="#oauth">OpenID and OAuth</a></li>
						<li><a href="#idor">Insecure direct object references, or IDOR</a></li>
					</ul></li>
					<li><a href="#additional-sec-web-request">Additional security issues</a><ul>
						<li><a href="#useful-security-response-headers">Useful security response headers</a></li>
						<li><a href="#cors">Cross-origin resource sharing, or CORS</a></li>
						<li><a href="#request-forgery-attacks">Request forgery attacks</a><ul>
							<li><a href="#csrf">Cross-site request forgery, or CSRF, or XSRF</a></li>
							<li><a href="#login-csrf">Login CSRF</a></li>
							<li><a href="#ssrf">Server-side request forgery, or SSRF</a></li>
						</ul></li>
						<li><a href="#code-injection">Code injection</a><ul>
							<li><a href="#sql-injection">SQL injection</a></li>
							<li><a href="#xss">Cross-site scripting, or XSS</a></li>
							<li><a href="#server-xss">Server side XSS</a></li>
						</ul></li>
					</ul></li>
					<li><a href="#security-resources">Security related resources</a><ul>
						<li><a href="#cis">Center for Internet Security, or CIS</a></li>
						<li><a href="#mozilla-webappsec">Mozilla WebAppSec</a></li>
						<li><a href="#owasp">Open Web Application Security Project, or OWASP</a></li>
					</ul></li>
				</ul></li>
			</ul>
		</nav>
		
		<main>
			<h2 id="introduction">Introduction</h2>
				<p id="1618697341">This page lists the various terms that relate to securing the data in transit, data in rest and securing web service requests. Note that the list of concepts provided on this page is not exhaustive and many more tasks are required to completely secure an application. For example, physically securing the servers by <a href="https://opensource.com/article/18/9/linux-iptables-firewalld" target="_blank" rel="noopener noreferrer">setting firewall</a>, installing only necessary software, updating/patching softwares, securing database via passwords, mitigation strategy <a href="/productionizing/productionizing-backend-development/glossary/infrastructure.html#ddos">DDoS attacks</a>, updating version of dependency libraries, specially if a new major version is available per <a href="https://semver.org/" target="_blank" rel="noopener noreferrer">semantic versioning layout</a>, etc. are some examples of securing an application that must also be performed. For purpose of securing data and web requests, the two main concepts in "security", if not the entirety of it, are <a href="#authentication">Authentication</a> and <a href="#authorization">Authorization</a>.</p>
				
			<h2 id="authentication">Authentication</h2>
				<p id="1608736802">An easy example to understand authetication is in context of a web application. When a web application receives requests from someone / somewhere, the application must identify the entity making the request and also prevent someone from mistakenly or attackingly assume identity of another user. To authenticate an entity is to get necessary information from them (like, username and password) and successfully relate it to a unique user entry stored on the server, database, etc. This ensures that "the entity making a request" is same as a given "user of the application". If a user cannot be authenticated, then they are marked as an "anonymous" user. Most applications still try to identify anonymous user by tagging them to the ip-address of the machine from where the request is originating, but this identification cannot be trusted, specially for critical operations. Authentication as a topic goes further detailed beyond simply collecting these a password and it is highly instructive to refer to this article at <a href="https://en.wikipedia.org/wiki/Authentication" target="_blank" rel="noopener noreferrer">Wikipedia</a>. As the application evolves and becomes more critical, it is highly suggested to enforce stronger authentication, like, Multifactor authentication (multifactor authentication is a big and important topic in itself and readers are encouraged to review it separately, even though it is not covered in the book). Note that even though the above article discusses "authentication" concept, it has a section towards the end titled "authorization". For this book, authentication and authorization are identified as separate concepts.</p>
				
				<h3 id="password-strength">Password strength</h3>
					<p id="1608862099">See article about password strength at <a href="https://en.wikipedia.org/wiki/Password_strength" target="_blank" rel="noopener noreferrer">Wikipedia</a>. Username and password combination have been the most commonly used method of authenticating an entity. Username, being public facing, can be easy to guess, and so, the load of preventing a compromised authentication comes down on having a strong password. A strong pasword must be used at all times wherever one is asked for, with different passwords for different systems, and also changing passwords regularly, at least after a major breach at any other company. A <a href="https://en.wikipedia.org/wiki/Password_manager" target="_blank" rel="noopener noreferrer">password manager</a> can of great help and should be used as much possible. Do note to have separate password managers for personal and work use, so that you don't lose access of one or other unexpectedly.</p>
				
				<h3 id="salting">Salting</h3>
					<p id="1608862270">See details about password salting <a href="https://cyberhoot.com/cybrary/password-salting" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://crackstation.net/hashing-security.htm" target="_blank" rel="noopener noreferrer">here</a>. The practice of password salting must be used whenever storing a user's password. It provides the benefit that in case of any data leaks / website breach, having a salted password prevents the raw password text provided by a user from getting leaked; And for normal use, having a salted passoword does not prevent the authentication process. It involves adding a string of between 32 or more characters to a password and then hashing it. However, salted passwords must also be iteratively hashed multiple times for this protection to work. <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener noreferrer">Bcrypt</a> is a good algorithm to use for password salting. MD5 and SHA must be avoided.</p>
				
			<h2 id="authorization">Authorization</h2>
				<p id="1608754365">See article about authorization at <a href="https://en.wikipedia.org/wiki/Authorization" target="_blank" rel="noopener noreferrer">Wikipedia</a>. While authentication relates to identifying the entity making a request with the user details stored in application, authorization relates to putting checks on the verified user or anonymous user from accessing data that they aren't allowed to access, or to perform any disallowed action on the data. By definition, authorization must happen only after authentication step has been completed.</p>
			
				<h3 id="permission-bits">Permission bits</h3>
					<p id="1608825700">See details about permission bits usage in setting traditional unix file permissions in this article at <a href="https://en.wikipedia.org/wiki/File-system_permissions#Traditional_Unix_permissions" target="_blank" rel="noopener noreferrer">Wikipedia</a> and <a href="https://docs.nersc.gov/filesystems/unix-file-permissions/" target="_blank" rel="noopener noreferrer">NERSC</a>. The permission bits give user the flexibility to configure directory and file permissions. Different permissions allowing read/write/excute, or combinations of them can be set for the file owner, the group that the file belong to, and for everyone else. Similar permissions can also be set for directories (however, execute permission on directory has different implications that execute permission on file).</p>
					
				<h3 id="acl">Access control list, or ACL</h3>
					<p id="1608825749">See article about ACL at <a href="https://en.wikipedia.org/wiki/Access-control_list" target="_blank" rel="noopener noreferrer">Wikipedia</a>. An example of ACL can be seen <a href="https://documentation.suse.com/sles/12-SP4/html/SLES-all/cha-security-acls.html#sec-security-acls-handle-defacl-prac" target="_blank" rel="noopener noreferrer">here</a>. ACLs take the behavior of "permission bits" described above to a more granular level. Different permissions can be set be individual users or groups. The permission corresponding to the first matching entry in the list is ascribed to the user.</p>
			
			<h2 id="sec-data-transit">Securing data in transit</h2>
				<p id="1608860102">See article about data in transit at <a href="https://en.wikipedia.org/wiki/Data_in_transit" target="_blank" rel="noopener noreferrer">Wikipedia</a>. Data in transit refers to the data that flows over a network, either in the public or untrusted network such as the Internet, or in the confines of a private network such as a corporate or enterprise Local Area Network (LAN). Following quick references can be used to identify ways to secure data in transit (<a href="https://brightlineit.com/data-encryption-transit-business-needs-know/" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://security.berkeley.edu/data-encryption-transit-guideline" target="_blank" rel="noopener noreferrer">here</a>). For web application, the quickest way to secure data in transit is by using HTTPS rather than HTTP for communication.</p>
				
				<h3 id="man-in-middle">Man-in-the-middle attack, and need for HTTPS</h3>
					<p id="1608857950">See article about man-in-the-middle attach at <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener noreferrer">Wikipedia</a> and <a href="https://us.norton.com/internetsecurity-wifi-what-is-a-man-in-the-middle-attack.html" target="_blank" rel="noopener noreferrer">Norton</a>. Using HTTP for communication and not encrypting data transferred between the client and server can allow someone to snoop the traffic and also modify it. Using HTTPS (references: <a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://www.cloudflare.com/learning/ssl/what-is-https/" target="_blank" rel="noopener noreferrer">Cloudflare</a>) encrypts the data communicated between client and server and thwarts these attcks. Recently, search engines (like, Google) have started to give higher ranking to web applications that provide HTTPS connection. While encryption / decryption does add some extra CPU cycles, these are still much faster than database and network latencies which are dominant factor contributing to the response latency. Thus, using rationale of "efficiency" for not having HTTPS configuration is not a valid reason (Reference: <a href="https://www.cloudflare.com/learning/ssl/why-use-https/" target="_blank" rel="noopener noreferrer">Cloudflare</a>). Similaly, when communicating with different microservices within the organization, or invoking third-party api(s), it should also be done using HTTPS and not HTTP.</a>
				
				<h3 id="dns-over-https">DNS over HTTPS</h3>
					<p id="1608857959">Domain Name System, or DNS (reference: <a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://www.cloudflare.com/learning/dns/what-is-dns/" target="_blank" rel="noopener noreferrer">Cloudflare</a>) is a decentralized naming system for websites that allows translating from understandable and memorizable text address to ip-address used by computers. When a client initiates a web request, the initial call made is to DNS servers (see <a href="https://en.wikipedia.org/wiki/Domain_Name_System#Address_resolution_mechanism" target="_blank" rel="noopener noreferrer">here</a> for more details on domain name resolution) after which subsequent HTTP/HTTPS communication with the target server occurs. The initial communication with the DNS is traditionally done over HTTP which can allow internet service providers (i.e., the company that provides you the internet service) to perform a "man-in-the-middle" attack to get information on the websites you (i.e. the client making the web request) are visiting. This can be alleviated by using HTTPS to perform initial DNS call, and is called DNS over HTTPS. For additional details on DNS Security, refer to tihs article at <a href="https://www.cloudflare.com/learning/dns/dns-security/" target="_blank" rel="noopener noreferrer">Cloudflare</a>. Another alternative can also be for companies to host their own DNS servers to enable communication between different internal microservices and resources, and also to identify/control allowed third party api calls.</p>
				
			<h2 id="sec-data-rest">Securing data at rest</h2>
				<p id="1608860588">See article about data at rest at <a href="https://en.wikipedia.org/wiki/Data_at_rest" target="_blank" rel="noopener noreferrer">Wikipedia</a> and <a href="https://docs.microsoft.com/en-us/azure/security/fundamentals/encryption-atrest" target="_blank" rel="noopener noreferrer">Microsoft Azure</a>. Data at rest refers to data that is housed physically on computer data storage in any digital form, including both structured and unstructured data. For a business application, it can include among other entries, database entries, files, logs, emails and alerts containing user data. If a server filesystem is duplicated (like, using RAID, or combination of cloud storage), then "data at rest" definition covers data stored at all such places. Securing data at rest primarily relies on adding password protection to access the corresponding resource and ensuring proper <a href="#permission-bits">file permissions</a>. On a per case basis, the operating system (or, OS) can be configured to encrypt all data being written onto the filesystem. Alternately, the application may itself decide to encrypt the data before sending to OS. Other precautions include storing hash value rather than plaintext if doing so can serve the purpose, stricter access restrictions and auditing of users who are retrieving / modifying this infomation. The goal is to keep a close watch on sensitive data and to have it be unusable by attackers even if the data is stolen.</p>
				
				<h3 id="data-disposal">Data disposal</h3>
					<p id="1612449281">As shown in <a href="/productionizing/productionizing-backend-development/glossary/data-storage.html#1611503723">an example in filesystem section</a> of storage glossary, simply issuing a delete command for files does not actually delete it from the filesystem; And it is possible to retrieve data back from the disk that was previously deleted. As explained in articles <a href="https://www.atlanticdf.com/blog/2019/10/31/safe-data-destruction-101-why-data-disposal-is-necessary/" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://www.webopedia.com/insights/completely-erase-harddrive/" target="_blank" rel="noopener noreferrer">here</a>, this is a security vulnerability and business must take appropriate steps to ensure that data has been truely purged out of the disk or storage device before it is thrown.</p>
					
				<h3 id="key-rotation">Encryption and key rotation</h3>
					<p id="1640709540">See article about key rotation at <a href="https://www.cryptomathic.com/news-events/blog/symmetric-cryptography-and-key-management-considerations-on-key-exhaustion-rotation-and-security-models" target="_blank" rel="noopener noreferrer">Cryptomathic</a>, <a href="https://cloud.google.com/kms/docs/key-rotation" target="_blank" rel="noopener noreferrer">Google cloud</a> and at <a href="https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html" target="_blank" rel="noopener noreferrer">AWS</a>. Encrypting sensitive data in database is the best way to ensure that it is not available to just anyone with access to the database. Since encryption keys are used in encrypting the data, it becomes important to secure the keys. Rotating the encryption key ensures that in the case of a data leak, the damage is contained and not all sensitive user data is compromised.</p>
					
			<h2 id="sec-web-request">Securing web service request</h2>
				<p id="1640710698">Securing a web service entails authenticating the entity performing the request and identifying them as an existing user or an anonymous user, verifying that the authenticated user is authorized to perform the action that they are attempting and ensuring that if the server is communicating with any other infrastructure component while processing the user request, then it is not inadvertently performing any unauthorized actions on behalf of the user.</p>
				
				<h3 id="authentication-sec-web-request">Authentication security of web request</h3>
					<p id="1640786799"><a href="/productionizing/productionizing-backend-development/glossary/req-resp.html#http">HTTP requests are in themselves stateless</a>. The way a HTTP request gets processed by the server does not depend on what pevious requests were made and what were the corresponding outcomes. In context of authentication, this means that each HTTP call must carry authentication information, and the server with individually authenticate every request before it is processed. While it is possible to send authentication details in the <a href="/productionizing/productionizing-backend-development/glossary/req-resp.html#request-response-body">request body</a>, doing so is discouraged because GET calls will not read request body and so, it becomes necessary to identify other means for sending authentication details at least for GET calls! A better alternative is to send authentication details via request header. Various ways to athenticate a request using a request header is discussed below. Note that since a user session is made after a successful authentication, so the various tools provided by modern web application frameworks for managing user session help in preventing session related attacks, like, <a href="https://owasp.org/www-community/attacks/Session_fixation" target="_blank" rel="noopener noreferrer">session fixation</a>. </p>
						
					<h4 id="basic-auth">Basic authentication</h4>
						<p id="1640784364">See articles about basic autentication at <a href="https://en.wikipedia.org/wiki/Basic_access_authentication" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication" target="_blank" rel="noopener noreferrer">Mozilla docs</a> and <a href="https://swagger.io/docs/specification/authentication/basic-authentication/" target="_blank" rel="noopener noreferrer">Swagger docs</a>. The authentication information is sent in <code>Authorization</code> request header, and the corresponding header value starts with <code>Basic</code> prefix. NOTE to avoid confusion that authentication details are sent is a request header that is called "authorization", contrasting with the fact that for this book, <a href="#authentication">authentication</a> and <a href="#authorization">authorization</a> are two separate concepts. Also note that this authentication method MUST only be considered when making requests over secure <a href="#man-in-middle">HTTPS</a> connection, else someone can listen to the request and get access to the header and through it, to the raw text password. The responsibility for collecting username and password, combining them in expected format for basic authentication, and then sending it with every call is the responsibility of the platform from where the call is made.</p>
						
					<h4 id="bearer-auth">Bearer authentication (or Token authentication)</h4>
						<p id="1640785094">See articles about basic autentication at <a href="https://swagger.io/docs/specification/authentication/bearer-authentication/" target="_blank" rel="noopener noreferrer">Swagger docs</a>. It is similar to <a href="#basic-auth">basic authentication</a> in that the authentication information is sent in the <code>Authorization</code> request header. However, here the corresponding header value starts with <code>Bearer</code> prefix. Some web applications may instead use <code>Token</code> prefix. For a bearer authentication, an access code or token is provided in the header, with the understanding that anyone holding that code is identified as same user by the server. Either when the account is created for the first time, or after every password reset, or after every login (depending on how the web application is designed), the server can send a token back to the authenticated user, and subsequent requests can now use the token for authentication. An advantage over the basic authentication is that any attacks or accidental slip ups will reveal the token associated with the user, and it will not reveal the username and password. Any compromised token can be discarded and a new one regenerated.</p>
					
					<h4 id="cookie-auth">Cookie based authentication</h4>
						<p id="1608739818">In modern times, most requests to web services originate from web browsers, like Chrome, IE, Firefox, etc. Browsers are designed with some additional features that are not part of HTTP specification. One such behavior is that a <code>cookie</code> header associated with a domain is sent back to the server automatically in every request. For more details, see the <a href="/productionizing/productionizing-backend-development/glossary/req-resp.html#cookies">glossary section on cookies</a>. This allows using cookies for authentication, where the server sets a session-id cookie on user's browser after the user has successfully authenticated themselves. Any subsequent request made from the browser will now send all the cookies back to the server, including the session-id, and the server can use it to authenticate the user. NOTE that relying only on the cookies for authentication is not a secure practice and must be avoided; For more details see the section below on <a href="#csrf">CSRF attack</a>.</p>
					
					<h4 id="token-vs-cookie-auth">Token vs cookie based authentication</h4>
						<p id="1612407559">Token based authentication have some key advantages when compared to cookie based authentication. Few differences between the two are discussed <a href="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide" target="_blank" rel="noopener noreferrer">here</a>. 
						An advantage of using cookies is that it is a mature concept and the web application developers on frontend and backend don't have to write and maintain custom code to manage cookies. However, if using tokens, then emulating behavior similar to cookie path, max-age and tags will require additional code. Storing headers for reuse and finally deleting them will require additional effort from developers, but this is automatically done for cookies for web browsers. On the other hand, using a token has some advantages over using a cookie. Since a cookie defines a user session on a single browser that is communicating with one server on a given domain, so, if the domain server needs to communicate with other domains, or if the webpage on the browser needs to communicate with other websites, then the same cookie cannot be used. On the other hand, a token can be reused among different systems, as long as each of them understand on how to process the token. Unlike a cookie, a token can also be copied from one browser to another on same or different computer, allowing a user to "move" their session from one system to another. The encryption key used for creating token can be rotated (<a href="#key-rotation">reference</a>) to achieve stronger levels of application security, which is not possible in a cookie.</p>
						<p id="1640796114">Best of both can be achieved by using a token for a cookie. For example, configuring a "sticky session" behavior  (Reference: <a href="https://serverfault.com/questions/32421/how-is-session-stickiness-achieved-across-multiple-web-servers" target="_blank" rel="noopener noreferrer">StackOverflow</a>) by storing complete session information in a cookie, or by using a shared backend database to get user details corresponding to a session-id cookie. Doing so allows the application to be "cloud-ready" where the user experience does not suffer if the server handling the user request suddenly breaks down, or if the user request is routed to a different server. Note that achieving sticky session by routing user request to same server is not a "cloud-ready" solution and should be avoided if possible.</p>
						
					<h4 id="custom-header-auth">Custom authentication headers</h4>
						<p id="1640797482">Web applications may choose to define and use custom request headers which are used for authenticating users. There is nothing disallowed in HTTP specifications against doing so. As described below in the section on <a href="#csrf">CSRF attack</a>, a custom header with same value as that passed in the cookie is a good way to prevent CSRF attack.</p>
						
				<h3 id="authorization-sec-web-request">Authorization security of web request</h3>
					<p>This section covers various security issues in processing a web request that can arise if a request is not properly authorized.</p>
					
					<h4 id="rbac">Role based access control, or RBAC</h4>
						<p id="1608827544">See article about RBAC at <a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank" rel="noopener noreferrer">Wikipedia</a>. Note that RBAC is not a third party software; Instead it is access-control mechanism or architecture defined around roles and privileges. Hence, RBAC implementation can vary for different business. In the RBAC architecture, "roles" are identified and access to business resources (for example, access to REST endpoints) are authorized for corresponding roles. Each user is associated to role(s), and can only access the resources authroized for the role. RBAC also allows for there to be a hierarchical relation among the roles. RBAC authorization is easier to manage at corporate level because a user simply needs to be added-to / remove-from appropriate role to ensure their authorized interaction with the system; And for this reason it is preferred compared to having ACLs (reference: <a href="https://security.stackexchange.com/questions/346/what-is-the-difference-between-rbac-and-dac-acl" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://stackoverflow.com/questions/31941767/what-is-the-exact-difference-between-acl-and-rbac-in-general" target="_blank" rel="noopener noreferrer">here</a>).</p>

					<h4 id="rate-limit">Rate limiting, or Throttling</h4>
						<p id="1608830335">See articles about Throttling at <a href="https://en.wikipedia.org/wiki/Throttling_process_(computing)" target="_blank" rel="noopener noreferrer">Wikipedia</a> and <a href="https://docs.developer.amazonservices.com/en_DE/dev_guide/DG_Throttling.html" target="_blank" rel="noopener noreferrer">AWS</a>. Throttling can be seen as a time-based authorization process wherein a user is disallowed to access API (or certain subsections) at a higher rate that an allowed value. From a business viewpoint, the most likely case for applying throttling is to enforce API access bounds set by payment tier subscribed by the user. Another important use case to apply throttling is to control access rate to resource-intensive APIs and to prevent system from becoming unresponsive.</p>
					
					<h4 id="oauth">OpenID and OAuth</h4>
						<p id="1608748483">See article about OpenID at <a href="https://en.wikipedia.org/wiki/OpenID" target="_blank" rel="noopener noreferrer">Wikipedia</a>. OpenID was designed to be decentralized authentication protocol that allows users to be authenticated by a trusted third party service. This eliminates the need for various web applications to provide their own ad hoc login systems and store user credentials. Instead, the OpenID allows users to log into multiple unrelated websites without having to have a separate identity and password for each. However, with the rise of companies like Google, Facebook, Twitter and the ecosystem of specific products and services offered by each, the user expectation is no longer limited to only having a centralized authentication. When visiting a third party websity, a user now wants the ability to be able to log in from the third party website to Google but only to make a calendar entry, or log into Facebook but only make a post on their wall. This requirement gave rise to <a href="https://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener noreferrer">OAuth</a> which is an open standard for access delegation, commonly used as a way for users to grant websites or applications access to their information on other websites (like Google, Facebook, etc.) but without giving them the corresponding passwords. For more details on how OAuth is implemented, see articles <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" target="_blank" rel="noopener noreferrer">here</a>, <a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://www.varonis.com/blog/what-is-oauth/" target="_blank" rel="noopener noreferrer">here</a>. Hence, the "Auth" in OAuth is actually "authorization", as in, it authorizes a third party to access user profile and services on host websites (like, Google, facebook, etc.). However, in doing so, the authorization provided is granular up to the user level and so, OAuth can also be used for authentication purpose (see <a href="https://en.wikipedia.org/wiki/OAuth#OpenID_vs._pseudo-authentication_using_OAuth" target="_blank" rel="noopener noreferrer">here</a>). This concept can be formalized to form <a href="https://openid.net/connect/" target="_blank" rel="noopener noreferrer">OpenID Connect</a>. Note that as of this writing, OAuth has 2 versions, and it is suggested to use the most recent one, i.e., OAuth2, for any development.</p>
					
					<h4 id="idor">Insecure direct object references, or IDOR</h4>
						<p id="1608862776">See details about IDOR at <a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References" target="_blank" rel="noopener noreferrer">OWASP</a>, including <a href="https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer">ways to prevent it</a>. IDOR occur when an application provides direct access to objects based on user input and without performing sufficient authorization checks. As a result of this vulnerability, attackers can bypass authorization and access resources in the system directly, for example database records or files. It can either include taking a filesystem path from user to retrieve file information but not checking if user is allowed access to the file, or even returning files from directory containing system data and not user data. Another example is returning database entries by reading one or more path and/or query parameters, and not verifying if the user is allowed access to the particular data, even if user-role allows them to access the general service. For example, consider a url path <code>/department/sales/employee/{employeed-id}</code> that allows a manager from sales department to view records of employee with <code>id = {employee-id}</code>. If the service only verifies that the user is a sales manager and authorizes them to use the above url path for any employee-id, regardless of whether the employee belongs in the sales department or not, then that would be an IDOR attack.</p>
				
				<h3 id="additional-sec-web-request">Additional security issues</h3>
					<p>This section covers other common security issues seen during web application development. Web application developers must aim to identify and prevent these vulnerabilities. By following the best practices suggested code development along with proper code reviews, most of these issues, if not all, can be identified and mitigated.</p>
				
					<h4 id="useful-security-response-headers">Useful security response headers</h4>
						<p id="1640886736">From personal experience, I very much appreciate the <a href=" https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-default" target="_blank" rel="noopener noreferrer">default security headers added in response by Spring security</a>. Not all headers may be suitable for all web applications, but it is a good list of security response headers to review and tweak as necessary. Particularly, the default value for headers, except those for caching response, can be used, i.e., <code>X-Content-Type-Options: nosniff</code>, <code>Strict-Transport-Security: max-age=31536000 ; includeSubDomains</code>, <code>X-Frame-Options: DENY</code>, <code>X-XSS-Protection: 1; mode=block</code>. It is highly suggested to also review and set the content security policy (shown <a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-csp" target="_blank" rel="noopener noreferrer">here</a>) and referrer policy (shown <a href="https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-referrer" target="_blank" rel="noopener noreferrer">here</a>) response headers.</p>

					<h4 id="cors">Cross-origin resource sharing, or CORS</h4>
						<p id="1608830395">See article about CORS at <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener noreferrer">Wikipedia</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">Mozilla</a>. In building a web application, it is common practice to use resources or services provided by a third party domain rather than spending time, effort and money in duplicating the service. CORS is a HTTP-header based mechanism that allows the third party domain / server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources. Performing AJAX requests is popular way to request for resources from any website. However, these requests can occur in background and without the user knowing when one is happening or even without waiting for them to provide an input. To prevent an unsuspecting user visiting a webpage from malicious cross-origin calls made automatically via the scripts on the page, browsers restrict all cross-origin HTTP requests initiated from scripts, as per the default <a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank" rel="noopener noreferrer">same-origin security policy</a>. CORS settings are applied on the server side by adding response headers to identify other domains that all allowed to make cross-origin request to it and what methods are allowed. These response headers are: <code>Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers, Access-Control-Max-Age</code>.</p>
						<p class="alert alert-warning">For developers, CORS is one of the issues that sneaks in totally unexpected. If in a time-pinch to develop something that will not get deployed to users and CORS is preventing progress, then there's a bypass to the problem using chrome's <a href="https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en" target="_blank" rel="noopener noreferrer">ModHeader</a> plugin. See <a href="/others/daily-software-tips.html#mod-header" target="_blank" rel="noopener noreferrer">here</a>.</p>
						
					<h4 id="request-forgery-attacks">Request forgery attacks</h4>
						<p id="1642188686">A request forgery attack is when the attacker sends a request, making it look/behave as if it was made by a valid user. Three attacks discussed below are <a href="#csrf">CSRF</a>, <a href="#login-csrf">Login CSRF</a> and <a href="#ssrf">SSRF</a> attacks. Of these, CSRF is the most common of these attacks and a top level vulnerability in many applications.</p>
	
						<h5 id="csrf">Cross-site request forgery, or CSRF, or XSRF</h5>
							<p id="1608864350">See details about CSRF at <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/csrf" target="_blank" rel="noopener noreferrer">OWASP</a> and at <a href="https://docs.spring.io/spring-security/reference/features/exploits/csrf.html" target="_blank" rel="noopener noreferrer">Spring security docs</a>. To understand CSRF attack and prevention techniques, one must first understand about <a href="/productionizing/productionizing-backend-development/glossary/req-resp.html#cookies">cookies</a>, how browsers use cookies, how <a href="#cookie-auth">cookies can be used for authentication</a>, and <a href="#cors">CORS</a>. Primarily, CSRF attacks exploit the property of web browsers that they automatically include any cookies associated to a domain in any web request sent to that domain. This is done regardless of whether the request originates as a result of user opening a new tab and typing a url, or if the user clicks a link belonging to the domain that exists in some third party website, or if the call is made by a script running on a webpage that is hosted either under same domain or under a different domain. Particularly, the last case causes CSRF attack, where (1) a script running on some third party domain is able to make a web request to another target domain, (2) when this request is made, then the browser automatically sends cookies associated with the target domain, (3) at least one of the cookie that is automatically sent is used by the target domain for authentication, (4) all of the above happens without user knowing about it, (5) all of the above happens despite CORS settings on target domain.</p>
							<p id="1640904137">To avoid a CSRF attack, one option is to not at all create any user session and not use cookies in any manner. A purely stateless, cookie-free, REST based communication will be free from CSRF attack. However, this may not always be possible, in which case, the best solution to preventing a CSRF attack is to double submit the value in a cookie, i.e. require a header containing same data as is present in cookie, an example shown in <a href="https://medium.com/cross-site-request-forgery-csrf/double-submit-cookie-pattern-65bb71d80d9f" target="_blank" rel="noopener noreferrer">this article</a>. Another article <a href="https://poshai.medium.com/are-csrf-tokens-necessary-3a6976bf1f34" target="_blank" rel="noopener noreferrer">this</a> describes why csrf tokens are necessary; CSRF token are an iplementation for double submit cookie pattern. Note that this solution relies on use of <a href="#man-in-middle">HTTPS</a>, <a href="/productionizing/productionizing-backend-development/glossary/req-resp.html#safe-request-method">safe HTTP methods</a> not executing side effects</a>, proper <a href="#cors">CORS</a> setting on server, and not having any <a href="#xss">XSS</a> vulnerability. For more details on CSRF prevention, see <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer">OWASP Cheatsheet</a>. Also, as much possible, the cookies set by the web application should also be secured as suggested <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Security" target="_blank" rel="noopener noreferrer">here</a>.</p>
							<ul id="1640905186">In trying to understand CSRF attacks, I personally feel that examples available on the internet about CSRF attacks don't do a complete job of explaining the various details. This paragraph attempts to provide additional details on CSRF attacks. For reference, let's use the CSRF attack example on the <a href="https://docs.spring.io/spring-security/reference/features/exploits/csrf.html" target="_blank" rel="noopener noreferrer">Spring security docs</a> and where double submit cookie is not set.
								<li>Let's say that the website with CSRF insecure page uses a cookie for authentication that has <code>samesite=strict</code> setting. In this case, even without the using a double submit cookie, the CSRF attack will fail. However, not all browsers implement "samesite" setting (see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite#browser_compatibility" target="_blank" rel="noopener noreferrer">browser compatibility</a>), so it is a good idea to still uses double cookie submit. Additionally, if the frontend and backend are hosted on the different domain, then it is not possible to use <code>samesite=strict</code> setting otherwise the communication between the two will break.</li>
								<li>The <code>samesite=strict</code> cookie setting may break some website features and from a business perspective, it may be preferable to instead use <code>samesite=lax</code> cookie setting. Although the latter setting restricts the cases in which a cookie can be sent, it is stil not a fool-proof way to avoid CSRF attack because the applications may not be designed properly, executing sensitive commands on a GET request, as mentioned <a href="https://portswigger.net/web-security/csrf/samesite-cookies" target="_blank" rel="noopener noreferrer">here</a>. So, it is still a good idea to use the double cookie submit pattern.</li>
								<li>Let's say the CORS policy on target server are set such that it only allows requests from a particular origin; And, requests originating from the attacking website's origin is not allowed. Let's also say that the attacking script is making a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests" target="_blank" rel="noopener noreferrer">simple request</a> to the target server. To ensure that cookies are sent with the cross-origin request to the target server, let's say that a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#requests_with_credentials" target="_blank" rel="noopener noreferrer">credentialed request</a> is being made. Let's assume that samesite setting is not used in the cookie. In this case, is the double submit cookie necessary? Yes! The way cross-origin simple requests are executed by a browser, no pre-flight requests are made. Instead, the expected cross-origin request is sent to the server and any response obtained from the server is discarded by the browser. The important thing to note is that even though the server response is discarded by the browser, the server still successfully executes the request sent to it by the script on the attacking website. Hence, the attack is successful! And so, a double submit cookie pattern must be used on the target server to prevent this attack.</li>
								<li>Let's consider above example, but instead a non-simple request is made by the script running on the attacking website. In this case, is the double submit cookie necessary? No! For such cases, the browser performs a pre-flight request before executing the desired cross-origin request. The response to the preflight request will let the browser know that the attacking website is disallowed from making cross-origin request to the target website; And so, the browser will not make the desired attack request. Thus, it is not necessary to use the double submit cookie pattern because no request will be made.</li>
								<li>Let's consider the same example above of making a cross-origin request. However, in this case, let's say that the target server allows requests from two domains, <code>domain-1.com</code> and <code>domain-2.com</code>. In this case, is the double submit cookie on target website necessary to ensure that a CSRF attack initiated by a script hosted on <code>domain-2.com</code> for a user authenticated on <code>domain-1.com</code> does not succeed? Yes! If this scenario described here is allowed to proceed, then it will play out as a classic CSRF attack. However, the thing to notice for this case is that unlike the above scenarios, the response from the CORS request will not be rejected by the browser because <code>domain-2.com</code> is an allowed origin for making cross origin request to the target website. Thus, if CORS settings on the target website allows multiple or all origins (i.e., <code>*</code>), then the double submit cookie pattern prevents CSRF attack on GET requests that might reveal private data of a user to an attacker, in addition to the usual case of preventing CSRF attack on a POST request that might create new data or induce side effects.</li>
							</ul>
						
						<h5 id="login-csrf">Login CSRF</h5>
							<p id="1612364320"><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests" target="_blank" rel="noopener noreferrer">Login CSRF</a> is a CSRF attack done on login page. Unlike the other CSRF attacks, where the user is already logged in and the attacker's goal is to send a forged request that appears as coming from user, in the case of Login CSRF, the attacker's goal is to have the user login to a forged account and not realize that it does not belong to them. Any information added to this account is now available to the attacker. This <a href="https://stackoverflow.com/questions/6412813/do-login-forms-need-tokens-against-csrf-attacks/15350123#15350123" target="_blank" rel="noopener noreferrer">StackOverflow post</a> nicely describes progression of a login csrf attack and why it's considered an "attack" even though the target user never logged into their own account via the compromised login step. When coupled with a logout CSRF attack, a login CSRF can become an even more troubling issue, as shown <a href="https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/" target="_blank" rel="noopener noreferrer">here</a>.</p>
							<p id="1642175554">This <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#login-csrf" target="_blank" rel="noopener noreferrer">OWASP article section</a> provides suggestion on fixing the login csrf problem and without running into <a href="#session-fixation">session fixation attack</a>. A major difference between login CSRF and normal CSRF attack is that the login step involves setting a new cookie which was previously absent, while other CSRF attack try to reuse the cookie already in browser. This is the reason why busting login CSRF attack involves setting a session even for anonymous users. A similar suggestion for fixing login CSRF attack is also provided in <a href="https://simonwillison.net/2021/Aug/3/samesite/#login-csrf-samesite-lax" target="_blank" rel="noopener noreferrer">this different article</a>.</p>
					
						<h5 id="ssrf">Server-side request forgery, or SSRF</h5>
							<p id="1608863938">See details about SSRF at <a href="https://en.wikipedia.org/wiki/Server-side_request_forgery" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/Server_Side_Request_Forgery" target="_blank" rel="noopener noreferrer">OWASP</a>. Consider a scenario where a web application, named WA1, accepts an a url from user in the request body. As part of processing the request, the server should download the file from provided url if the user is autheorized to view the file, and finally send the file contents in response back to the user. Now consider that the business hosting this application also has some other application, named WA2, managing some internal files that must not be made available to outside users. SSRF attack would occur if an attacker makes a call to WA1 giving it a url pointing to WA2 for retrieval of internal files. The attack is successful if WA1 makes a request to WA2 requesting for internal file and authenticates itself as WA1, which is an interal user, rather than as the external user who initially made the call to WA1. In response, WA2 does not raise an error because WA1 is an internal user, and provides the internal file to it, which WA1 returns back to attacker. Had the attacker made a direct call to WA2, the request might have failed, but it does not fail when routed via WA1. Hence, a SSRF can be somewhat seen as an <a href="#idor">IDOR attack</a> during an internal server-to-server communiation due to miscommunication of proper user authentication from one server to another. Resolving such issues requires ensuring that whenever there is a chain of request, then the incoming authentication credentials is the one getting used in subsequent requests, and it is not overwritten by a new authentication credential. As mentioned <a href="#1612407559">earlier</a>, the token used in the token based authentication in the very first request coming from external user can be used by all other chained requests to avoid this attack. This is assuming that there is an enterprise level authentication system that can be used by various applications running within an organization to identify the user for a corresponding token.</p>
					
					<h4 id="code-injection">Code injection</h4>
						<p id="1612495974"><a href="https://en.wikipedia.org/wiki/Code_injection" target="_blank" rel="noopener noreferrer">Code injection</a> is the exploitation of a bug in software through which the attacker can change the expected course of execution. Two most famous injection vulnerabilities are <a href="#sql-injection">SQL injection attack</a> through which the values in database can be modified, and <a href="#xss">Cross-site scripting, or XSS attack</a> through which code can be injected in a victim's HTML page. Injection attacks can also be used to assume another user's authentication, or to trigger a data loss. While there are different ways to handle injection attacks, all remediation suggestion broadly fall into the category of "when accepting untrusted data, i.e. any data from user, try to restrict its value as much possible to not deviate from expectation which can get misinterpreted by application and cause unintended side-effects". This is a very loosely defined statement, and worse, its scope can change as the software and related infrastructure evolves. Maybe your software application starts as a REST application and you don't worry about escaping html text when storing it. Over time, you add behavior allowing users to change html file to pdf, add suddenly your site becomes xss vulnerable! Hence, adherence to best practices and continuous monitoring is needed to ensure that the application is not susceptible to injection attacks.</p>
	
						<h5 id="sql-injection">SQL injection</h5>
							<p id="1612580218"><a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener noreferrer">SQL injection</a> is an attack using the code injection technique, and is used to attack data-driven applications, in which malicious SQL statements are inserted into an entry field for execution. SQL injection exploits a security vulnerability in an application's software when user input is either incorrectly filtered for string literal escape characters embedded in SQL statements or user input is not strongly typed and unexpectedly executed. <a href="https://xkcd.com/327/" target="_blank" rel="noopener noreferrer">Here</a> is a XKCD link that explains the attack and its mitigation in a very simple manner. The good news is that many web frameworks provide standard utilities to ensure that SQL injection attacks do not happen. Unless they are knowingly excluded, it's become less probably to fall victim to an SQL injection attack.</p>
						
						<h5 id="xss">Cross-site scripting, or XSS</h5>
							<p id="1608866075">See details about XSS at <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/xss/" target="_blank" rel="noopener noreferrer">OWASP</a>. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. For example, if a web application allows sending emails but it does not filter the email content to remove attacking scripts, then a xss attack can be effected by sending an email with malicious content to other users and having them open the email in browser. A troubling aspects of XSS is there are various ways to perform these attacks and it can occur anywhere a web application directly uses input from a user. As an extreme example, consider that xss attack can also occur if <a href="https://portswigger.net/research/portable-data-exfiltration" target="_blank" rel="noopener noreferrer">website tries to render user data as a pdf file</a>. Two main solutions to handle XSS attack is to verify / sanitize any text entry taken from user and in the web-page, only incorporate user-data at certain locations. For more details on XSS prevention, see <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer">OWASP Cheatsheet</a>.</p>
						
						<h5 id="server-xss">Server side XSS</h5>
							<p id="1612578951">A server side xss is a <a href="#xss">XSS</a> attack where another server is the victim of the attack. This may happens when unsafe user data is processed by a server as part of business workflow processing, at which time the attack is effected. This vulnerability can manifest itself in multiple ways. For example, as shown <a href="https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf" target="_blank" rel="noopener noreferrer">here</a>, a server side XSS attack can happen when a html is processed and being converted to a pdf file. Or maybe the unsafe data got logged to file and was picked up by some other process that caused it to get attacked. Vulnerability to such attacks depends on analysis of the workflow and can change from one workflow to another. Generally, when dong any server-side processing of a user uploaded file, it should be done in a controlled virtual workspace so control such attacks from causing data leak to an outside domain, or to affect the server hosting the application.</p>
		
			<h2 id="security-resources">Security related resources</h2>
				<p>The following resources are useful references for security related terminology, best practices, blogs, etc.</p>
		
				<h3 id="cis">Center for Internet Security, or CIS</h3>
					<p id="1608831915">CIS home page can be found <a href="https://www.cisecurity.org/" target="_blank" rel="noopener noreferrer">here</a>. Particularly, note the <a href=" https://www.cisecurity.org/controls/cis-controls-list/" target="_blank" rel="noopener noreferrer">20 points guidelines</a> provide dby CIS covering for various aspects of software security.</p>
		
				<h3 id="mozilla-webappsec">Mozilla WebAppSec</h3>
					<p id="1608832263">The <a href="https://wiki.mozilla.org/WebAppSec" target="_blank" rel="noopener noreferrer">Mozilla Web Application Security wiki</a> provides a list of <a href="https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines" target="_blank" rel="noopener noreferrer">secure coding guidelines</a> that is extremely useful.</p>
		
				<h3 id="owasp">Open Web Application Security Project, or OWASP</h3>
					<p id="1608831965">The <a href="https://owasp.org/" target="_blank" rel="noopener noreferrer">OWASP</a> is a nonprofit foundation that works to improve the security of software. <a href="https://owasp.org/www-project-top-ten/" target="_blank" rel="noopener noreferrer">OWASP Top 10</a> vulnerabilities is a good place to check the more common security issues that should be identified and rectified in an application. A complete list of OWASP projects can be found <a href="https://owasp.org/projects/" target="_blank" rel="noopener noreferrer">here</a>.</p>
		</main>
		
		<footer></footer>
		
		<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
		<script type="module">
			import {onNonHomepageLoad} from "../scripts.js";
			$(document ).ready(onNonHomepageLoad);
		</script>
		
	</body>
	
</html>
