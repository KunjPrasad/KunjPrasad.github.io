<!--
    HTML book section: Security related terms glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Security related terms</h2>
	<p id="1618697341">This page lists the various terms that relate to securing the request. Please note that complete application security goes much further and the list below is not exhaustive. For example, physically securing the servers by <a href="https://opensource.com/article/18/9/linux-iptables-firewalld" target="_blank">setting firewall</a>, installing only necessary software, updating/patching softwares, securing database via passwords, mitigation strategy <a href="#1612491901" data-nav-id="1608343369">DDoS attacks</a>, etc. are some examples of securing an application that must also be performed.</p>
	
	<nav class="article-toc">
		<h3>Table of contents</h3>
		<ul>
			<li><a href="#1608736802" data-nav-id="1608343369">Authentication</a><ul>
				<li><a href="#1608739818" data-nav-id="1608343369">Cookie and Token based authentication</a><ul>
					<li><a href="#1608743016" data-nav-id="1608343369">JWT authentication</a></li>
				</ul></li>
				<li><a href="#1608748483" data-nav-id="1608343369">OpenID and OAuth</a></li>
			</ul></li>
			<li><a href="#1608754365" data-nav-id="1608343369">Authorization</a><ul>
				<li><a href="#1608825700" data-nav-id="1608343369">Permission bits</a></li>
				<li><a href="#1608825749" data-nav-id="1608343369">Access control list, or ACL</a></li>
				<li><a href="#1608827544" data-nav-id="1608343369">Role based access control, or RBAC</a></li>
				<li><a href="#1608830335" data-nav-id="1608343369">Rate limiting, or Throttling</a></li>
				<li><a href="#1608830395" data-nav-id="1608343369">Cross-origin resource sharing, or CORS</a></li>
			</ul></li>
			<li><a href="#1608860102" data-nav-id="1608343369">Data in transit</a><ul>
				<li><a href="#1608857950" data-nav-id="1608343369">Man-in-the-middle attack, and need for HTTPS</a></li>
				<li><a href="#1608857959" data-nav-id="1608343369">DNS over HTTPS</a></li>
			</ul></li>
			<li><a href="#1608860588" data-nav-id="1608343369">Data at rest</a><ul>
				<li><a href="#1608862099" data-nav-id="1608343369">Password strength</a></li>
				<li><a href="#1608862270" data-nav-id="1608343369">Salting</a></li>
				<li><a href="#1612449281" data-nav-id="1608343369">Data disposal</a></li>
			</ul></li>
			<li><a href="#" data-nav-id="1608343369">Common security issues</a><ul>
				<li><a href="#1612447317" data-nav-id="1608343369">Dependency update</a></li>
				<li><a href="#1612495974" data-nav-id="1608343369">Code injection</a><ul>
					<li><a href="#1612580218" data-nav-id="1608343369">SQL injection</a></li>
					<li><a href="#1608866075" data-nav-id="1608343369">Cross-site scripting, or XSS</a></li>
					<li><a href="#1612578951" data-nav-id="1608343369">Server side XSS</a></li>
				</ul></li>
				<li>Request forgery attack<ul>
					<li><a href="#1608864350" data-nav-id="1608343369">Cross-site request forgery, or CSRF, or XSRF</a></li>
					<li><a href="#1612364320" data-nav-id="1608343369">Login CSRF</a></li>
					<li><a href="#1608863938" data-nav-id="1608343369">Server-side request forgery, or SSRF</a></li>
				</ul></li>
				<li><a href="#1608862776" data-nav-id="1608343369">Insecure direct object references, or IDOR</a></li>
			</ul></li>
			<li>Security related resources<ul>
				<li><a href="#1608831915" data-nav-id="1608343369">Center for Internet Security, or CIS</a></li>
				<li><a href="#1608832263" data-nav-id="1608343369">Mozilla WebAppSec</a></li>
				<li><a href="#1608831965" data-nav-id="1608343369">Open Web Application Security Project, or OWASP</a></li>
			</ul></li>
		</ul>
	</nav>
	
	<h3>Authentication</h3>
	<p id="1608736802">A web application receives requests from someone/somewhere, that then needs to be processed and a corresponding response returned. However, in doing so, the application must prevent one user from mistakenly or attackingly assume identity of another user to access someone else's data. This is where the concept of Authentication comes in, wherein, the web application asks for details from user making the request to verify that "the entity making a request" is same as a given "user of the application". Traditionally, this is done by collecting an username and pasword from the user. Authentication as a topic goes further detailed beyond simply collecting these a password and it is highly instructive to refer to this article at <a href="https://en.wikipedia.org/wiki/Authentication" target="_blank">Wikipedia</a>. As the application evolves and becomes more critical, it is highly suggested to enforce stronger authentication, like, Multifactor authentication. Also note that even though the above article includes "Authorization" section towards the end, it is a different concept altogether. In this book, authentication and authorization are dealt separately.</p>
	
	<h4>Cookie and Token based authentication</h4>
	<p id="1608739818"><a href="#1608922565" data-nav-id="1608303678">HTTP requests are in themselves stateless</a>. Making a HTTP call is not dependent on past calls, nor does it affect future calls. This raises a question on how to provide authentication details to server such that it does not preclude the user from sending some other data within request-body. Also, if there's a way to prevent collecting and sending the user credentials in every call. One way is to start by collecting authentication details from the user (like, username and password), authenticate the user, store the authenticated user-details on server side either in some cache or database, and return a session-id in <a href="#1609041933" data-nav-id="1608303678">cookie</a>. When subsequent requests are made, the browser sends the session-id cookie back to server and the server can look up the corresponding user details from its cache or database. When the same cookie is returned in subsequent HTTP calls, then the server identifies it to be the same user. This is cookie based authentication. Another method starts with same way but after a succesful authentication, the server returns a random token specific to the user. The returned token may or may not have an expiry period after which it'll need to be refreshed. Now in future calls, the user must send that token back as part of <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication" target="_blank">Authorization request header</a> (once again, realize that this is "authentication" process, not "authorization", despite the name of request header). The most common token based authentication is <a href="https://tools.ietf.org/html/rfc6750" target="_blank">Bearer authentication</a>. Slightly different from token based authentication is <a href="https://tools.ietf.org/html/rfc7617" target="_blank">Basic authentication</a> where encoded username and pasword are sent in request header.</p>
	<p id="1612407559">Token based authentication have some key advantages when compared to cookie based authentication. Few differences between the two are discussed <a href="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide" target="_blank">here</a>. To enable cookie based authentication, the server must be able to retrive the user session corresponding to the cookie. However, if for any reason, the server dies out (which regularly happens in cloud environment), then the session is lost. Since tokens used in token based authentication are stateless, it makes the application more "cloud-ready", i.e. any other server is equally able to process the user request and it doesn't need to be same as the server the performed initial authentication and created user session. Do note though that when using token based authentication, then a "user session" should not be defined or used. Instead any stateful data is captured within the JWT and sent back out. Tokens can be used to <a href="#1608863938" data-nav-id="1608343369">prevent server side request forgery attacks</a>, discussed later. With tokens, it is also possible to transfer the session from one machine to another, even at a different ip-address. For example, add two services in web application where the first one converts the token into some unique number / image  whatever, and the second over converts back from the intermediary to token. Any other machine the token gets copied, the same.</p>
	
	<h5>JWT authentication</h5>
	<p id="1608743016">See article about <a href="https://jwt.io/introduction/" target="_blank">Json Web Tokens (JWT)</a>. A JWT is a text consisting of 3 portions joined together by a period. The second portion is called "payload" and is Base64 encoding of a json object that contains necessary user details. In addition to user data, there are few more fields, like, issuer and expiration time (This allows JWT to be time bound and lose validity after expiration). The third is called signature that is formed by combining the first and second portion of JWT along with a secret. This allows JWT to be read by anyone receiving it but prevents someone from tampering details in JWT's payload and sending that back to server. The way it works: user gives a username and password during login. After authentication, the server returns a JWT token. In subsequent request, the JWT is sent in request header back to server. If it is tampered with, or expired, or belongs to different issuer, then the user is not authenticated. Else, receiving the token (containing user details) implies that the request containing it is coming from someone to which the server issued this token in past, which could only be for an authenticated user. This is how having a JWT provides an authentication. Using JWT for authentication is a form of <a href="#1608739818" data-nav-id="1608343369">token authentication</a>, JWT being the token here.</p>
	
	<h4>OpenID and OAuth</h4>
	<p id="1608748483">See article about OpenID at <a href="https://en.wikipedia.org/wiki/OpenID" target="_blank">Wikipedia</a>. OpenID was designed to be decentralized authentication protocol that allows users to be authenticated by a trusted third party service. This eliminates the need for various web applications to provide their own ad hoc login systems and store user credentials, and instead allows users to log into multiple unrelated websites without having to have a separate identity and password for each. However, with the rise of companies like Google, Facebook, Twitter and the ecosystem of services and products offered by them, the user expectation from other websites changed. Now, users instead want an ability in other websites to be able to log into, say, Google and make a calendar entry, or log into Facebook and make a post on their wall. This gave rise to <a href="https://en.wikipedia.org/wiki/OAuth" target="_blank">OAuth</a> which is an open standard for access delegation, commonly used as a way for users to grant websites or applications access to their information on other websites (like Google, Facebook, etc.) but without giving them the corresponding passwords (for more implementation details, see articles <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" target="_blank">here</a> and <a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth" target="_blank">here</a>). Hence, the "Auth" in OAuth is actually "authorization" and for various business who want access to user profile on target websites. However, OAuth can also be used for authentication purpose (see <a href="https://en.wikipedia.org/wiki/OAuth#OpenID_vs._pseudo-authentication_using_OAuth" target="_blank">here</a>), which is formalized to form <a href="https://openid.net/connect/" target="_blank">OpenID Connect</a>.</p>
	
	<h3>Authorization</h3>
	<p id="1608754365">See article about authorization at <a href="https://en.wikipedia.org/wiki/Authorization" target="_blank">Wikipedia</a>. While authentication relates to identifying the entity making a request with the user details stored in application, authorization relates to putting checks on the verified user from accessing data that they should not access. At a minimum, it includes both preventing an unauthenticated/anonymous user from accessing data available to authenticated users and preventing an authenticated user from accessing data belonging to another user. In addition to these two rules, additional rules can be added as part of authorization.</p>
	
	<h4>Permission bits</h4>
	<p id="1608825700">See details about permission bits usage in setting traditional unix file permissions in this article at <a href="https://en.wikipedia.org/wiki/File-system_permissions#Traditional_Unix_permissions" target="_blank">Wikipedia</a> and <a href="https://docs.nersc.gov/filesystems/unix-file-permissions/" target="_blank">NERSC</a>. Different permissions allowing read/write/excute, or combinations of them can be set for the file owner, the group that the file belong to, and for everyone else. Similar permissions can also be set for directories (however, execute permission on directory has different implications that execute permission on file). As an example, consider the case discussed in <a href="#1611502622" data-nav-id="1611200362">file system section of the data-storage glossary</a>. In that example, what happens if someone not your friend asks for the friend's note? Yhey should not be given access to your friend's data because it's not their data to own. Or, maybe your friend wants to allow other people to see the note but not be able to modify it. The file permission bits give user the flexibility to configure the file permissions.</p>
	
	<h4>Access control list, or ACL</h4>
	<p id="1608825749">See article about ACL at <a href="https://en.wikipedia.org/wiki/Access-control_list" target="_blank">Wikipedia</a>. An example of ACL can be seen <a href="https://documentation.suse.com/sles/12-SP4/html/SLES-all/cha-security-acls.html#sec-security-acls-handle-defacl-prac" target="_blank">here</a>. ACLs take the behavior of "permission bits" described above to a more granular level. Different permissions can be set be individual users or groups. The permission corresponding to the first matching entry in the list is ascribed to the user.</p>
	
	<h4>Role based access control, or RBAC</h4>
	<p id="1608827544">See article about RBAC at <a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank">Wikipedia</a>. Note that RBAC is an approach / architecture to restricting system access to authorized users, it is not a third party software. RBAC implementation can vary for different business but the underlying architecture remains, which is, to ascribe role for each user profile and define permissions only using the role identified for a user after they have been authenticated. This form of authorization is easier to manage at corporate level because a user simply needs to be added-to / remove-from appropriate role to ensure their authorized interaction with the system; And for this reason it is preferred compared to having ACLs (reference: <a href="https://security.stackexchange.com/questions/346/what-is-the-difference-between-rbac-and-dac-acl" target="_blank">here</a> and <a href="https://stackoverflow.com/questions/31941767/what-is-the-exact-difference-between-acl-and-rbac-in-general" target="_blank">here</a>).</p>

	<h4>Rate limiting, or Throttling</h4>
	<p id="1608830335">See articles about Throttling at <a href="https://en.wikipedia.org/wiki/Throttling_process_(computing)" target="_blank">Wikipedia</a> and <a href="https://docs.developer.amazonservices.com/en_DE/dev_guide/DG_Throttling.html" target="_blank">AWS</a>. It can be seen as a time-based authorization process wherein a user is disallowed to access API (or certain subsections) at a higher rate that an allowed value. From a business viewpoint, the most likely case for applying throttling is to enforce API access bounds set by payment tier subscribed by the user. Another important use case to apply throttling is to control access rate to resource-intensive APIs and to prevent system from becoming unresponsive.</p>
	
	<h4>Cross-origin resource sharing, or CORS</h4>
	<p id="1608830395">See article about CORS at <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank">Wikipedia</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank">Mozilla</a>. With ability to perform AJAX requests from webpages, a user may get exploited by an attacker, if the attacker hosted webpage is able to freely make calls to some other domain (i.e. website). Being on attacker's webpage, the user would never know of such background calls being made. Thus, while a web page may freely embed cross-origin images, stylesheets, scripts, iframes, it is forbidden to make ajax requests as per the default <a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank">same-origin security policy</a>. A server can add response headers to identify other domains that all allowed to make CORS request to it, what methods are allowed. These response headers are: <code>Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers, Access-Control-Max-Age</code>. Thus, CORS settings can be seen as being related to authorization process, in that it authorizes a javascript code on webpage of some different domain to call an endpoints on the current domain.</p>
	<p class="alert alert-warning">For developers, CORS is one of the issues that sneaks in totally unexpected. If in a time-pinch to develop something that will not get deployed to users and CORS is preventing progress, then there's a bypass to the problem using chrome's <a href="https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en" target="_blank">ModHeader</a> plugin. See <a href="/others/daily-software-tips.html#mod-header" target="_blank">here</a></p>
	
	<h3>Data in transit</h3>
	<p id="1608860102">See article about data in transit at <a href="https://en.wikipedia.org/wiki/Data_in_transit" target="_blank">Wikipedia</a>. Data in transit refers to the data that flows over a network, either in the public or untrusted network such as the Internet, or in the confines of a private network such as a corporate or enterprise Local Area Network (LAN). Following quick references can be used to identify ways to secure data in transit (<a href="https://brightlineit.com/data-encryption-transit-business-needs-know/" target="_blank">here</a> and <a href="https://security.berkeley.edu/data-encryption-transit-guideline" target="_blank">here</a>). For web application, the quickest way to secure data in transit is by using HTTPS rather than HTTP for communication.</p>
	
	<h4>Man-in-the-middle attack, and need for HTTPS</h4>
	<p id="1608857950">See article about man-in-the-middle attach at <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">Wikipedia</a> and <a href="https://us.norton.com/internetsecurity-wifi-what-is-a-man-in-the-middle-attack.html" target="_blank">Norton</a>. Using HTTP for communication and not encrypting data transferred between the client and server can allow someone to snoop the traffic and also modify it. Using HTTPS (references: <a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank">Wikipedia</a>, <a href="https://www.cloudflare.com/learning/ssl/what-is-https/" target="_blank">Cloudflare</a>) encrypts the data communicated between client and server and thwarts these attcks. Recently, search engines (like, Google) have started to give higher ranking to web applications that provide HTTPS connection. While encryption / decryption does add some extra CPU cycles, these are still much faster than database and network latencies which are dominant factor contributing to the response latency. Thus, using rationale of "efficiency" for not having HTTPS configuration is not a valid reason (Reference: <a href="https://www.cloudflare.com/learning/ssl/why-use-https/" target="_blank">Cloudflare</a>). Similaly, when communicating with different microservices within the organization, or invoking third-party api(s), it should also be done using HTTPS and not HTTP.</a>
	
	<h4>DNS over HTTPS</h4>
	<p id="1608857959">Domain Name System, or DNS (reference: <a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank">Wikipedia</a>, <a href="https://www.cloudflare.com/learning/dns/what-is-dns/" target="_blank">Cloudflare</a>) is a decentralized naming system for websites that allows translating from understandable and memorizable text address to ip-address used by computers. When a client initiates a web request, the initial call made is to DNS servers (see <a href="https://en.wikipedia.org/wiki/Domain_Name_System#Address_resolution_mechanism" target="_blank">here</a> for more details on domain name resolution) after which subsequent HTTP/HTTPS communication with the target server occurs. The initial communication with the DNS is traditionally done over HTTP which can allow internet service providers (i.e., the company that provides you the internet service) to perform a "man-in-the-middle" attack to get information on the websites you (i.e. the client making the web request) are visiting. This can be alleviated by using HTTPS to perform initial DNS call, and is called DNS over HTTPS. For additional details on DNS Security, refer to tihs article at <a href="https://www.cloudflare.com/learning/dns/dns-security/" target="_blank">Cloudflare</a>. Another alternative can also be for companies to host their own DNS servers to enable communication between different internal microservices and resources, and also to identify/control allowed third party api calls.</p>
	
	<h3>Data at rest</h3>
	<p id="1608860588">See article about data at rest at <a href="https://en.wikipedia.org/wiki/Data_at_rest" target="_blank">Wikipedia</a> and <a href="https://docs.microsoft.com/en-us/azure/security/fundamentals/encryption-atrest" target="_blank">Microsoft Azure</a>. Data at rest refers to data that is housed physically on computer data storage in any digital form, including both structured and unstructured data. For a business application, it can include among other entries, database entries, files, logs, emails and alerts containing user data. If a server filesystem is duplicated (like, using RAID, or combination of cloud storage), then "data at rest" definition covers data stored at all such places. Securing data at rest primarily relies on adding password protection to access the corresponding resource and ensuring proper <a href="#1608825700" data-nav-id="1608343369">file permissions</a>. On a per case basis, the operating system (or, OS) can be configured to encrypt all data being written onto the filesystem. Alternately, the application may itself decide to encrypt the data before sending to OS. Other precautions include storing hash value rather than plaintext if doing so can serve the purpose, stricter access restrictions and auditing of users who are retrieving / modifying this infomation. The goal is to keep a close watch on sensitive data and to have it be unusable by attackers even if the data is stolen.</p>
	
	<h4>Password strength</h4>
	<p id="1608862099">See article about password strength at <a href="https://en.wikipedia.org/wiki/Password_strength" target="_blank">Wikipedia</a>. Having a strong security software would mean nothing if the password holding it together is extremely weak and easy to guess; Once guessed, the security of data at rest is greatly compromised. So, a strong pasword must be used at all times, with different passwords for different systems, and also changing passwords regularly, at least after a major breach at any company. A <a href="https://en.wikipedia.org/wiki/Password_manager" target="_blank">password manager</a> can of great help and should be separately used for personal and corporate use as much possible.</p>
	
	<h4>Salting</h4>
	<p id="1608862270">See details about password salting <a href="https://cyberhoot.com/cybrary/password-salting" target="_blank">here</a> and <a href="https://crackstation.net/hashing-security.htm" target="_blank">here</a>. Password Salting is one of the most secure ways to protect passwords stored for future authentication without exposing them should your website be breached in the future and to prevent them from being reverse engineered by hackers. It involves adding a string of between 32 or more characters to a password and then hashing it. However, salted passwords must also be iteratively hashed multiple times for this protection to work. <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank">Bcrypt</a> is a good algorithm to use for password salting. MD5 and SHA must be avoided.</p>
	
	<h4>Data disposal</h4>
	<p id="1612449281">As shown via <a href="#1611503723" data-nav-id="1611200362">an example in filesystem section</a> of storage glossary, simply issuing a delete command for files does not actually delete it from the filesystem; And it is possible to retrieve data back from the disk that was previously deleted. As explained in articles <a href="https://www.atlanticdf.com/blog/2019/10/31/safe-data-destruction-101-why-data-disposal-is-necessary/" target="_blank">here</a> and <a href="https://www.webopedia.com/insights/completely-erase-harddrive/" target="_blank">here</a>, this is a security vulnerability and business must take appropriate steps to ensure that data has been truely purged out of the disk or storage device before it is thrown.</p>
	
	<h3>Common security issues</h3>
	<p>Following are some of the common security issues seen during web application development. Developers must aim to identify and prevent these vulnerabilities. Following accepted code development best practices along with proper code reviews should help identify and mitigate most of them.</p>
	
	<h4>Dependency update</h4>
	<p id="1612447317">Almost all web application today use some framework to provide common functionalities on top of which custom business logic is added. As part of development, adding libraries could be used that also forms the dependency for the application. Over time security issues are identified and patched in the libraries and the version number is changed. Developers must keep an eye on the version of these dependencies and peridocally update it, specially if a new major version, per <a href="https://semver.org/" target="_blank">semantic versioning layout</a>, is available. If moving up the version involved non backward compatible changes, then those must be handled sooner than later; rather than using it as reason to not upgrade. <a href="#1608660132" data-nav-id="1608344347">Static code analyzers</a> can also help identify vulnerabilities and can notify these issues as part of pre-commit hook.</p>
	
	<h4>Code injection</h4>
	<p id="1612495974"><a href="https://en.wikipedia.org/wiki/Code_injection" target="_blank">Code injection</a> is the exploitation of a bug in software through which the attacker can change the expected course of execution. Two most famous injection vulnerabilities are SQL injection attack</a> through which the values in database can be modified, and <a href="#1608866075" data-nav-id="1608343369">Cross-site scripting, or XSS attack</a> through which code can be injected in a victim's HTML page. Injection attacks can also be used to assume another user's authentication, or to trigger a data loss. While there are different ways to handle injection attacks, they broadly fall into the category of "when accepting untrusted data, i.e. any data from user, try to restrict its value as much possible to not deviate from expectation which can get misinterpreted by application and cause unintended side-effects". This is a very loosely defined statement, and worse, its scope can change as the software and related infrastructure evolves. Maybe your software application starts as a REST application and you don't worry about escaping html text when storing it. Over time, you add behavior allowing users to change html file to pdf, add suddenly your site becomes xss vulnerable, as discussed below!</p>
	
	<h5>SQL injection</h5>
	<p id="1612580218"><a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank">SQL injection</a> is an attack using the code injection technique, and is used to attack data-driven applications, in which malicious SQL statements are inserted into an entry field for execution. SQL injection exploits a security vulnerability in an application's software when user input is either incorrectly filtered for string literal escape characters embedded in SQL statements or user input is not strongly typed and unexpectedly executed. <a href="https://xkcd.com/327/" target="_blank">Here</a> is a XKCD link that explains the attack and its mitigation in a very simple manner. The good news is that many web frameworks provide standard utilities to ensure that SQL injection attacks do not happen. Unless they are knowingly excluded, it's become less probably to fall victim to an SQL injection attack.</p>
	
	<h5>Cross-site scripting, or XSS</h5>
	<p id="1608866075">See details about XSS at <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/xss/" target="_blank">OWASP</a>. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. One of the troubling aspects of XSS is that the flaws that allow these attacks to succeed are quite widespread and can occur anywhere a web application directly uses input from a user. As an extreme example, it can also occur if <a href="https://portswigger.net/research/portable-data-exfiltration" target="_blank">website tries to render user data as a pdf file</a>. Two main solutions to handle XSS attack is to verify / sanitize any text entry taken from user and in the web-page, only incorporate user-data at certain locations. For more details on XSS prevention, see <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" target="_blank">OWASP Cheatsheet</a>.</p>
	<p id="1610296182">There is a way to see an XSS attach occurring in this ebook. Click on one of "Add-note" buttons and add the following note: <code>&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;textarea&gt;</code>. Let's save it by clicking out of textbox and remember location of where the note was added since we'll be coming back to it soon. Click on a different navigation item on left to load a different page, and then click on navigation item to load the page where the note wa added. You'll notice 2 things happening: one, there will be an alert box when the page is loaded (like shown <a href="https://www.w3schools.com/jsref/met_win_alert.asp" target="_blank">here</a>), and instead of the note showing up that you just added, you'll see 2 textboxes. The XSS attack here is that in loading a text data, i.e. the note which was added, the browser instead intepreted it as valid html and ran a script. The script that ran generated the alert box. Generally though, the attacks won't be as innocent. Over here, the attack script was created by you, but what if you downloaded the entry from some other place? Bottom line: <strong>don't trust data coming from someone else.</strong> Frankly, there should have been some alarm bells ringing when I asked you to run this example and same should also happen if you're downloading note data from someone else and then loading it in your browser. Not that this shouldn't be done because doing so enables learning from each other. However, do exercise caution! A followup question: how is it that adding the note triggered xss attack but the first line in this paragraph also has the same line and not XSS attack is occurring there? [<a href="/others/daily-software-tips.html#change-website-render" target="_blank">Hint</a>]</p>
	
	<h5>Server side XSS</h5>
	<p id="1612578951">Consider user provided unsafe data making its way from the initial application where it was uploaded, to another internal business application that processes use data, and in doing so, falls victim to the unsafe data; This is server side XSS attack. This vulnerability can manifest itself in multiple ways. For example, as shown <a href="https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf" target="_blank">here</a>, a server side XSS attack can happen when a html is processed and being converted to a pdf file. Or maybe the unsafe data got logged to file and was picked up by some other process that caused it to get attacked. Vulnerability to such attacks depends on analysis of the workflow and can change from one workflow to another. Generally, when dong any server-side processing of a user uploaded file, it should be done in a controlled virtual workspace so control such attacks from causing data leak to an outside domain, or to affect the server hosting the application.</p>
	
	<h4>Request forgery attack</h4>
	
	<h5>Cross-site request forgery, or CSRF, or XSRF</h5>
	<p id="1608864350">See details about CSRF at <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/csrf" target="_blank">OWASP</a>. CSRF attacks exploit the property of web browsers that they will automatically include any <a href="#1609041933" data-nav-id="1608303678">cookies</a> used by a given domain in any web request sent to that domain, and that they do so without notifying the users. This behavior, along with use of <a href="#1608739818" data-nav-id="1608343369">cookie based authentication</a>, improper <a href="#1608830395" data-nav-id="1608343369">CORS</a> setting at server side and improper endpoint design can make a user vulnerable to CSRF attack. At a high level, the attack works by tricking a user into taking actions that trigger scripts which make a call from the browser of user to the server. In doing so, browser send all cookies and server authenticates this forged request as intentionally made by user due to presence of cookie based authentication. Hence, to the server, the forged request appears as real and it will perform any appropriately requested actions including returning data, manipulating session state, or making changes to the victim's account. The quickest solution to preventing a CSRF attack is to double submit a cookie, i.e. require a header containing same data as is present in cookie, an example shown in <a href="https://medium.com/cross-site-request-forgery-csrf/double-submit-cookie-pattern-65bb71d80d9f" target="_blank">this article</a>. Additionally, <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security" target="_blank">strict transport security, or, HSTS</a> must also be enforced to strengthen this solution (reference: <a href="https://security.stackexchange.com/questions/73406/the-spring-security-framework-recommends-against-using-double-submit-cookies-to/100624#100624" target="_blank">here</a> and <a href="https://security.stackexchange.com/questions/220797/is-the-double-submit-cookie-pattern-still-effective/220810#220810" target="_blank">here</a>). However, a complete solution also requires analyzing the CORS policy set by the service. Also, note that if the web application is susceptible to XSS attack, then the attacker can still gain access to the cookie and fixing CSRF via sending a different header fails. For more details on CSRF prevention, see <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html" target="_blank">OWASP Cheatsheet</a>. Also, as much possible, the cookies set by the web application should also be secured as suggested <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Security" target="_blank">here</a>.</p>
	
	<h5>Login CSRF</h5>
	<p id="1612364320"><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests" target="_blank">Login CSRF</a> is a CSRF attack done on login page, and is different from other CSRF attacks where a user is already logged in and the attacker tries to forge a request as if it is coming from user. This <a href="https://stackoverflow.com/questions/6412813/do-login-forms-need-tokens-against-csrf-attacks/15350123#15350123" target="_blank">StackOverflow post</a> nicely describes progression of a login csrf attack and why it's considered an "attack" even though the target user never logged into their own account via the compromised login step. Another good resource is <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#login-csrf" target="_blank">this article section</a> from OWASP.</p>
	
	<h5>Server-side request forgery, or SSRF</h5>
	<p id="1608863938">See details about SSRF at <a href="https://en.wikipedia.org/wiki/Server-side_request_forgery" target="_blank">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/Server_Side_Request_Forgery" target="_blank">OWASP</a>. Consider a scenario where a web application WA1 accepts an a url from user, such that the server downloads file from that location, and as proof of download, then returns a copy of it in response. Now consider that the business hosting this application also has some other application WA2, managing some internal files that must not be made available to outside users. SSRF attack would occur if an attacker makes a call to WA1 giving it a url pointing to WA2 for retrieval of internal files. The attack is successful if WA1 makes a call to WA2 requesting for internal file, then WA2 responds without raising an error because a call coming from WA1 is like an internal call to WA2, and finally the internal file is returned back to attacker. Had the attacker made a direct call to WA2, the request might have failed, but it does not fail when routed via WA1. To solve such issues, a web application is performing an action on some internal / external web application must be able to construct the request as if coming from the user and not from internal system. Since <a href="#1608739818" data-nav-id="1608343369">token based authentication</a> is stateless, it is helpful to solve such issues, wherein, the initial web application (i.e. to which the user makes a request) passes the same authentication token to downstream applications to simulate those request are being made by the user. By definition, this is itself dependent on having an enterprise level authentication system that can be used by various applications running within an organization to identify the user for a corresponding token.</p>
	
	<h4>Insecure direct object references, or IDOR</h4>
	<p id="1608862776">See details about IDOR at <a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References" target="_blank">OWASP</a>, including <a href="https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html" target="_blank">ways to prevent it</a>. IDOR occur when an application provides direct access to objects based on user-supplied input and without performing sufficient authorization checks.. As a result of this vulnerability attackers can bypass authorization and access resources in the system directly, for example database records or files. It can either include taking a filesystem path from user to retrieve file information but not checking if user is allowed access to the file, or even returning files from directory containing system data and not user data. Another example is returning database entries by reading one or more path and/or query parameters, and  not verifying if the user is allowed access to the data, even if user-role allows them to access the service.</p>
	
	<h3>Security related resources</h3>
	<p>The following resources are useful references for security related terminology, best practices, blogs, etc.</p>
	
	<h4>Center for Internet Security, or CIS</h4>
	<p id="1608831915">CIS home page can be found <a href="https://www.cisecurity.org/" target="_blank">here</a>. Particularly, note the <a href=" https://www.cisecurity.org/controls/cis-controls-list/" target="_blank">20 points guidelines</a> provide dby CIS covering for various aspects of software security.</p>
	
	<h4>Mozilla WebAppSec</h4>
	<p id="1608832263">The <a href="https://wiki.mozilla.org/WebAppSec" target="_blank">Mozilla Web Application Security wiki</a> provides a list of <a href="https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines" target="_blank">secure coding guidelines</a> that is extremely useful.</p>
	
	<h4>Open Web Application Security Project, or OWASP</h4>
	<p id="1608831965">The <a href="https://owasp.org/" target="_blank">OWASP</a> is a nonprofit foundation that works to improve the security of software. <a href="https://owasp.org/www-project-top-ten/" target="_blank">OWASP Top 10</a> vulnerabilities is a good place to check the more common security issues that should be identified and rectified in an application. A complete list of OWASP projects can be found <a href="https://owasp.org/projects/" target="_blank">here</a>.</p>
	
	<aside class="shown-individually-but-hidden-in-ebook"><i><strong>Read this article, and more, in ebook <a href="/productionizing/productionizing-backend-development/#1608343369">here</a>.</strong></i></aside>
</article>
