<!--
    HTML book section: Security related terms glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Security related terms</h2>
	<p>This page lists the various terms that relate to securing the request. Please note that complete application security goes much further and the list below is not exhaustive. For example, physically securing the servers by setting firewall, installing only necessary software, updating/pathing softwares, securing database via passwords, etc. are some examples of securing an application which are not mentioned below.</p>
	
	<h3>Authentication</h3>
	<p id="1608736802">A web application receives requests from someone/somewhere, that then needs to be processed and a corresponding response returned. However, in doing so, the application must prevent one user from mistakenly or attackingly assume identity of another user to access someone else's data. This is where the concept of Authentication comes in, wherein, the web application asks for details from user making the request to verify that "the entity making a request" is same as a given "user of the application". Traditionally, this is done by collecting an username and pasword from the user. Authentication as a topic goes further detailed beyond simply collecting these a password and it is highly instructive to refer to this article at <a href="https://en.wikipedia.org/wiki/Authentication" target="_blank">Wikipedia</a>. As the application evolves and becomes more critical, it is highly suggested to enforce stronger authentication, like, Multifactor authentication. Also note that even though the above article includes "Authorization" section towards the end, it is a different concept altogether. In this book, authentication and authorization are dealt separately.</p>
	
	<h4>Cookie and Token based authentication</h4>
	<p id="1608739818"><a href="#1608922565" data-nav-id="1608303678">HTTP requests are in themselves stateless</a>. Making a HTTP call is not dependent on past calls, nor does it affect future calls. This raises a question on how to provide authentication details to server such that it does not preclude the user from sending some other data within request-body. Also, if there's a way to prevent collecting and sending the user credentials in every call. One way is to start by collecting authentication details from the user (like, username and password), authenticate the user, store the authenticated user-details on server side either in some cache or database, and return a session-id in the cookie. When subsequent requests are made, the session-id cookie gets sent back to server and the server can look up the corresponding user details from its cache or database. This is cookie based authentication. When the same cookie is returned in subsequent HTTP calls, then the server identifies it to be the same user. This is cookie based authentication. Another method starts with same way but after a succesful authentication, the server returns a random token specific to the user. The returned token may or may not have an expiry period after which it'll need to be refreshed. Now in future calls, the user must send that token back as part of <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication" target="_blank">Authorization request header</a> (once again, realize that this is "authentication" process, not "authorization", despite the name of request header). The most common token based authentication is <a href="https://tools.ietf.org/html/rfc6750" target="_blank">Bearer authentication</a>. Slightly different from token based authentication is <a href="https://tools.ietf.org/html/rfc7617" target="_blank">Basic authentication</a> where encoded username and pasword are sent in request header.</p>
	
	<h4>JWT authentication</h4>
	<p id="1608743016">See article about <a href="https://jwt.io/introduction/" target="_blank">Json Web Tokens (JWT)</a>. A JWT is a text consisting of 3 portions joined together by a period. The second portion is called "payload" and is Base64 encoding of a json object that contains necessary user details. In addition to user data, there are few more fields, like, issuer and expiration time (This allows JWT to be time bound and lose validity after expiration). The third is called signature that is formed by combining the first and second portion of JWT along with a secret. This allows JWT to be read by anyone receiving it but prevents someone from tampering details in JWT's payload and sending that back to server. The way it works: user gives a username and password during login. After authentication, the server returns a JWT token. In subsequent request, the JWT is sent in request header back to server. If it is tampered with, or expired, or belongs to different issuer, then the user is not authenticated. Else, receiving the token (containing user details) implies that the request containing it is coming from someone to which the server issued this token in past, which could only be for an authenticated user. This is how having a JWT provides an authentication.</p>
	
	<h4>OpenID and OAuth</h4>
	<p id="1608748483">See article about OpenID at <a href="https://en.wikipedia.org/wiki/OpenID" target="_blank">Wikipedia</a>. OpenID was designed to be decentralized authentication protocol that allows users to be authenticated by a trusted third party service. This eliminates the need for various web applications to provide their own ad hoc login systems and store user credentials, and instead allows users to log into multiple unrelated websites without having to have a separate identity and password for each. However, with the rise of companies like Google, Facebook, Twitter and the ecosystem of services and products offered by them, the user expectation from other websites changed. Now, users instead want an ability in other websites to be able to log into, say, Google and make a calendar entry, or log into Facebook and make a post on their wall. This gave rise to <a href="https://en.wikipedia.org/wiki/OAuth" target="_blank">OAuth</a> which is an open standard for access delegation, commonly used as a way for users to grant websites or applications access to their information on other websites (like Google, Facebook, etc.) but without giving them the corresponding passwords (for more implementation details, see articles <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" target="_blank">here</a> and <a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth" target="_blank">here</a>). Hence, the "Auth" in OAuth is actually "authorization" and for various business who want access to user profile on target websites. However, OAuth can also be used for authentication purpose (see <a href="https://en.wikipedia.org/wiki/OAuth#OpenID_vs._pseudo-authentication_using_OAuth" target="_blank">here</a>), which is formalized to form <a href="https://openid.net/connect/" target="_blank">OpenID Connect</a>.</p>
	
	<h3>Authorization</h3>
	<p id="1608754365">See article about authorization at <a href="https://en.wikipedia.org/wiki/Authorization" target="_blank">Wikipedia</a>. While authentication relates to identifying the entity making a request with the user details stored in application, authorization relates to putting checks on the verified user from accessing data that they should not access. At a minimum, it includes both preventing an unauthenticated/anonymous user from accessing data available to authenticated users and preventing an authenticated user from accessing data belonging to another user. In addition to these two rules, additional rules can be added as part of authorization.</p>
	
	<h4>Permission bits</h4>
	<p id="1608825700">See details about permission bits usage in setting traditional unix file permissions in this article at <a href="https://en.wikipedia.org/wiki/File-system_permissions#Traditional_Unix_permissions" target="_blank">Wikipedia</a> and <a href="https://docs.nersc.gov/filesystems/unix-file-permissions/" target="_blank">NERSC</a>. Different permissions allowing read/write/excute, or combinations of them can be set for the file owner, the group that the file belong to, and for everyone else. Similar permissions can also be set for directories (however, execute permission on directory has different implications that execute permission on file). As an example, consider the case discussed in <a href="#1611502622" data-nav-id="1611200362">file system section of the data-storage glossary</a>. In that example, what happens if someone not your friend asks for the friend's note? Yhey should not be given access to your friend's data because it's not their data to own. Or, maybe your friend wants to allow other people to see the note but not be able to modify it. The file permission bits give user the flexibility to configure the file permissions.</p>
	
	<h4>Access control list, or ACL</h4>
	<p id="1608825749">See article about ACL at <a href="https://en.wikipedia.org/wiki/Access-control_list" target="_blank">Wikipedia</a>. An example of ACL can be seen <a href="https://documentation.suse.com/sles/12-SP4/html/SLES-all/cha-security-acls.html#sec-security-acls-handle-defacl-prac" target="_blank">here</a>. ACLs take the behavior of "permission bits" described above to a more granular level. Different permissions can be set be individual users or groups. The permission corresponding to the first matching entry in the list is ascribed to the user.</p>
	
	<h4>Role based access control, or RBAC</h4>
	<p id="1608827544">See article about RBAC at <a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank">Wikipedia</a>. Note that RBAC is an approach / architecture to restricting system access to authorized users, it is not a third party software. RBAC implementation can vary for different business but the underlying architecture remains, which is, to ascribe role for each user profile and define permissions only using the role identified for a user after they have been authenticated. This form of authorization is easier to manage at corporate level because a user simply needs to be added-to / remove-from appropriate role to ensure their authorized interaction with the system; And for this reason it is preferred compared to having ACLs (reference: <a href="https://security.stackexchange.com/questions/346/what-is-the-difference-between-rbac-and-dac-acl" target="_blank">here</a> and <a href="https://stackoverflow.com/questions/31941767/what-is-the-exact-difference-between-acl-and-rbac-in-general" target="_blank">here</a>).</p>

	<h4>Rate limiting, or Throttling</h4>
	<p id="1608830335">See articles about Throttling at <a href="https://en.wikipedia.org/wiki/Throttling_process_(computing)" target="_blank">Wikipedia</a> and <a href="https://docs.developer.amazonservices.com/en_DE/dev_guide/DG_Throttling.html" target="_blank">AWS</a>. It can be seen as a time-based authorization process wherein a user is disallowed to access API (or certain subsections) at a higher rate that an allowed value. From a business viewpoint, the most likely case for applying throttling is to enforce API access bounds set by payment tier subscribed by the user. Another important use case to apply throttling is to control access rate to resource-intensive APIs and to prevent system from becoming unresponsive.</p>
	
	<h4>Cross-origin resource sharing, or CORS</h4>
	<p id="1608830395">See article about CORS at <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank">Wikipedia</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank">Mozilla</a>. With ability to perform AJAX requests from webpages, a user may get exploited by an attacker, if the attacker hosted webpage is able to freely make calls to some other domain (i.e. website). Being on attacker's webpage, the user would never know of such background calls being made. Thus, while a web page may freely embed cross-origin images, stylesheets, scripts, iframes, it is forbidden to make ajax requests as per the default <a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank">same-origin security policy</a>. A server can add response headers to identify other domains that all allowed to make CORS request to it, what methods are allowed. These response headers are: <code>Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers, Access-Control-Max-Age</code>. For developers, CORS is one of the issues that sneaks in totally unexpected.</p>
	<p class="alert alert-warning">If in a time-pinch to develop something that will not get deployed to users and CORS is preventing progress, then there's a bypass to the problem using chrome's <a href="https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en" target="_blank">ModHeader</a> plugin. See <a href="/others/daily-software-tips.html#mod-header" target="_blank">here</a></p>
	
	<h3>Data in transit</h3>
	<p id="1608860102">See article about data in transit at <a href="https://en.wikipedia.org/wiki/Data_in_transit" target="_blank">Wikipedia</a>. Data in transit refers to the data that flows over a network, either in the public or untrusted network such as the Internet, or in the confines of a private network such as a corporate or enterprise Local Area Network (LAN). Following quick references can be used to identify ways to secure data in transit (<a href="https://brightlineit.com/data-encryption-transit-business-needs-know/" target="_blank">here</a> and <a href="https://security.berkeley.edu/data-encryption-transit-guideline" target="_blank">here</a>). For web application, the quickest way to secure data in transit is by using HTTPS rather than HTTP for communication.</p>
	
	<h4>Man-in-the-middle attack, and need for HTTPS</h4>
	<p id="1608857950">See article about man-in-the-middle attach at <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">Wikipedia</a> and <a href="https://us.norton.com/internetsecurity-wifi-what-is-a-man-in-the-middle-attack.html" target="_blank">Norton</a>. Using HTTP for communication and not encrypting data transferred between the client and server can allow someone to snoop the traffic and also modify it. Using HTTPS (references: <a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank">Wikipedia</a>, <a href="https://www.cloudflare.com/learning/ssl/what-is-https/" target="_blank">Cloudflare</a>) encrypts the data communicated between client and server and thwarts these attcks. Recently, search engines (like, Google) have started to give higher ranking to web applications that provide HTTPS connection. While encryption / decryption does add some extra CPU cycles, these are still much faster than database and network latencies which are dominant factor contributing to the response latency. Thus, using rationale of "efficiency" for not having HTTPS configuration is not a valid reason (Reference: <a href="https://www.cloudflare.com/learning/ssl/why-use-https/" target="_blank">Cloudflare</a>). Similaly, when communicating with different microservices within the organization, or invoking third-party api(s), it should also be done using HTTPS and not HTTP.</a>
	
	<h4>DNS over HTTPS</h4>
	<p id="1608857959">Domain Name System, or DNS (reference: <a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank">Wikipedia</a>, <a href="https://www.cloudflare.com/learning/dns/what-is-dns/" target="_blank">Cloudflare</a>) is a decentralized naming system for websites that allows translating from understandable and memorizable text address to ip-address used by computers. When a client initiates a web request, the initial call made is to DNS servers (see <a href="https://en.wikipedia.org/wiki/Domain_Name_System#Address_resolution_mechanism" target="_blank">here</a> for more details on domain name resolution) after which subsequent HTTP/HTTPS communication with the target server occurs. The initial communication with the DNS is traditionally done over HTTP which can allow internet service providers (i.e., the company that provides you the internet service) to perform a "man-in-the-middle" attack to get information on the websites you (i.e. the client making the web request) are visiting. This can be alleviated by using HTTPS to perform initial DNS call, and is called DNS over HTTPS. For additional details on DNS Security, refer to tihs article at <a href="https://www.cloudflare.com/learning/dns/dns-security/" target="_blank">Cloudflare</a>. Another alternative can also be for companies to host their own DNS servers to enable communication between different internal microservices and resources, and also to identify/control allowed third party api calls.</p>
	
	<h3>Data at rest</h3>
	<p id="1608860588">See article about data at rest at <a href="https://en.wikipedia.org/wiki/Data_at_rest" target="_blank">Wikipedia</a> and <a href="https://docs.microsoft.com/en-us/azure/security/fundamentals/encryption-atrest" target="_blank">Microsoft Azure</a>. Data at rest refers to data that is housed physically on computer data storage in any digital form, including both structured and unstructured data. For a business application, it can include among other entries, database entries, files, logs, emails and alerts containing user data. If a server filesystem is duplicated (like, using RAID, or combination of cloud storage), then "data at rest" definition covers data stored at all such places. Securing data at rest primarily relies on adding password protection to access the corresponding resource. For sensitive data, extra precautions are necessary including storing encrypted data, storing hash value rather than plaintext or even an encrypted data, stricter access restrictions and close auditing of users who are retrieving / modifying this infomation. The goal is to keep a close watch on sensitive data and to have it be unusable by attackers even if the data is stolen.</p>
	
	<h4>Password strength</h4>
	<p id="1608862099">See article about password strength at <a href="https://en.wikipedia.org/wiki/Password_strength" target="_blank">Wikipedia</a>. Having a strong security software would mean nothing if the password holding it together is extremely weak and easy to guess. A strong pasword must be used at all times, with different passwords for different systems, and also changing passwords regularly, at least after a major breach at any company.</p>
	
	<h4>Salting</h4>
	<p id="1608862270">See details about password salting <a href="https://cyberhoot.com/cybrary/password-salting" target="_blank">here</a> and <a href="https://crackstation.net/hashing-security.htm" target="_blank">here</a>. Password Salting is one of the most secure ways to protect passwords stored for future authentication without exposing them should your website be breached in the future and to prevent them from being reverse engineered by hackers. It involves adding a string of between 32 or more characters to a password and then hashing it. However, salted passwords must also be iteratively hashed multiple times for this protection to work. <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank">Bcrypt</a> is a good algorithm to use for password salting. MD5 and SHA must be avoided.</p>
	
	<h3>Common security issues</h3>
	<p>Following are some of the common security issues seen during web application development. Developers must aim to identify and prevent these vulnerabilities. Following accepted code development best practices along with proper code reviews should help identify and mitigate most of them.</p>
	
	<h4>Cross-site scripting, or XSS</h4>
	<p id="1608866075">See details about XSS at <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/xss/" target="_blank">OWASP</a>. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. One of the troubling aspects of XSS is that the flaws that allow these attacks to succeed are quite widespread and can occur anywhere a web application directly uses input from a user. Two main solutions to handle XSS attack is to verify / sanitize any text entry taken from user and in the web-page, only incorporate user-data at certain locations. For more details on XSS prevention, see <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" target="_blank">OWASP Cheatsheet</a>.</p>
	<p id="1610296182">There is a way to see an XSS attach occurring in this ebook. Click on one of "Add-note" buttons and add the following note: <code>&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;textarea&gt;</code>. Let's save it by clicking out of textbox and remember location of where the note was added since we'll be coming back to it soon. Click on a different navigation item on left to load a different page, and then click on navigation item to load the page where the note wa added. You'll notice 2 things happening: one, there will be an alert box when the page is loaded (like shown <a href="https://www.w3schools.com/jsref/met_win_alert.asp" target="_blank">here</a>), and instead of the note showing up that you just added, you'll see 2 textboxes. The XSS attack here is that in loading a text data, i.e. the note which was added, the browser instead intepreted it as valid html and ran a script. The script that ran generated the alert box. Generally though, the attacks won't be as innocent. Over here, the attack script was created by you, but what if you downloaded the entry from some other place? Bottom line: <strong>don't trust data coming from someone else.</strong> Frankly, there should have been some alarm bells ringing when I asked you to run this example and same should also happen if you're downloading note data from someone else and then loading it in your browser. Not that this shouldn't be done because doing so enables learning from each other. However, do exercise caution! A followup question: how is it that adding the note triggered xss attack but the first line in this paragraph also has the same line and not XSS attack is occurring there? [<a href="/others/daily-software-tips.html#change-website-render" target="_blank">Hint</a>]</p>
	
	<h4>Cross-site request forgery, or CSRF, or XSRF</h4>
	<p id="1608864350">See details about CSRF at <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/csrf" target="_blank">OWASP</a>. CSRF attacks exploit the property of web browsers that they will automatically include any cookies used by a given domain in any web request sent to that domain, and that they do so without notifying the users. This behavior, along with use of cookie based authentication, server <a href="#1608830395" data-nav-id="1608343369">CORS</a> setting and endpoint design can make a user vulnerable to CSRF attack. At a high level, the attack works by tricking a user into taking actions that trigger scripts which make a call from the browser of user to the server. In doing so, browser send all cookies and server authenticates this forged request as intentionally made by user due to presence of cookie based authentication. Hence, to the server, the forged request appears as real and it will perform any appropriately requested actions including returning data, manipulating session state, or making changes to the victim's account. The quickest solution to preventing a CSRF attack is to double submit a cookie, i.e. require a header containing same data as is present in cookie. However, a complete solution also requires analyzing the CORS policy set by the service. Also, note that if the web application is susceptible to XSS attack, then the attacker can still gain access to the cookie and fixing CSRF via sending a different header fails. For more details on CSRF prevention, see <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html" target="_blank">OWASP Cheatsheet</a>. Also, as much possible, the cookies set by the web application should also be secured as suggested <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Security" target="_blank">here</a>.</p>
	
	<h4>Server-side request forgery, or SSRF</h4>
	<p id="1608863938">See details about SSRF at <a href="https://en.wikipedia.org/wiki/Server-side_request_forgery" target="_blank">Wikipedia</a>, <a href="https://owasp.org/www-community/attacks/Server_Side_Request_Forgery" target="_blank">OWASP</a>. Consider a scenario where a web application WA1 accepts an a url from user, such that the server downloads file from that location, and as proof of download, then returns a copy of it in response. Now consider that the business hosting this application also has some other service WA2, managing some internal files that must not be made available to outside users. SSRF attack would occur if an attacker makes a call to WA1 giving it a url pointing to WA2 for retrieval of internal files. The attack is successful if WA1 makes a call to WA2 requesting for internal file, then WA2 responds without raising an error because a call coming from WA1 is like an internal call to WA2, and finally the internal file is returned back to attacker. Had the attacker made a direct call to WA2, the request might have failed, but it does not fail when routed via WA1. A base solution to solve such issues is that when a web application is performing an action on some internal / external web application, then the request must be constructed in a way to simulate as if coming from the user and not from internal system. Additionally, robust enterprise level authentication and authorization system is needed. Relying only on ip address for authorization is a design like to fail when multiple interacting services are introduced.</p>
	
	<h4>Insecure direct object references, or IDOR</h4>
	<p id="1608862776">See details about IDOR at <a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References" target="_blank">OWASP</a>, including <a href="https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html" target="_blank">ways to prevent it</a>. IDOR occur when an application provides direct access to objects based on user-supplied input and without performing sufficient authorization checks.. As a result of this vulnerability attackers can bypass authorization and access resources in the system directly, for example database records or files. It can either include taking a filesystem path from user to retrieve file information but not checking if user is allowed access to the file, or even returning files from directory containing system data and not user data. Another example is returning database entries by reading one or more path and/or query parameters, and  not verifying if the user is allowed access to the data, even if user-role allows them to access the service.</p>
	
	<h3>Security related resources</h3>
	<p>The following resources are useful references for security related terminology, best practices, blogs, etc.</p>
	
	<h4>Center for Internet Security, or CIS</h4>
	<p id="1608831915">CIS home page can be found <a href="https://www.cisecurity.org/" target="_blank">here</a>. Particularly, note the <a href=" https://www.cisecurity.org/controls/cis-controls-list/" target="_blank">20 points guidelines</a> provide dby CIS covering for various aspects of software security.</p>
	
	<h4>Open Web Application Security Project, or OWASP</h4>
	<p id="1608832263">The <a href="https://wiki.mozilla.org/WebAppSec" target="_blank">Mozilla Web Application Security wiki</a> provides a list of <a href="https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines" target="_blank">secure coding guidelines</a> that is extremely useful.</p>
	
	<h4>Open Web Application Security Project, or OWASP</h4>
	<p id="1608831965">The <a href="https://owasp.org/" target="_blank">OWASP</a> is a nonprofit foundation that works to improve the security of software. <a href="https://owasp.org/www-project-top-ten/" target="_blank">OWASP Top 10</a> vulnerabilities is a good place to check the more common security issues that should be identified and rectified in an application. A complete list of OWASP projects can be found <a href="https://owasp.org/projects/" target="_blank">here</a>.</p>
</article>
