<!--
    HTML book section: Architecture related term glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Architecture related terms</h2>
	<p>This page lists the various terms that relate to coding principles and the corresponding architecture those principles promote.</p>
	<p>Architecture related terms and corresponding discussions are purposefully mentioned at the very last to explicitly highlight where one should identify its importance in the hierarchy of product development. These are important terms - no doubt; And no doubt indeed because the entire book focuses around architecture discussion! However, realize that these discussions must not take precedence over the business itself. If choosing between having a feature out fast which is secure and works as intended but does not comply to architecture patterns, versus putting extra time to have a properly designed feature, one should choose the former option, and incur a technical debt and then try to fix the technical debt subsequently. This way, the product would have been out for some time. However, if a counter concerns is that the product managers will not subsequently allow time for technical debt to get addressed and will bring in a new product feature to be added, then that's a different discussion altogether.</p>

	<h3>Coding principles related terms</h3>
	<p id="1609207851">Coding principles are guidelines that an industry, organization, team or individual adopt to improve software designs and code implementation (reference: <a href="https://simplicable.com/new/coding-principles" target="_blank">Simplicable</a>, <a href="https://en.wikipedia.org/wiki/Category:Programming_principles" target="_blank">Wikipedia</a>). However, for the purpose of this e-book, only the coding principles that affect backend development will be covered. The ones covering front end, or infrastructure will not be covered. The coding principles adopted by a team itself derives from business priorities identified by the team. For example: consider the principle of <a href="https://en.wikipedia.org/wiki/Defensive_programming" target="_blank">"Defensive programming"</a> that suggest handling every scenario that can happen. Contrast it with when a software is in its initial stages as a new product. Not every feature is hashed out because it is not known on how the user will interact with it. Optimizing the product for every scenario may take precious time away from more in-demand features and may factor towards the failure of the product. Listed below are some of the coding principles that I believe are important.</p>
	
	<h4>Black box</h4>
	<p id="1609208440">Reference: <a href="https://en.wikipedia.org/wiki/Black_box" target="_blank">Wikipedia</a>. The "Black box" is an important principle suggests that a new functionality in a software should behave as per the business requirements, and without needing to know how the actual coding is done; Also, it should be able to do so different inputs. Just like a black box, a software functionality should take a particular set of input every time, and return an output. Consider applying this principle at basic data level, wherein a combination of raw data along with allowed operations that can be done on it forms a black box. Any code the interacts with the cluster does so via the allowed operations and never directly with the data. This is the principle of "encapsulation" in <a href="#1609290898">object oriented programming</a> (discussed later). Going one level up, consider applying this principle to a collection of objects and methods forming a "module" (in Python or Javascript), or a "package" in Java. Doing so suggests that the objects/method should have closely related functionality that is separate from other modules or packages. This is also called <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" target="_blank">code cohesion</a>. Treating software functionality as a black box also helps in easily testing it.</p>
	
	<h4>Code reuse</h4>
	<p id="1609213969">Reference: <a href="https://en.wikipedia.org/wiki/Code_reuse" target="_blank">Wikipedia</a>. In adding a new functionity to a software, as much possible of old code should be used. Practice of reusing code is motivated by additional reasons, like, doing so enables faster development time by saving time to rewrite same code and corresponding tests. It also confirms that other portions of the software have been properly defined (..in terms of what they do) and have been properly "black boxed" because had this not been done, it wouldn't be possible to reuse the existing code. Additionally, if code is not being reused and is instead getting duplicated, then it becomes confusing to know whether the two duplicated code portions should change hand-in-hand or if they represent different features. This principle also relates to the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank">"Don't repeat Yourself", or DRY</a> principle, which states that <i>"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system."</i></p>
	
	<h4>Fail-fast</h4>
	<p id="1609214101">Reference: <a href="https://en.wikipedia.org/wiki/Fail-fast" target="_blank">Wikipedia</a>. Also see <a href="https://en.wikipedia.org/wiki/Offensive_programming" target="_blank">Offensive programming</a>. The "Fail fast" principle suggests that if the inputs given to a command should result in a failure, then the failure should be identified as quickly possible. The "quick" is not to try and get some performance points, but instead is done with intention to prevent any unintended side-effects from happening before the code fails. In contrast to <a href="https://en.wikipedia.org/wiki/Defensive_programming" target="_blank">defensive programming</a>, having a fail-fast behavior ensures setting bounds to limits of execution for the software; And if the customer encounters any such limits, it will be immediately visible and can be reported to product managers for remediation. This further ties in with the <a href="https://en.wikipedia.org/wiki/Worse_is_better" target="_blank">"Worse is better"</a> principle.</p>
	
	<h4>Premature optimization is the root of all evil</h4>
	<p id="1609214109">This line is used in different articles to support the idea that development time should not be wasted in making nit-pick improvements. This also sees a support from business viewpoint that more priority and focus should be towards features and developments that bring in revenue or clear blocks that may check future growth. Similar aphorisms also exist, like, "If it ain't broke, don't fix it", and are added to further drive the message to not go into optimizing code. The irony, however, is that this is not the intent of the quote. Sourced from <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.103.6084&rep=rep1&type=pdf" target="_blank">here</a>, adding a few lines before and after the quote change it to <i>"The conventional wisdom shared by many of today's software engineers calls for ignoring efficiency in the small; but I believe this is simply an overreaction to the abuses they see being practiced by pennywise-and-pound-foolish programmers, who can't debug or maintain their "optimized" programs. In established engineering disciplines a 12 % improvement, easily obtained, is never considered marginal; and I believe the same viewpoint should prevail in software engineering. Of course I wouldn't bother making such optimizations on a oneshot job, but when it's a question of preparing quality programs, I don't want to restrict myself to tools that deny me such efficiencies. There is no doubt that the grail of efficiency leads to abuse. Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: <u>premature optimization is the root of all evil</u>. Yet we should not pass up our opportunities in that critical 3 %. A good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only after that code has been identified. It is often a mistake to make a priori judgments about what parts of a program are really critical, since the universal experience of programmers who have been using measurement tools has been that their intuitive guesses fail."</i></p>
	<p id="1609214110">From above, it can be concluded that if there's a particular code that will get called multiple times (as identified from an analysis and not by guesswork), then working to optimize it is not an improper use of time. Also, see this related <a href="https://softwareengineering.stackexchange.com/questions/80084/is-premature-optimization-really-the-root-of-all-evil" target="_blank">discussion</a>. Also note that this discussion lends itself to the <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" target="_blank">"You Aren't Gonna Need It", or YAGNI</a> principle that states a programmer should not add functionality just because they foresee it as being needed. Instead, it should be done only after adding the new functionality is deemed necessary.</p>
	
	<h4>Inversion of control, or IoC</h4>
	<p id="1609259673">Reference: <a href="https://en.wikipedia.org/wiki/Inversion_of_control">Wikipedia</a>. In traditional programming, it is the custom code that expresses the purpose of the program calls, and to do so, it calls reusable libraries to take care of generic tasks. However, with IoC, it is the generic framework that calls into the custom, or task-specific, code. In IoC, custom-written portions of a computer program receive the flow of control from a generic framework. IoC is used to increase modularity of the program and make it extensible. From a business viewpoint, this applies because what comes first is just soe basic version of the product, to which future enhancements are added as a sub-feature. As example is defining a default browser for your computer/phone. With IoC, you instruct your phone (i.e., the generic framework in the example) to open a web-page, and it does so by passing request to the default browser (i.e., a custom code in the example). In future, you can add/remove broser, change defaults, but doing so still does not break the ability of phone to open a web-page. The ability to install multiple browsers is the "extensibility" that your phone (i.e., the generic framework in the example) gets with IoC.</p>
	<p id="1609260879">This principle also lends itself to <a href="https://en.wikipedia.org/wiki/John_Gall_(author)#Gall's_law" target="_blank">Gall's law</a> that states <i>"A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system."</i> It reinforces starting with a simple design first and then adding custom code to handle special scenarios. Having a similar flavor is the <a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank">Keep It Simple, Stupid, or KISS</a> principle, which states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. However, it should be noted that continuous incremental addition of simple code components done by different team mebers unaware of different portions of overall code base can cause code to be duplicated or be badly/improperly defined in what it intends to achieve. This interferes with the <a href="#1609208440">"Black box"</a> and <a href="#1609213969">"Code reuse"</a> principle described above. So, having simplicity in codebase comes with an ironical responsibility of progressively making it complex by revisiting definitions and creating hierarchies in the generic framework. This bring in the <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)" target="_blank">Rule of Three</a> which is a code refactoring rule of thumb to decide when similar pieces of code should be refactored to avoid duplication. It states that two instances of similar code don't require refactoring, but when similar code is used three times, it should be extracted into a new procedure, i.e.,  "Three strikes and you refactor".</p>
	
	<h4>Loose coupling, and the Law of Demeter</h4>
	<p id="1609262426">Before stating with "Loose coupling", let's look at another aspect of "Inversion of Control" (IoC). In the <a href="#1609259673">IoC section</a>, it is suggested that a generic framework should call into the custom codes. This brings in a <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg" target="_blank">"chicken or egg"</a> problem. How does the generic framework know what custom codes could get used in future or how to interact individually with them? Or, is it that the custom code is made first and then a generic framework is made to interact with it; And if so, then why the extra work? This twist is the nature of software development. The solution to the problem is that the custom code comes first, and as the codebase grows, it is refactored and broken into a generic framework and specialized codes with the hope that doing so will promote code reuse of the generic framework and make it easier to add new custom features that hook into the generic framework. This is also discussed under the <a href="#1609259673">IoC section</a>. "Loose coupling" is the name of that expectation with which the code was refactored to create the generic framework, i.e. any new custom code will use a standard way of interacting with the generic framework, as laid out by that framework, and that it will provide only that small functionality as expected from it by the generic framework and no more, and so, it will not try to interact with any unrelated component. This also implies that the concept of loose coupling comes in limelight when IoC based design is used to have a generic framework and multiple specific codes that interact with it.</p>
	<p id="1609263762">Coming back to loose coupling.. see reference: <a href="https://en.wikipedia.org/wiki/Loose_coupling" target="_blank">Wikipedia</a>. Loosely coupled system is one in which each of its components has, or makes use of, little or no knowledge of the definitions of other separate components. Components in a loosely coupled system can be replaced with alternative implementations that provide the same services. The <a href="https://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank">Law of Demeter, or LoD</a>, also called principle of least knowledge is a design guideline based on notion that an object should assume as little as possible about the structure or properties of anything else (including its subcomponents), in accordance with the principle of <a href="https://en.wikipedia.org/wiki/Information_hiding" target="_blank">"information hiding"</a>. It may be viewed as a corollary to the <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank">principle of least privilege</a>, which dictates that a module possess only the information and resources necessary for its legitimate purpose.</p>
	<p id="1609290127">This principle also lends itself to <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" target="_blank">"Composition over inheritance"</a>. Composition over inheritance states that in <a href="#1609290898">object oriented programming</a> (discussed later), a class should achieve polymorphic behavior and code reuse via composition (i.e. by containing instances of other classes that implement the desired functionality) rather than inheritance from a base or parent class. Using inheritance creates a strong coupling between the base and derived class such that changing any functionality in base class changes corresponding function in all derived class in an implicit/hidden manner. Side note:  A good way to identify difference between whether to use composition vs inheritance is by checking if a "has-a" or "is-a" relation exists between the derived and the base class. For example: one would say "A laptop has a processor", but "A Dell-laptop is a laptop". In the first example, having a "has-a" relation means that a laptop class should be formed by composing over contained instances, one of which is a processor. In the second example, having a "is-a" relation means that a "Dell laptop" may be formed by extending a "laptop" class. Once again though, realize that doing so creates a strong coupling, and any time the "laptop" definition is changed, it will also change the definition of "Dell laptop". The "is-a" relation, once realized, must be guaranteed to also hold forever. If this is not possible, prefer to stay on using composition. If you want to change a current design that uses inheritance and instead use composition, and want to do so with minimal disruption, then use the "Stimulated Multiple Inheritance" patterns as described in Joshua Bloch's "Effective Java".</p>
	<p id="1609302990">In the above example, if each contained instance is modeled as an independent coding <a href="https://en.wikipedia.org/wiki/Concern_(computer_science)" target="_blank">concern</a>, then this principle also lends to the idea that a preferable construct for a generic framework capable of handling multiple concerns. The principle suggest that the framework should be loosely coupled to each concern and should be constructed by composing over various concerns which can be independently added/removed. This is the principle of <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank">"separation of concerns"</a>.</p>
	
	<h3>SOLID</h3>
	<ul id="1609301770"><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank">SOLID</a> is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible, and maintainable.
		<li><b>S</b>: <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank">Single-responsibility principle</a> suggests that a class should only have a single responsibility, that is, its implementation maps to one part of the software's specification and vice versa. This promotes <a href="#1609213969">code reuse</a> because any new feature dependent on same specification would use this class as a dependency. By restricting the design of the class to raise an error when used in a manner outside the defined specifications, a <a href="#1609214101">fail-fast</a> behavior is realized. This also makes it easier to <a href="#1609214109">identify and check premature optimization</a> since extraneous code will not map to any requirements.</li>
		<li><b>O</b>: <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank">Openâ€“closed principle</a> states that software entities should be open for extension, but closed for modification. The "closed" behavior suggests that a software entity should have a well-defined, stable description like a <a href="#1609208440">black box</a>.  The "open" behavior allows using both inheritance or composition to extends a behavior. However, as discussed above, <a href="#1609290127">composition should be preferred over inheritance</a>. Check the next point (i.e., "L", or "Liskov substitution principle") for guidance on when inheritance can be used. Everywhere else, use "composition" instead to form new class.</li>
		<li><b>L</b>: <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank">Liskov substitution principle</a> gives a direct guidance on when inheritance can be used. It suggests that when using inheritance, the base class objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. A place within the code where it naturally happens is when inheritance is used to extend an interface or an abstract class. On personal note, I would suggest that these two are the only valid place for using inheritance to construct a new class, and everywhere else, using composition should be preferred over inheritance.</li>
		<li><b>I</b>: <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank">Interface segregation principle</a> suggests that having multiple client-specific interfaces are better than one general-purpose interface. This promotes having a <a href="#1609208440">black box</a> like behavior in relation to how a client views any single interaction with the overall software. This consideration applies at time of designing software components, i.e. before specific implementations are coded.</li>
		<li><b>D</b>: <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank">Dependency inversion principle</a> suggests that implementations of high-level modules should not depend on implementations of low-level modules and instead both should depend on the corresponding abstractions (e.g., interfaces). This enables the software design stage to command more time in clarifying interactions between different components. Subsequent tasks for coding various implementations can then be split and done in parallel. This also makes the software flexible in that different implementations can be swapped or chained at any time without affecting other portions of the software. This promotes an <a href="#1609259673">inversion of control</a> wherein interaction between the software components are controlled by abstractions and by the corresponding generic framework containing these abstractions. Specific implementations are then wired into it to enable the software achieve desired result.</li>
	</ul>
	<p id="1609345387">Note how the concept of SOLID captures all coding principles defined in <a href="#1609207851">previous section</a>. It is for this reason, the <a href="#1607048361" data-nav-click="true">one-line summary</a> for this book suggests users to rely on this mnemonic acronym whenever the find themselves doubtful on how to design and implement a software or a feature within the software.</p>
	
	<h3>Programming paradigms</h3>
	<p id="1609350881">Reference: <a href="https://en.wikipedia.org/wiki/Programming_paradigm" target="_blank">Wikipedia</a>, <a href="https://cs.lmu.edu/~ray/notes/paradigms/" target="_blank">article at lmu.edu</a>. A programming paradigm is a style or a way of programming. Some programming languages make it easy to write code with certain paradigms but not others.</p>
	
	<h4>Imperative and declarative programming paradigms</h4>
	<p id="1609361331">The two major paradigms are <a href="https://en.wikipedia.org/wiki/Imperative_programming" target="_blank">imperative</a> and <a href="https://en.wikipedia.org/wiki/Declarative_programming" target="_blank">declarative</a> style of coding. In the imperative style of coding, the programmer explicitly instructs the machine how to change its state. It has two main features: explicitly stating the order in which operations occur in addition to having constructs that control the order, and, allowing for side effects to occur such that state can be modified at one point in time, within one unit of code, and then later read at a different point in time inside a different unit of code. An imperative style can be considered as implementing some algorithm in explicit steps. In the declarative style, the program describes what must be accomplished in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives. For more details, see <a href="https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-paradigm-in-programmin" target="_blank">this question on StackOverflow</a>.</p>
	
	<h4>OOP</h4>
	<p id="1609290898"></p>
	Make sure to have id=1609290898 because that's referred in code bove
	Encapsulation vs abstaction
	https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)
	Link to composition over inheritance discussed previous
	
	<h4>AOP</h4>
	<p id=""></p>
	
	Functional programming
	functions as first class in oop
	
	<h3>Design patterns</h3>
	<p id="1609346397"><a href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank">Software design pattern</a> is a generally accepted and reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design the a product can directly use, nor is it a finished code that can be added directly in the code. Rather, it is a description for how to solve a problem that the community of programmers/developers have identified and also support. It may be viewed as a structured approach to computer programming that is intermediate between the levels of a programming paradigm and a concrete algorithm. Note that the patterns are dependent on the programing paradigm being used. Most commonly referred design patterns are for <a href="#1609290898">object oriented paradigm</a>,but they may not be suitable for non-object-oriented languages. Also, it is possible for a programming language to have built in features for a specific problem and it may not be necessary to use the pattern. Some common places to get design patterns are: <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank">Design Patterns (book)</a>, <a href="https://martinfowler.com/articles/enterprisePatterns.html" target="_blank">catalog of multiple patterns</a>, <a href="https://www.enterpriseintegrationpatterns.com/" target="_blank">Enterprise integration patterns</a>, <a href="https://www.tutorialspoint.com/design_pattern/design_pattern_overview.htm" target="_blank">tutorialspoint.com</a>, <a href="https://github.com/iluwatar/java-design-patterns" target="_blank">here</a>.</p>
	
	<h4>Antipatterns</h4>
	<p id="1609348200"><a href="https://en.wikipedia.org/wiki/Anti-pattern" target="_blank">Anti-pattern</a> is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive. A few places to get antipatterns, in addition to the <a href="https://en.wikipedia.org/wiki/Anti-pattern" target="_blank">Wikipedia</a> page, are at <a href="https://sourcemaking.com/antipatterns" target="_blank">sourcemaking.com</a> and this <a href="https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns" target="_blank">wiki book</a>.</p>
	
	<h3>Microservice</h3>
	<p id="1609350800">Reference: <a href="https://martinfowler.com/articles/microservices.html" target="_blank">article by Martin Fowler</a>, <a href="https://microservices.io/" target="_blank">website for "Microservices Patterns" book</a>, <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank">Wikipedia</a>, <a href="https://medium.com/hashmapinc/the-what-why-and-how-of-a-microservices-architecture-4179579423a9" target="_blank">Medium</a>.
	Microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. In doing so, the microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to independently evolve its technology stack. Needless to say, the topic of microservice architecture goes in much more depth and are covered in the references and elsewhere. It also comes with it own set of design patterns. Some places that cover it are <a href="https://microservices.io/book" target="_blank">"Microservices Patterns" book</a> and <a href="https://docs.microsoft.com/en-us/azure/architecture/microservices/design/patterns" target="_blank">this article at Microsoft</a>.</p>
	
	<h3>12-factor development</h3>
	<p id="1609295682"><a href="https://12factor.net/" target="_blank">The 12 factor app development</a> lists 12 suggestion for development and deployment of modern web service. It is strongly suggested to go through each of the suggestions, understand it and incorporate it in practice.</p>
</article>
