<!--
    HTML book section: Infrastructure related term glossary to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<aside class="shown-individually-but-hidden-in-ebook"><i><strong>Read it in ebook <a href="/productionizing/productionizing-backend-development/#1608344368">here</a></strong></i></aside>
	
	<nav class="article-toc">
		<h2>Table of contents</h2>
		<a href="#1618695712" data-nav-id="1608344368">Infrastructure related terms</a>
		<ul>
			<li><a href="#1608393835" data-nav-id="1608344368">Server</a></li>
			<li><a href="#1608394258" data-nav-id="1608344368">Cloud computing</a></li>
			<li><a href="#1608395384" data-nav-id="1608344368">Load balancer</a></li>
			<li><a href="#1612493359" data-nav-id="1608344368">Content delivery network, or CDN</a></li>
			<li><a href="#1612491901" data-nav-id="1608344368">Denial of Service, or DoS attack</a></li>
			<li><a href="#1618696016" data-nav-id="1608344368">Data storage</a></li>
			<li><a href="#1617405655" data-nav-id="1608344368">Web application framework</a></li>
			<li><a href="#1608564873" data-nav-id="1608344368">Code repository</a></li>
			<li><a href="#1608565983" data-nav-id="1608344368">Continuous Delivery (or, CD), and Continuous Integration (or, CI)</a></li>
			<li><a href="#1608570000" data-nav-id="1608344368">Virtualization versus Containerization</a></li>
			<li><a href="#1608572592" data-nav-id="1608344368">System Monitoring</a><ul>
				<li><a href="#1608575849" data-nav-id="1608344368">SLO, SLI and Error budget</a></li>
			</ul></li>
		</ul>
	</nav>
	
	<h2>Infrastructure related terms</h2>
	<p id="1618695712">This page lists the various terms that relate to infrastructure and other applications needed to support the deployment and hosting of a web application. Since this book focuses on backend development, it may not use all of the terms. Nonetheless, it is important for a backend software developer to be aware of these terms and what they mean.</p>
	
	<h3>Server</h3>
	<p id="1608393835">See article about server on <a href="https://en.wikipedia.org/wiki/Server_(computing)" target="_blank">Wikipedia</a>. It is a combination of software and hardware that reads an incoming request and returns a response. The entity making the request is called a "client". In backend development, developers leverage an existing software framework that handles common task of reading a generic incoming request and sending a generic response, and leaves gaps for pluggable custom code to provide specific business logic. Also note, a server should be able to handle multiple simultaneous request from each client in an independent manner, i.e., without letting any request know about others. So, how does a server know about the client to which it should send a response to? In short, it uses client address and port to define a connection over which the response is sent (see <a href="https://unix.stackexchange.com/questions/75011/how-does-the-server-find-out-what-client-port-to-send-to" target="_blank">here</a>).</p>
	
	<h3>Cloud computing</h3>
	<p id="1608394258">See article about cloud computing on <a href="https://en.wikipedia.org/wiki/Cloud_computing" target="_blank">Wikipedia</a> and on <a href="https://azure.microsoft.com/en-us/overview/what-is-cloud-computing/#cloud-deployment-types" target="_blank">Microsoft Azure</a>. Consider youself as opening an e-business and also having a corresponding software code to achieve the goal. However, for the business to begin, the software code needs to deployed to servers. And then comes a whole lot of hardware and software maintenance, upgrades, security patches. If your business is a hit, you'd want more servers and quickly. Maybe a lot more users show up at certain time of day or year, then you'd like to have more servers for just that small time. What if your business does not work out - now you want to sell the servers for cost recovery! Needing a server is like wanting to go between 2 places in a city. Owning a server is like buying a car. It is good for certain use cases and it comes with its constraints, like, you need to know how to drive a car. Cloud service is like a cab service or ride share. You don't bother with anything about driving or car but you're paying a small fraction towards someone else's profit out of your own. It is good during initial stages and can be revisited later.</p>
	
	<h3>Load balancer</h3>
	<p id="1608395384">See article about load balancer on <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank">Wikipedia</a>, <a href="https://www.citrix.com/glossary/load-balancing.html" target="_blank">Citrix</a> and <a href="https://www.nginx.com/resources/glossary/load-balancing/" target="_blank">Nginx</a>. A load balancer, simply put, balances load of incoming request to different backend servers. The main goal is to have each server get an uniform workload for request processing. This ensures optimal user experience by not having them wait simply becaue the request got routed to a busy server while another server is free. Different routing strategies can be configured to distribute load and to enable various response caching strategies suitable to business needs. Additionally, HTTPS termination can also be done at this layer before sending the request to server. It can also send periodic health checks to backing servers and remove routing traffic to inactive servers.</p>
	
	<h3>Content delivery network, or CDN</h3>
	<p id="1612493359">See articles about content delivery network, or CDN at <a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank">Wikipedia</a> and <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/" target="_blank">CloudFlare</a>. A CDN is a geographically distributed network of servers and that serve static web resources (like, HTML files, style, javascript files, images, etc.) to geographically distributed end users. In doin so, it enables high availability of the data (i.e., ensuring data remains available even if certain servers beomes unavailable for whatever reason) and iimproves speed of fownloading the resource (because it is faster for users to download the content from a CDN server which is physically closer to the user). By offloading the task of serving static web resources which by definition do not change over time, or do so very infrequently, the servers hosting the business application free up additional capacity it can use to handle user request. For this reason, certain web application frameworks directly suggest using CDNs for serving static content, example, <a href="https://docs.djangoproject.com/en/3.1/howto/static-files/deployment/#serving-static-files-from-a-cloud-service-or-cdn" target="_blank">Django framework making the suggestion in its docs</a>.</p>
	
	<h3>Denial of Service, or DoS attack</h3>
	<p id="1612491901">See articles about Denial of Service or DoS attack at <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank">Wikipedia</a>, <a href="https://www.comparitech.com/net-admin/dos-vs-ddos-attacks-differences-prevention/" target="_blank">this article</a> and at  <a href="https://aws.amazon.com/shield/ddos-attack-protection/" target="_blank">AWS</a>. A denial-of-service, or DoS attack is a cyber-attack in which the attacker seeks to make a web resource unavailable to its intended users by disrupting services of the server hosting the resource. It is typically accomplished by flooding the targeted machine or resource with superfluous requests in an attempt to overload systems and prevent some or all legitimate requests from being fulfilled. Think of it like driving with a passenger who keeps asking "are we there yet?" - to which you, the driver, needs to respond. However, the passenger's intention is not to get the answer but to keep asking it so frequently that you cannot focus on driving, thereby bringing the driving activity to a stop. A distributed denial of service, or DDoS attack is when there are many such systems performing the attack which itself could have been initiated by a single entity. Since the requests in DDoS attack come from different ip-addresses, it is much harder to deal with compared to DoS attack. Unlike other attacks that use weakness in code or user authentication/authorization (these are discussed in the <a href="#1608343369" data-nav-id="1608343369">security glossary</a>), the DoS or DDoS attack seeks to make the entire service unavailable for all users. Combating DDos attack is something that cannot be done within the web application and involves invest in infrastructure components to enable handling such attacks; For this reason, it is discussed under the infrastructure glossary. One DDoS attack mitigation strategy is to use CDNs or ocloud-based providers and have it handle DDoS attacks. Some other options to handle the attack are using load balancers and using criteria to drop requests that are likely spurious, like ones coming from certain ip-address, or physical region, and at a much higher than baseline rate. </p>

	<h3>Data storage</h3>
	<p id="1618696016">Since the topic of  data storage is big enough, it is discussed separately under <a href="#1611200362" data-nav-id="1611200362">data storage</a> glossary.</p>
	
	<h3>Web application framework</h3>
	<p id="1617405655">See article about web application framework on <a href="https://en.wikipedia.org/wiki/Web_framework" target="_blank">Wikipedia</a>. A web framework, or web application framework, is a software framework that is designed to support the development of web applications including web services, web resources, and web APIs. These provide a standard way to build and deploy web applications on the world wide web, an most often automate these common activities. For example, many web frameworks provide libraries for database access, templating frameworks, and session management. In doing so, they often promote code reuse, standardize web application design and deployment process which makes it easier to find support and resources, and prevent spending developer time on common boilerplate code. An an example, Django is a popular framework when developing in Python language, and Spring is a popular framework for development in Java language.</p>
	
	<h3>Code repository</h3>
	<p id="1608564873">See article about code repository on <a href="https://en.wikipedia.org/wiki/Repository_(version_control)" target="_blank">Wikipedia</a>, <a href="https://bitbucket.org/product/code-repository" target="_blank">BitBucket</a> and in a <a href="https://huspi.com/blog-open/software-code-repositories" target="_blank">blog at HUSPI</a>. The simplest way is to think of it as a database for enterprise codebase. It should allow different team mebers to collaborate on the project and access different versions fo code as incremental changes are committed by team members. Particularly, note that the version control system can either be distributed (like, Git or Mercurial) or centralized (like, Subversion or CVS). Having worked on both, I personally prefer the distributed system.</p>
	
	<h3>Continuous Delivery (or, CD), and Continuous Integration (or, CI)</h3>
	<p id="1608565983">See article about continuous develivery on <a href="https://continuousdelivery.com/" target="_blank">ContinuousDelivery</a>, <a href="https://en.wikipedia.org/wiki/Continuous_delivery">Wikipedia</a> and <a href="https://aws.amazon.com/devops/continuous-delivery/" target="_blank">AWS</a>. For a team to provide continuous delivery of the web application, it must ensure that the code available in repository is always in a state where it can be deployed to the production environment without any issues. An important step needed to achieve this goal is to have the developers merge their code in same code repository and for the code to be free of conflicts or errors, i.e., have continuous integration . See article about continuous integration on <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank">Wikipedia</a>, <a href="https://www.atlassian.com/continuous-delivery/continuous-integration" target="_blank">Atlassian</a> and <a href="https://aws.amazon.com/devops/continuous-integration/" target="_blank">AWS</a>. Within the repository itself, sub-folders could be made to handle parallel development, merging features and identifying code for release. For example, using <a href="https://stackoverflow.com/questions/698313/what-is-trunk-branch-and-tag-in-subversion" target="_blank">trunk, branch and tag folders in subversion</a>, or using <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank">Git flow</a>, etc. Additionally, one must use some application that verifies on each commit that the newly added code does not break existing features and previous build. This is where <a href="https://www.jenkins.io/" target="_blank">Jenkins</a> may help by building full application with every commit of new code and verifying that the application builds and passes all tests. <a href="#1608660132" data-nav-id="1608344347">Static analysis</a>, mentioned in the testing glossary, also helps with the process.</p>
	
	<h3>Virtualization versus Containerization</h3>
	<p id="1608570000">For articles on virtualization, see <a href="https://en.wikipedia.org/wiki/Virtualization" target="_blank">Wikipedia</a>, <a href="https://www.vmware.com/solutions/virtualization.html" target="_blank">VMWare</a> and <a href="https://opensource.com/resources/virtualization" target="_blank">OpenSource</a>. To enable, full resource utilization, virtualization creates multiple copies of same/different OS on same hardware. As a side benefit, the system software and all installations can now be copied and easily moved to new hardware. Contrast this to containerization where different applications are deployed on a hardware having same OS, but in separate, independent "containers" that are isolated from each other. For articles on containeriation, see <a href="https://en.wikipedia.org/wiki/Containerization" target="_blank">Wikipedia</a>, <a href="https://www.docker.com/resources/what-container" target="_blank">Docker</a> and <a href="https://www.citrix.com/glossary/what-is-containerization.html" target="_blank">Citrix</a>. <a href="https://docs.docker.com/get-started/overview/" target="_blank">Docker</a> and <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" target="_blank">Kubernetes (which is a container manager)</a> are two common applications used in containerization. With the development in containerization, it has clawed off some of the functionalities that were previously done via virtualization. However, they both can be used in tandem. See <a href="https://www.burwood.com/blog-archive/containerization-vs-virtualization" target="_blank">one of the blogs</a> discussing the similarities an differences between the two.</p>
	
	<h3>System Monitoring</h3>
	<p id="1608572592">This can include a vast array of utilities to monitor system performance to identify if the servers are performing in an expected manner, i.e. expected levels of CPU usage, network usage, no memory leaks, etc. It can also include sending periodic healthcheck requests to different servers to identify if they are up. Common tools are Unix statsd, Graphite, Nagios, Datadog, etc. Monitoring memory usage helps identify if the code has memory leaks. Monitoring network activity is the one of the best way to identify the onset of <a href="#1612491901" data-nav-id="1608343369">DDoS attacks</a>.</p>
	
	<h4>SLO, SLI and Error budget</h4>
	<p id="1608575849">See articles on Atlassian about <a href="https://www.atlassian.com/incident-management/kpis/sla-vs-slo-vs-sli" target="_blank">SLO, SLI</a> and <a href="https://www.atlassian.com/incident-management/kpis/error-budget" target="_blank">Error budget</a>. These are performance indicators to identify if the business application (i.e. the service) is behaving in a manner expected for the business. Once the application makes it to production environment and is available to users, the service level objectives (SLOs) must be identified such that it mirrors business objectives. System monitoring tools can be used to obtain service level indicators (SLIs), i.e. the acual performance level for a service. The difference between SLI and SLO can be used to define error budget, i.e. how much error a service can take before it fails to meet the SLO. Depending on business requirement, there can be multiple SLOs. </p>
</article>
