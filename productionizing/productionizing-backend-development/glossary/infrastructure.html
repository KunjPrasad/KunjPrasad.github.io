<!--
    Productionizing Backend Development - Infrastructure glossary, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<title>Productionizing Backend Development - Infrastructure glossary</title>
		<meta name="description" content="Glossary for the book on Productionizing Backend Development containing concepts and terms related to infrastructure required to host the web application.">
		<meta name="author" content="Kunj Prasad">
	
		<!-- Meta with information that otherwise should have come in request headers -->
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Pragma" content="no-cache">
		<meta http-equiv="Cache-Control" content="no-cache">
		
		<!-- Browser related meta -->
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1">
		<meta http-equiv="X-UA-Compatible" content="IE=Edge">
		
		<!-- OpenGraph related meta -->
		<meta property="og:url" content="https://kunjprasad.github.io/productionizing/productionizing-backend-development/glossary/infrastructure.html">
		<meta property="og:site_name" content="Productionizing Backend Development book on Kunj Prasad's website">
		<!-- Not yet added image: <meta property="og:image" content="https://kunjprasad.github.io/assets/social_media_logo.png"> -->
		<meta property="og:title" content="Productionizing Backend Development - Infrastructure glossary">
		<meta property="og:description" content="Glossary for the book on Productionizing Backend Development containing concepts and terms related to infrastructure required to host the web application.">
		<meta property="og:locale" content="en_US">
		<meta property="og:type" content="article">
		<meta property="article:publisher" content="Kunj Prasad">
		<meta property="article:published_time" content="2022-01-24T00:00:00+00:00">
		<meta property="article:modified_time" content="2022-01-24T00:00:00+00:00">
		
		<link rel="stylesheet" href="/utilities/common-styles.css" type="text/css">
	</head>
	
	<body>
	
		<header>
			<h1>Infrastructure glossary</h1>
			<ol class="breadcrumb-container">
				<li><a href="/productionizing/productionizing-backend-development/">Home</a></li>
				<li><a href="/productionizing/productionizing-backend-development/glossary/">Glossary</a></li>
				<li>Infrastructure glossary</li>
			</ol>
		</header>
		
		<div id="note-status" class="note-status-sticky-header alert"><!-- The content here is filled dynamically by the script and gives information on notes, and file uploads, or unsaved changes --></div>
		
		<nav>
			<h2>Table of contents</h2>
			<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#server">Server</a></li>
				<li><a href="#cloud-computing">Cloud computing</a></li>
				<li><a href="#load-balancer">Load balancer</a></li>
				<li><a href="#cdn">Content delivery network, or CDN</a></li>
				<li><a href="#ddos">Denial of Service, or DoS attack</a></li>
				<li><a href="#data-storage">Data storage</a></li>
				<li><a href="#code-repository">Code repository</a></li>
				<li><a href="#ci-cd">Continuous Delivery (or, CD), and Continuous Integration (or, CI)</a></li>
				<li><a href="#virtualization-vs-containerization">Virtualization versus Containerization</a></li>
				<li><a href="#system-monitoring">System Monitoring</a><ul>
					<li><a href="#slo-sli-error-budget">SLO, SLI and Error budget</a></li>
				</ul></li>
			</ul>
		</nav>
		
		<main>
			<h2 id="introduction">Introduction</h2>
				<p id="1618695712">This page lists the various terms that relate to infrastructure and other applications needed to support the deployment and hosting of a web application. Since this book focuses on backend development, it may not use all of the terms. Nonetheless, it is important for a backend software developer to be aware of these terms and what they mean.</p>
				
			<h2 id="server">Server</h2>
				<p id="1608393835">See article about server on <a href="https://en.wikipedia.org/wiki/Server_(computing)" target="_blank" rel="noopener noreferrer">Wikipedia</a>. It is a combination of software and hardware that reads an incoming request and returns a response. The entity that sends a request to a server is called a "client", which is most likely either the web browser or some other software application making a server-to-server web request. A server listens for incoming client request on the server port and creates a dedicated connection between itself and the client, using client address and port (reference: <a href="https://unix.stackexchange.com/questions/75011/how-does-the-server-find-out-what-client-port-to-send-to" target="_blank" rel="noopener noreferrer">here</a>). This connection is available only to a specific client, and different connections are concurrently made for various client requests. When available, the server sends a response back to the client over the dedicated client connection. Server can be configured to forward any incoming request onto a "bundled" web application which is deployed on a server. This way, the application provides the business specific logic on how to handle the request, while the server just provides a common framework to handle incoming web request and outgoing web response.</p>
				
			<h2 id="cloud-computing">Cloud computing</h2>
				<p id="1608394258">See article about cloud computing on <a href="https://en.wikipedia.org/wiki/Cloud_computing" target="_blank" rel="noopener noreferrer">Wikipedia</a> and on <a href="https://azure.microsoft.com/en-us/overview/what-is-cloud-computing/#cloud-deployment-types" target="_blank" rel="noopener noreferrer">Microsoft Azure</a>. Cloud computing a relatively recent development where the cloud provider can "lease" out computers or any other hardware, or computers with an operating system and some pre-installed software, network capacity, etc. A business can now lease these resources, deploy the business-specific web application code over these servers and make it open for public use. The advantage of doing so is that the business is now free from the responsibility of buying, updating and maintaining the server hardware and software, or from starting a new server if some other server goes down. This "leasing" of resources is itself done over the internet, and so the business does not know, nor does it need to know, where the actual servers are physically located. This is why the resources are said to be "in the cloud". There are usually three models of cloud service that can be used: Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS). The key difference between these depend on how much of the resource management is being done by the business compared to how much is being done by the cloud provider (reference: <a href="https://www.bigcommerce.com/blog/saas-vs-paas-vs-iaas/" target="_blank" rel="noopener noreferrer">here</a>, <a href="https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://www.ibm.com/cloud/learn/iaas-paas-saas" target="_blank" rel="noopener noreferrer">here</a>). One way to get an idea of various cloud product that are available and can be used, checkout the cloud-based offering from AWS <a href="https://aws.amazon.com/products/" target="_blank" rel="noopener noreferrer">here</a></p>
				
			<h2 id="load-balancer">Load balancer</h2>
				<p id="1608395384">See article about load balancer on <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://www.citrix.com/glossary/load-balancing.html" target="_blank" rel="noopener noreferrer">Citrix</a> and <a href="https://www.nginx.com/resources/glossary/load-balancing/" target="_blank" rel="noopener noreferrer">Nginx</a>. A load balancer, simply put, balances load of incoming request to different backend servers. The main goal is to have each server get an uniform workload for request processing. This ensures optimal user experience by not having them wait simply becaue the request got routed to a busy server while another server is free. Different routing strategies can be configured to distribute load and to enable various response caching strategies suitable to business needs. Additionally, HTTPS termination can also be done at this layer before sending the request to server. It can also send periodic health checks to backing servers and remove routing traffic to inactive servers.</p>
				
			<h2 id="cdn">Content delivery network, or CDN</h2>
				<p id="1612493359">See articles about content delivery network, or CDN at <a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener noreferrer">Wikipedia</a> and <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/" target="_blank" rel="noopener noreferrer">CloudFlare</a>. A CDN is a geographically distributed network of servers and that serve static web resources (like, HTML files, style, javascript files, images, etc.) to geographically distributed end users. In doing so, it enables high availability of the data (i.e., ensuring data remains available even if certain servers beomes unavailable for whatever reason) and iimproves speed of fownloading the resource (because it is faster for users to download the content from a CDN server which is physically closer to the user). By offloading the task of serving static web resources which by definition do not change over time, or do so very infrequently, the servers hosting the business application free up additional capacity it can use to handle user request. For this reason, certain web application frameworks directly suggest using CDNs for serving static content, example, <a href="https://docs.djangoproject.com/en/3.1/howto/static-files/deployment/#serving-static-files-from-a-cloud-service-or-cdn" target="_blank" rel="noopener noreferrer">Django framework making the suggestion in its docs</a>.</p>

			<h2 id="ddos">Denial of Service, or DoS attack</h2>
				<p id="1612491901">See articles about Denial of Service or DoS attack at <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://www.comparitech.com/net-admin/dos-vs-ddos-attacks-differences-prevention/" target="_blank" rel="noopener noreferrer">this article</a> and at  <a href="https://aws.amazon.com/shield/ddos-attack-protection/" target="_blank" rel="noopener noreferrer">AWS</a>. A denial-of-service, or DoS attack is a cyber-attack in which the attacker seeks to make a web resource unavailable to its intended users by encumbering the server hosting the resource to such a degree that it is unable to respond to valid requests. It is typically accomplished by flooding the targeted machine or resource with superfluous requests in an attempt to overload systems and prevent some or all legitimate requests from being fulfilled. As an example, think of it like driving with a passenger who keeps asking "are we there yet?" - to which you, the driver, needs to respond. However, the passenger's intention is not to get the answer but to keep asking it so frequently that you cannot focus on driving, thereby causing you to stop driving. A distributed denial of service, or DDoS attack is when there are many such systems performing the attack which itself could have been initiated by a single entity. Since the requests in DDoS attack come from different ip-addresses, it is much harder to deal with it compared to DoS attack. Unlike other attacks that use weakness in code or user authentication/authorization (see <a href="/productionizing/productionizing-backend-development/glossary/security.html">security glossary</a>), the DoS or DDoS attack seeks to make the entire service unavailable for all users. Combating DDos attack is something that cannot be done within the web application and involves invest in infrastructure components to enable handling such attacks. For this reason, it is discussed under the infrastructure glossary. One way to handle the attack is using load balancers and using criteria to drop requests that are likely spurious, like ones coming from certain ip-address, or physical region, and at a much higher than baseline rate. Mitigation of DDoS attack is another service that are provided by <a href="#cloud-computing">cloud-based providers</a> or <a href="#cdn">CDNs</a>.</p>

			<h2 id="data-storage">Data storage</h2>
				<p id="1618696016">Since the topic of  data storage is big enough, it is discussed separately under the <a href="/productionizing/productionizing-backend-development/glossary/data-storage.html">data storage</a> glossary.</p>
				
			<h2 id="code-repository">Code repository</h2>
				<p id="1608564873">See article about code repository on <a href="https://en.wikipedia.org/wiki/Repository_(version_control)" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://bitbucket.org/product/code-repository" target="_blank" rel="noopener noreferrer">BitBucket</a> and in a <a href="https://huspi.com/blog-open/software-code-repositories" target="_blank" rel="noopener noreferrer">blog at HUSPI</a>. As a business evolves, the code for the business application will also change. The simplest way is to think of a code repository is as a database for enterprise codebase, such that every instance of a code change is versioned in chronological order. It promotes collaboration by enabling different team members to simultaneously retrieve the codebase, make updates to it, and then push the updates back to repository without undoing the changes made by other team members. Particularly, note that the version control system can either be distributed (like, Git or Mercurial) or centralized (like, Subversion or CVS). Having worked on both, I personally prefer the distributed system.</p>
					
			<h2 id="ci-cd">Continuous Delivery (or, CD), and Continuous Integration (or, CI)</h2>
				<p id="1608565983">See article about continuous develivery on <a href="https://continuousdelivery.com/" target="_blank" rel="noopener noreferrer">ContinuousDelivery</a>, <a href="https://en.wikipedia.org/wiki/Continuous_delivery">Wikipedia</a> and <a href="https://aws.amazon.com/devops/continuous-delivery/" target="_blank" rel="noopener noreferrer">AWS</a>. For a team to provide continuous delivery of the web application, it must ensure that the code available in repository is always in a state where it can be deployed to the production environment without any issues. An important step needed to achieve this goal is to have the developers merge their code in same code repository and for the code to be free of conflicts or errors, i.e., have continuous integration. See article about continuous integration on <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://www.atlassian.com/continuous-delivery/continuous-integration" target="_blank" rel="noopener noreferrer">Atlassian</a> and <a href="https://aws.amazon.com/devops/continuous-integration/" target="_blank" rel="noopener noreferrer">AWS</a>. Within the repository itself, sub-folders could be made to handle parallel development, merging features and identifying code for release. For example, using <a href="https://stackoverflow.com/questions/698313/what-is-trunk-branch-and-tag-in-subversion" target="_blank" rel="noopener noreferrer">trunk, branch and tag folders in subversion</a>, or using <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank" rel="noopener noreferrer">Git flow</a>, etc. Having automated tests helps in ensuring that the new code is free of unexpected issues and also does not break any existing behavior. <a href="https://www.jenkins.io/" target="_blank" rel="noopener noreferrer">Jenkins</a> can be used to build "artifacts" (like, bundled javascript code, or .war files, etc.) with every commit of new code, and verify that the build process works without any failure, and all automated tests pass successfully. Once an artifact is built, it can be deployed in server, from where it is made available for public use. <a href="/productionizing/productionizing-backend-development/glossary/testing.html#static-code-analysis">Static analysis</a>, mentioned in the testing glossary, also helps with the CI/CD process, ensuring that erroneous and non-standard new code does not make it to the main codebase.</p>
				
			<h2 id="virtualization-vs-containerization">Virtualization versus Containerization</h2>
				<p id="1608570000">For articles on virtualization, see <a href="https://en.wikipedia.org/wiki/Virtualization" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://www.vmware.com/solutions/virtualization.html" target="_blank" rel="noopener noreferrer">VMWare</a> and <a href="https://opensource.com/resources/virtualization" target="_blank" rel="noopener noreferrer">OpenSource</a>. To enable, full resource utilization, virtualization creates multiple copies of same/different OS on same hardware. As a side benefit, the system software and all installations can now be copied and easily moved to new hardware. Contrast this to containerization where different applications are deployed on a hardware having same OS, but in separate, independent "containers" that are isolated from each other. For articles on containeriation, see <a href="https://en.wikipedia.org/wiki/Containerization" target="_blank" rel="noopener noreferrer">Wikipedia</a>, <a href="https://www.docker.com/resources/what-container" target="_blank" rel="noopener noreferrer">Docker</a> and <a href="https://www.citrix.com/glossary/what-is-containerization.html" target="_blank" rel="noopener noreferrer">Citrix</a>. <a href="https://docs.docker.com/get-started/overview/" target="_blank" rel="noopener noreferrer">Docker</a> and <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" target="_blank" rel="noopener noreferrer">Kubernetes (which is a container manager)</a> are two common applications used in containerization. With the development in containerization, it has clawed off some of the functionalities that were previously done via virtualization. However, they both can be used in tandem. See <a href="https://www.burwood.com/blog-archive/containerization-vs-virtualization" target="_blank" rel="noopener noreferrer">one of the blogs</a> discussing the similarities an differences between the two.</p>
				
			<h2 id="system-monitoring">System Monitoring</h2>
				<p id="1608572592">In the <a href="/productionizing/productionizing-backend-development/glossary/housekeeping.html#healthcheck-monitoring">web application housekeeping glossary section on healthcheck monitoring</a>, it is mentioned that various healthcheck information can be collected for various resources used by the web application. This is an example of system monitoring, wherein a vast array of tools are instrumented / configured to monitor system performance. This helps to identify if the servers are performing in an expected manner, i.e. expected levels of CPU usage, network usage, no memory leaks, etc. Commonly used tools are Unix statsd, Graphite, Nagios, Datadog, etc. Monitoring memory usage helps identify if the code has memory leaks. Monitoring network activity is the one of the best way to identify the onset of <a href="#ddos">DDoS attacks</a>.</p>
				
				<h3 id="slo-sli-error-budget">SLO, SLI and Error budget</h3>
					<p id="1608575849">See articles on Atlassian about <a href="https://www.atlassian.com/incident-management/kpis/sla-vs-slo-vs-sli" target="_blank" rel="noopener noreferrer">SLO, SLI</a> and <a href="https://www.atlassian.com/incident-management/kpis/error-budget" target="_blank" rel="noopener noreferrer">Error budget</a>. These are performance indicators to identify if the business application (i.e. the service) is behaving in a manner expected for the business. Once the application makes it to production environment and is available to users, the service level objectives (SLOs) must be identified such that it mirrors business objectives. System monitoring tools can be used to obtain service level indicators (SLIs), i.e. the acual performance level for a service. The difference between SLI and SLO can be used to define error budget, i.e. how much error a service can take before it fails to meet the SLO. Depending on business requirement, there can be multiple SLOs.</p>
		</main>
		
		<footer></footer>
		
		<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
		<script type="module">
			import {onNonHomepageLoad} from "../scripts.js";
			$(document ).ready(onNonHomepageLoad);
		</script>
		
	</body>
	
</html>
