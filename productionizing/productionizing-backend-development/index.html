<!--
    HTML book: Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Productionizing Backend Development</title>
		<meta name="description" content="Productionizing Backend Development HTML E-book">
		<meta name="author" content="Kunj Prasad">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv='Pragma' content='no-cache'>
		<meta http-equiv='Cache-Control' content='no-cache'>
		<link rel="stylesheet" href="/utilities/styles-common.css" type="text/css">
		<link rel="stylesheet" href="styles.css" type="text/css">
		<style type="text/css"></style>
	</head>
	
	<body>
		<header>
			<h1>Productionizing Backend Development</h1>
		</header>
		<nav>
			<a id="1606665479" href="introduction.html">Introduction</a>
			<a id="1607048361" href="one-line-summary.html">One line summary</a>
			<a id="1606703843" href="personal-notes.html">Personal notes</a>
			<a id="1606665918" href="/utilities/disclaimer-generic.html">Disclaimer</a>
			<section>
				<h2>Glossary</h2>
				<a id="1608303678" href="glossary/req-resp.html">Request and response related terms</a>
				<a id="1608343369" href="glossary/security.html">Security related terms</a>
				<a id="1608344347" href="glossary/testing.html">Testing related terms</a>
				<a id="1608344358" href="glossary/housekeeping.html">Application housekeeping related terms</a>
				<a id="1608344368" href="glossary/infrastructure.html">Infrastructure related terms</a>
				<a id="1608344385" href="glossary/architecture.html">Architecture related terms</a>
			</section>
			<section>
				<h2>1-way interaction</h2>
				<a id="1609385770" href="one-way/introduction.html">Introduction</a>
				<a id="1609472905" href="one-way/entity.html">Entity</a>
				<a id="1609472910" href="one-way/dto.html">Data transfer object (DTO)</a>
				<a id="1609472915" href="one-way/controller.html">Controller</a>
				<a id="1609472920" href="one-way/service.html">Service</a>
				<a id="1609472930" href="one-way/repository.html">Repository</a>
				<a id="1609472935" href="one-way/filter.html">Filter</a>
				<a id="1609472940" href="one-way/renderer.html">Renderer</a>
				<a id="1609472945" href="one-way/exception-handler.html">Exception handler</a>
				<a id="1609472950" href="one-way/user-auth-auth.html">User auth/auth</a>
				<a id="1609472955" href="one-way/feature-flag.html">Feature flag</a>
				<a id="1609472960" href="one-way/req-attributes.html">Custom request attributes</a>
				<a id="1609385771" href="one-way/additional-terms.html">Additional terms</a>
			</section>
			<section>
				<h2>2-way interactions</h2>
				<a id="1609474984" href="two-way/transaction.html">Transaction</a>
			</section>
			
			
			
			<!-- TODO
			Make separate glossary for storage. Link it in infrastructure, saying it has been separated. Include SSD, memory, disk storage . Cache as a smart map; in-memory, distributed or on fast disk... Add network latency in infra glossary.. same rack is faster for network
			
			//GLOSSARY
			
			Testing
			-- negative tests; proper naming; arrange-act-assert
			-- testing as means of documentation -- and matching iwth requirements (functional) - so keep it as small possible to individual "requirement" level. Give proper name. Arrange, act, assert. 
			--Easier to check bugs
			
			
			Monitoring: -- in housekeeping
			-- LIGHTSTEP - DISTRIBUTED TRACING:  **DOn't give actual implementation since you didn't write it
-- OpenTracing API
-- Defines "Span" : smallest unit of distributed trace
-- OpenTracing defines how to collect Span
-- LightStep is a provider that allows for collecting Spans
-- OpenCensus made by Google, now joined with OpenTracing to form OpenTelemetry (datadog style metrics along with openTracing)
-- can also run locally in developer mode and see the queries being made, and time taken
-- tracing does not depend on language being used.. as long as everyone uses openTracing, then everyone gets the span trace, even for 3rd party library

			
			WRITING COMMENTS: -- in housekeeping
-- When in doubt search for google style guide on comment for that language.
-- Remember "comment maintenance" is also a burden that cannot be done by compiler - and takes team-time. So try to balance it
-- Maybe start by writing comment at top of file about what it does.
-- When writing comments, always start at top-most level "code-item", like Component (in JS) and Classes (in Python). This should be most general, and being highest in level, it should be more "declarative" in nature than imperative, i.e. highlight more on what/why rather than how. 
-- Then, go to specific functions "..which are exported" and write comments about their behavior. Include more description - but stick to what/why rather than how
-- Only inside code, if you are adding comment, then it's likely to be to explain something. BUT.. before doing so, consider the following:
--|----- Maybe change magic number by aptly named constant. Thus won't need to add comment
--|----- A good place for comment in if you feel that the function has stages/chunks but you don't want to make the code unnecessarily small by pre-emptively breaking it
			-- Related: Give proper variable name, don't skimp!!
			
			
			-- Maintain read only replica for speed
			
			
			Security
			-- Security based on hidden variable name alone isn't security
			-- Add other security issues. mention content security policy. Add ModHeader and add response header
			
			--|---- Login CSRF
			
			--|---- Don't rely on cookie only for security. Use CSRFToken, or JWT. Using both is overkill. JWT does make you cloud ready
			
			-- Look for notes in spring security, like changing session after login, clearing session on logout, adding x-content-type-options: nosniff. 
			-- See https://blog.avast.com/why-is-ebay-port-scanning-my-computer-avast and https://nullsweep.com/why-is-this-website-port-scanning-me/ -- don't port scan. If you want to do so for security, then offer as a service and start/stop it when user asks. Don't do so in a hidden cryptic way
			
			-- Security - chpt 26 of 2 scoops - go through it
			--|---- Basic thing for security:: see "Server Hardening", section 26.2 in pg.346 of 2 scoops:: Server hardening measures include but are not limited to things like setting up firewalls (help.ubuntu.com/community/UFW), changing your SSH port, and disabling/removing unnecessary services.
			--|---- **VERY VERY VERY IMPORTANT**: Good practice -- You should disable the HTML field autocomplete browser feature on fields that are gateways to payment. This includes credit card numbers, CVVs, PINs, credit card dates, etc. The reason is that a lot of people use public computers or their personal computers in public venues. In fact, consider changing the form field itself to PasswordInput. Also on that line - never store credit card data.
			--|---- Section 26.13 on Pg.357 about file handling. 
			--|----|---- Use CDN for file (I think this is more of a performance thing and to prevent getting your server drowned in false request).
			--|----|---- Since user uploaded file can have xss content, so don't have it open in browser by only allowing it to be downloaded - done by setting "content-disposition:attachment"
			
			--|---- **VERY VERY VERY IMPORTANT**: If working with custom user data which can be xml.. then realize that there can be a ddos attack done. See https://en.wikipedia.org/wiki/Billion_laughs_attack -- the article mentions that this attack can be done on any language with references (like, on YAML)
			--|---- 
			
			
			-- sql injection
			-- Avoid inernal XSS. This comment is written earlier also::  If your DTO fields, path param, etc. has constrainst, like can be a-z,A-Z,0-9,_, then also realize these constraints in the field definition. DOn't just take any arbitrary string. Take only the ones expected. This can be useful in preventing internal xss, i.e., say as part of your logic, you are logging these field values, etc. - and then are running some daily background task, possibly to collect some metric. Since these are external user data - you shouldn't be trusting it.. and some user may try to pass in a script that inadvertantly gets run. This is internal XSS. The point is - don't trust any data comingf rom out till you've verified it. Similar also holds for fields containing html text from user.. Best would be to just get markup (and define an enum type column which highlights that the entry being read is of markup type, not html).. but if you do need to store html, then escape it as you form the request body itself. Also note that this promotes reusability, setting standards in project.
			
			
			
			
			
			database:
			ACID, CAP
			normalization / denormalization
			Optimistic vs Pessimistic Locking
			
			
			
			Cover these 3 points, and link to prod-prod
			Rule of 3 to identify refactor (link to glossary/architecture.html)
			-- Foolish consistency is hogoblin (link to introduction.html)
			-- if needed, go for speed, and cover tech debt later. Business first (link to introduction.html, glossary/architecture.html)
			
			
			
			Discuss code arrangement based on above -- in infrastructue code repo (**maybe make 1way entry for it.. and add an interaction to arrange code keeping all contextually relevant pieces in 1 folder.. keep context priority of code-type, like all service, or all controller at one place)
			-- differentiate between view utilities vs just utilities; any method requiring handle to request should be related to view and nothing else. Even though serializer deals with request body, the view should create a context for it and pass related arguments. Don't have the serializer directly call request or read from it
			-- differentiate between global utils vs package level utils
			-- positioning of constants
			--|---- One thing that can be placed in global scale constants file (and not constants defined in each sub module) is if the project is importing a 3rd party library, and the utilities in it use some string formats, etc. Since the import applies globally, so it comes to be that any constants being defined for use therein must also be global. Best is to start by defining things locally, and then move them to global if it gets reused at different places - to have a DAG structure. This does require extra work in being agile to refactor.. but is good practice as it keeps context in understanding what a constant does and in what scope is it used.
			-- Inheritance vs composition
			-- abstraction vs encapsulation: DIfferent for python, JS vs for java
			-- long file vs short file
			
			-- include documentation and scripts folder
			
			-- If you are having different project that can talk with each other.. then make sure that can also be done in local. It can be needed later on to be able to have this feature.
			
			Utility class/methods : mention they are defined if they are used at multiple places (maybe keep it in code arrangement). Also that there can be different utility for different controller / service / repo
			
			-- put common functionality in abstract classes.. Mixins..
			
			-- Advanced case: Producer vs consumer
			--|---- In designing/coding - and particularly regarding models, REALIZE that the difference between producer and consumer mindset is and important difference to identify. When you are coding as producer, you want your codebase to be as compliant to SOLID, it'll be open for expansion, but different functionalities will be in different files and you'll have more "distributed" codebase. the drawback, maybe you may one change, but forget to make related change elsewhere because by design concept -- everything is open - so a change at one place doesn't/shouldn't affect other places. When coding as consumer, you purposefully accept that code won't go to someone else and you have full control over its consumption and API structure. You can add efficiency with this mindset. But this affects code resiliency. Most common, you'll run into import loops and/or will want to move some code to utils.. which brings up question of why not do that since beginning. STILL.. even in consumer mindset, remember to not break DAG!! -- things are easily factored as long as both app, module, sub-module level dag is not broken.. particularly removing order of __init__.py
			--|---- This is probably biggest design contention when you are producing and using the codebase in your application. The tensions come up because a group is both producer and consumer - so both viewpoints are correct. However, traditional viewpoints of quickness, efficiency, related features at one place because you're the only one so why proliferate code -- come up and may blindside the efforts. Do realize it comes with a future cost in that there can be future issues.. so do keep that in mind - particularly if in scrum workflow. Again, nothing that can't be changed - but it'll need extra time/money. Personally, having a producer mindset is better because it keeps development open towards future changes, but it causes a distributed code.
			--|---- **Thinking about producer vs consumer mindset is a good way to reason about having abstract classes in each project and then have them implemented in your project's home app. This way, the definitions in each sub-app gives a basic skeleton.. that you modify as necessary when adding it in home-app
			--|---- one aspect is whether they should contain method to define nonDB-related ASPECT-LOGIC (like fields that should be logged), field based object-access, or whether that logic should be in some other class. Having things are one place bloats model, makes model definition dependant on context (which is something that may be good if you are end consumer -- as it keeps all related code at one place and low chance of missing things, but not a provider), also you may get forced to scenarios that don't respect DAG!
			--|---- Thinking along lines of differences between producer and consumer mindset is also a good way to think whether the model should be kept as much POJO and related methods to moved to separate utility class, or if related methods be added inside the model itself. Former is a producer mindset and latter is a consumer mindset. The disadvantage of latter is that now, classes that lie higher up in DAG precedence can be made to have functions that apply on classes that come lower in DAG precedence. Then, it moves to having those special methods in separate utility.. then it becomes why not just put everything there.. or maybe DAG relation was previously not very defined, but it gets so at later time, and now the chain is broken.
			--|---- Where should validation lie when dealing with discrete valued "status" type fields in model-vs-serializer -- see above comment!!
			--|---- From above, it seems that producer should only give basic pojo classes. Actually, differentiation between the two depends on the amount of functionality you want to add. If you give max freedom of extension, then you won't be able to add function, or will give something too fragmented. A good trade-off is to give an interface and some sort of basic implementation.
			
			
			
			
			-- don't indiscriminately use cookies. Add security: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Security   ;  Note that GDPR applies to them - so be careful and considerate in storing them: https://gdpr.eu/cookies/
			
			
			-- SANITIZE calls : PII should delete data, not relations.
			
			
			

			
			
			
			
			//ONE WAY -- INTRODUCTION
			
			https://stackoverflow.com/questions/38677889/difference-between-service-layer-and-controller-in-practice/38678061#38678061 -- Looking in Java view of controller, service, repository... controller holds interaction with request; service has business logic and no request based logic; repsitory has database logic and only interacts with service. Best to do everything in one transaction -- even the conversion from slugs into corresponding entity.
			--|---- For this reason, process serializers in Django should not do anything with child slug.. if you are using SlugRelated field, then keep it as read-only, or create-new.. don't modify. On flip side, if you are worried about the entity changing in span of request.. then best you are pessimistic locking and not rely on just using single transaction.
			
			
			
			
	
			
			
			mvc - a 3-way interaction.. but idealy should be more.. but mvc squashes dto and entity. And controller squashes service and repo.
			
			
			-- Advanced case: DAG structure for ManyToMany field: DTO, Entity, url, create/update/delete: what happens first and what follows
			-- Advanced case: multi-representation of same data: Resume as text and pdf; DTP, model, url, create/update/delete
			-- Using "If-Modified-Since". Should it bubble, i.e. when a child is changed, then also its parent entity is also updated (This also relates to keeping auditlog entry)? - I'd say no. This means that when showing a DTO, one should NOT show childDTO because that then breaks the meaning of parentDTO being non-modified. A workaround could be to simply return url where one can get childDTO
			--|---- This is a good argument on why a REST GET url should only returns resource and no parent/child DTO. returning any extra information mixes the update time for two and so, is like a caching strategy. Best, and always, add cache depending on your use case and not preliminarily. This also sets up a guideline in that your GET call should end up asking for a resource and only that resource (not parent/child) should be returned
			
			
			
			

			
			
			
			
			//ADVANCED UTILITIES
			
			LOG CONTROL
			-- single place to control what all is logged.. to have logs in standard format. To remove sensitive data
			
			
			HATEOAS + SWAGGER!!:
			
			-- By OPTIONS spec "The response payload, if any, might also describe the communication options in a machine or human-readable representation.  A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP.  A server MUST generate a Content-Length field with a value of "0" if no payload body is to be sent in the response."
			--|---- note the "Location" response header should be used to provide information about created resource. HATEOAS gives information on other things that can be done with the resource - and is business dependent logic. Maybe if all you are doing is returning some links then that can be done viaresponse headers instead.. but using HATEOAS also allows customizing and sending text data back to further guide user's decision. Also, firewall may remove non-standard headers, so having details in request body is better
			
			-- Make it role based
			
			1) In Hateoas links, apart from internationalization 
---- also give security detail : who all will be accessing the data. Is there any restriction on mutating data, etc. Maybe just give link to security policy
---- a question is if you can guide users into using your webpage/REST-url in suitable flow. Maybe each URL within each level can be numbered so that users are guided. For some who have already done part of work.. they can skip those portions and get to next step. Maybe give guidance on how a user can identify which step they should start with.. say by doing successive GET calls.

			2) If a field/fields can take enumerated value only, then give all possible combination.. or url to get combination possibility, along with what they mean. This helps user understand enum values which are not in their language. Maybe give different enum-options based on the language selected by user?!! and/or add a translator at beginning so that the json data is translated to one understood by server.. even though it starts from one that is understood by server
			
			-- HATEOAS or swagger, or both?! See https://stackoverflow.com/questions/54839672/difference-between-swagger-hateoas  
			--|---- If using Swagger, also set custom headers, authentication.. and also add unit tests to verify that swagger spec getting generated has expected values
			--|---- Since HATEOAS is REST version of a UI, try to return only as much related content as allowed for a role
			--|---- Don't show HATEOAS text on error, you might end up causing leaks if user is not allowed to see the text. The error message should be descriptive enough. Not sure though.. maybe there's better process. Like, can point to homepage or a support page.
			
			-- For Swagger: when reading model field description -- best if the plugin being used can do by reading DB comment. This keep DB field comment as only source of truth when defining field definition text.
			
			-- At a later stage... consider internationalizing your error response and your HATEOAS!! Maybe swagger also!
			
			-- The use of field in DTO to control validation application for error vs warning level validation can be explained in HATEOAS
			
			
			
			Governor service
			
			
			
			
			
			
			
			-->
		</nav>
		<main tabindex="0"></main>
		<footer></footer>
		<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
		<script type="module">
			import { onUploadNoteFileChange, onDownloadNoteFile, onDocumentLoad } from './scripts.js';
			$(document ).ready(onDocumentLoad);
			$("main").on("change", "#note-file-upload-input", (event) => onUploadNoteFileChange(event.target.files[0]));
			$("main").on("click", "#note-file-download-button", onDownloadNoteFile);
		</script>
	</body>
<html>