<!--
    HTML book section: Service in 1-way interaction to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<aside class="shown-individually-but-hidden-in-ebook"><i><strong>Read it in ebook <a href="/productionizing/productionizing-backend-development/#1609472920">here</a></strong></i></aside>
	<h2>Service</h2>
	<p id="">Acknowledge that the terminology is Java focused - it means portions of code wth business logic. Couples to controller and repository only. may couple to other service methods.
	
	<!--
	This is where business logic starts. Do business dependent validation.
	service code must be as much declarative in nature. 
	Retry logic: -- Making a unified client; Ambassador pattern -- should this be in repo? This keeps service declarative and retry becomes the imperative logic.
	
	
	Relate to 1610226800 in glossary/architecture -- generally methods should have Command-query separation. But service can do multiple things. In fact, it might be needed to trigger side-effect and return data, like in all non-GET calls
	
	
	See http://web.archive.org/web/20120827100207/http://www.cbare.org/writing/Transactions/transactions.html -- mentioned in db-storage glossary. At end, it has "Tips for writing efficient transactions" which include "avoid performing slow operations like user input in a transaction", and generally "reduce time spent holding locks"
	
	Transaction is one request long, due to http being stateless and each request being independent
	
	One transaction per service. because service is representation of work asked for in a request; Controller is web to code matching and back - so it should not have transaction
	
	2way:
	dto and service: do validation first and fail fast. 
	
	
	2way: service+security
	-- doing any file processing in different server with stricter security
	
	
	2way service+test
	-- create mock for 3rd party api and background tasks and integration test it
	
	
	3way: service + transaction (2way)
	Handle one type of DB or file or MQ call per service. This allows having @transaction. For file / MQ processing, the corresponding service shouldn't have @transaction
	--|----|---- Above is an example of interaction with multiple data store. In such cases, always have a background sync / clenup process. Also design your code to be able to do so. Use Transactional outbox pattern.. or if your code is in initial or non-complex stages, then just a logging with a periodic check might also suffice.
	
	In recent times, with the emphasis on <a href="#1609350800" data-nav-id="1608344385">microservice</a> structure, it is preferred to process distributed transactions using asynchronous using <a href="https://microservices.io/patterns/data/transactional-outbox.html" target="_blank">transactional outbox pattern</a> rather than using <a href="https://en.wikipedia.org/wiki/X/Open_XA" target="_blank">XA</a> manager.
	
	-->
	</p>
</article>
