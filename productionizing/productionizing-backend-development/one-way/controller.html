<!--
    HTML book section: Controller in 1-way interaction to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Controller</h2>
	<p id="1618888639">The interaction between a user and a web application through HTTP(S) requests is the core requirement for having a web business. At the server, a "request" object is a programmatic representation of all details sent by the user and contains information like the <a href="#1608993702" data-nav-id="1608303678">request url</a>, <a href="#1609041974" data-nav-id="1608303678">request body</a>, <a href="#1609038553" data-nav-id="1608303678">request headers</a>, etc (Reference: <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html" target="_blank" rel="noopener noreferrer">HttpServletRequest object in Java</a>). Eventually, this request should cause some business processing to occur at the server and the result of the processing returned to the user. A controller is defined as the code component that accepts as input the request sent by user, and causes a suitable business processing to occur. Modern web application development frameworks simplify this step a lot by providing boiler-plate code to handle a generic web request made to the business application. The frameworks leaves it to the developer to add application-specific codes and details, like, mapping request url and request method to a business processing method that gets executed when user sends a request to the url, and, converting request body to an object that is provided to the business processing method as an input, etc. In this ebook, the discussion on "controller" does NOT cover the boiler-plate code provided by the frameworks. Readers are asked to refer to the documentation for the framework to understand that code. It is only the application-specific coding that is covered in the discussion on "controller". Even among those, the topic of converting request body to an object is covered separately in a <a href="#1609472910" data-nav-id="1609472910">later chapter</a> because there can be multiple considerations to keep in mind during the process.</p>
	
	<nav class="article-toc">
		<h3>Table of contents</h3>
		<ul>
			<li><a href="#" data-nav-id="1609472915"></a></li>
			<li><a href="#" data-nav-id="1609472915"></a></li>
			<li><a href="#" data-nav-id="1609472915"></a></li>
			<li><a href="#" data-nav-id="1609472915"></a></li>
		</ul>
	</nav>
	
	<h3>When outside "controller", do NOT "request"</h3>
	<p id="1619283137">Once the server receives a user request, it is generally processed in a single thread. Most web frameworks store the "request" object as a thread-local object (Reference: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html" target="_blank" rel="noopener noreferrer">Thread-local in Java</a>) and provides utility method to access the "request" object from anywhere in the code. However, it is strongly suggested to not code in a manner that requires access to the "request" object outside the controller object. This is suggested because doing so creates a "separation of responsibility" between the controller code which is responsible for translating details in a "request" object to ones that can be used for business processing. In future, if it becomes necessary to allow similar features be accessible over other protocols like <a href="#1608922555" data-nav-id="1608303678">remote method invocation (RMI)</a>, then it will only be needed to add a new controller-like layer for the protocol, and the core business logic won't need to be changed. Needing to access the "request" object as part of the business processing is a sure-shot indication that the controller method is not properly coded. A <a href="#1612275370" data-nav-id="1612275370">later chapter</a> covers another use case where a thread-local helper object is used rather than using the request object outside the controller code.</p>
	
	<h3>RESTful URL design</h3>
	<p id="1619285670">This section covers considerations that should be kept in mind when designing the URLs for business application that gets handled by controller. <a href="#1608927383" data-nav-id="1608303678">REST</a> design principles suggest that the <a href="#1608993702" data-nav-id="1608303678">URL(s)</a> for the web application must be constructed in a manner that someone with no knowledge about the business web application and the URL(s) supported by it, is able to discover the URL of interest to them. A good example of seeing such a design in action is a filesystem, consisting of folders (or directories) and files or subfolders within the directory. To access a file in a filesystem, a user can start at the top-most level directory, i.e. the root directory, and iterate down different folders till the desired file is found. At each level, the user is presented with a list of options, i.e. files and folders, that they can interact with. Having a pre-existing knowledge of the folder structure in the filesystem is not a pre-requisite for the user to interact with the filesystem. Ideally, when properly designed, a RESTful architecture should promote similar interaction. A user should be able to start their with the web application, starting from the root URL, and working their way up to the desired URL.</p>
	<p id="1619287660">Consider the question: In the example of windows filesystem, how does a user know that they can click on a file and press "Shift + Delete" to permanently delete that file. One answer is: the user knows it because it is a standard operation. The corollary to this answer in a web application is the use of appropriate <a href="#1609036000" data-nav-id="1608303678">request method</a> with a url to perform a desired operation. This is covered in more details <a href="#1619288257" data-nav-id="1609472915">later</a>. Another possible option is that when a user clicks on a file, then, in addition to the file content, they are also provided the information that pressing "Shift + Delete" will permanently delete that file. The corollary to this answer in a web application is the use of <a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener noreferrer">HATEOAS</a> design constraint. Use of HATEOAS is covered in more details in a <a href="#1619285636" data-nav-id="1612275350">later chapter</a>. Using the example of filesystem or otherwise, the sub-sections below discuss additional insights on the design of web application URL(s).</p>
	
	<h4>Example web application URL(s)</h4>
	<p id="1619295280">Let's use the two requirements identified in a previous chapter (<a href="#1612650690" data-nav-id="1612649521">here</a> and <a href="#1613439952" data-nav-id="1612649521">here</a> to identify a set of URL(s) that the banking web application may have. Subsequent sub-sections can use this list for further discussions. For now, let's assume that a login and logout function exists and that those endpoint are outside the scope of discussion. There can be an endpoint through which the user can see and modify their information, an endpoint through which they can see their bank account information but cannot modify it, an endpoint through which they can see their insurance information and enroll or unenroll from it, an endpoint to see their account transactions, and finally an endpoint to create new message, see their past messages and corresponding response.</p>
	
	<h4>Shallow vs nested URL</h4>
	<p id="1619285987">For the use case mentioned <a href="#1619295280" data-nav-id="1609472915">above</a>, let's say there is a url <code>GET /users/{userSlug}</code>though which user can see their information. Side-note: For now, we're not discussing whether the use of <code>GET /users/{userSlug}</code> is proper given that each user will have a unique userSlug. Side-note #2: recall from <a href="#1613946647" data-nav-id="1609472905">previous discussion</a> about entity that a "slug" value should be used to retrieve data from the server. Coming back to the discussion, what should be the url for a user to view their bank account details. One option is to design the url as <code>GET /users/{userSlug}/bankAccounts/{bankAccountSlug}</code>. Another option is to design the url as <code>GET /bankAccounts/{bankAccountSlug}</code>. Former design is what's referred as the nested URL pattern (I am not sure if that is an industry standard name, but it seems to be apt) because the URL to access the sub-resources is formed by extending the parent resource URL. The latter design is called shallow URL pattern because the URL to access any resource is formed by extending the root URL by only one time.</p>
	
	<h5>Benefits of shallow URL design</h5>
	<p id="1619365342">So which is a better design to use - shallow or nested URL? One feature of nested URL is that the parent child relation between two entities are clearly defined. This means that a <code>User</code> entry gets made first and the <code>BankAccount</code> entry gets made after. The downside is that these relations can constrain some use cases. For example, if an administrative staff at the bank wants to get a list all bank-accounts with negative balance, then it is not possible to do so because the staff does not know about the userSlug, and even if they did, then making calls one-by-one for every user is plain cumbersome! For this case, it would have been useful to instead have a shallow URL like <code>GET /bankAccounts</code> to get a list of all bank-account that can then be filtered to returned relevant data. A quick fix is to make both URLs, i.e., <code>GET /users/{userSlug}/bankAccounts</code> and <code>GET /bankAccounts</code>, and wire-in the former URL such that its invocation redirects to the latter URL with a query parameter, like, <code>GET /bankAccounts?users=userSlug</code>. This allows performing simple queries where user for a bankAccount is defined, and also performing complex queries for bankAccounts.</p>
	<p id="1624631630">Another positive for using the shallow URL design is that nested URL design can get too long. For example, the nested design based URL to get a transaction entry for a bank account will be <code>GET /users/{userSlug}/bankAccounts/{bankAccountSlug}/transactions/{transactionSlug}</code>. If you want to get the message for the transaction, then add another <code>/messages/{messageSlug}</code> at the end of it, and it just makes the already long url even longer! And what if the use case is to retrieve all messages for three specific users corresponding to 4 specific transactions? Such cases require using matrix parameters in the url path which aren't without issues themselves and not widely supported (reference: <a href="https://www.w3.org/DesignIssues/MatrixURIs.html" target="_blank" rel="noopener noreferrer">W3</a>, <a href="https://stackoverflow.com/questions/2048121/url-matrix-parameters-vs-query-parameters" target="_blank" rel="noopener noreferrer">StackOverflow</a>). Using shallow URL design means that there will never be more than 1 path parameter. Hence, it precludes the need for matrix parameters. Note that it is dscussed <a href="#1624630839" data-nav-id="1609472915">later</a> that business related details must not be sent in request header and so, using request headers is not a proper alternative to matrix parameters.Consider another use case where it is needed to get all messages for a user. Then, an intuitive URL to use might be <code>GET /users/{userSlug}/messages</code>, which starts with the shallow URL and goes at most one level further.</p>
	
	<h5>Downsides of shallow URL design</h5>
	<p id="1619368662">In addition to advantages, there are some downsides of using the shallow URL design. One downside is that there is a loss of contextual information binding the various nested URLs. In the example about bank accounts, using a shallow url design causes a loss of contextual information that a <code>BankAccount</code> is only formed after a <code>User</code> entry is made. Having a <code>GET /bankAccounts</code> directly under the root context may inadvertently imply that a <code>BankAccount</code> entry can be made without having a <code>User</code> entry. Even when using the shallow URL design, there would be an expectation to provide an URL like <code>GET /users/{userSlug}/bankAccounts</code> so that someone can retrive list of slugs associated with the bank accounts for a user (Why return only a list of account slugs? See it in a <a href="#1624554408" data-nav-id="1616383834">later chapter</a>), and then use <code>GET /bankAccounts/{bankAccountSlug}</code> to get the account information. Hence, one must now consider that using shallow URLs reduce the total number of RESTful URLs associated with the business application.</p>
	<p id="1624477449">Another downside is that a shallow URL pollutes the HATEOAS response (briefly mentioned <a href="#1619287660" data-nav-id="1609472915">above</a>). For a shallow URL design, when someone pulls the HATEOAS response from the root context, they'll get the information that there are 2 child URLs that can be used: <code>GET /users</code> and <code>GET /bankAccounts</code>. However, if the nested URL design were used, then they'll get the information that there is only 1 child URL than can be used: <code>GET /users</code>. When they access HATEOAS information for <code>GET /users</code>, then they get information about <code>GET /users/{userSlug}/bankAccounts</code> URL. Doing so prevents prevents overwhelming users by providing them a whole lot of information up front, and instead only providing information piece-meal on how they can interact with the system. A corollary filesystem related example is structuring files within hierarchically ordered directories rather than adding all files inside the top level folder. Both design allows storing and retrieving files, but the former structure enables having some context associated with each file based on which they are grouped together. It also overwhelms the user to search for relevant file in a giant list of files.</p>
	
	<h5>You don't just "Redirect" a "POST"</h5>
	<p id="1619570758">In a <a href="#1619365342" data-nav-id="1609472915">previous section</a>, it is suggested as a design option to have two URLs like <code>GET /users/{userSlug}/bankAccounts</code> and <code>GET /bankAccounts?users=userSlug</code>, and where the former redirects to latter. Doing so allows one to start with the former nested URL design and then at a later time, switch over to the latter shallow URL design. However, it should be realized that the simplicity of this suggestion is because it is done for GET calls. POST requests can be much more difficult to redirect. Referring to the <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener noreferrer">Internet Engineering Task Force (IETF) Request for Comments (RFC) 2616</a>, a browser must not change the request method on redirect, but it is observed to not be the case! The status code of 307 Temporary Move status code was added to make it expressly clear that the same request method must be used. Even so, redirecting POST requests doesn't seemless works like it does for GET request. When redirecting a POST call, the browser is expected to alert the user and present an option to proceed or to cancel without reposting data to the new location. This doesn't make for a good user experience continuously having to tell the browser that it is ok to proceed! Even worse, it can make some users suspicious if there's any security flaws in  the application. Since POST, PUT, PATCH, DELETE request cannot be easily redirected, so this rekindles the discussion on whether a proper URL design is to have it shallow or to have it nested (Reference: <a href="https://www.itprotoday.com/server-virtualization/redirecting-post-requests" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://stackoverflow.com/questions/2604530/a-good-way-to-redirect-with-a-post-request" target="_blank" rel="noopener noreferrer">here</a>). That being said, most modern webpages perform server calls using jQuery or similar javascript library and the website can be coded to automatically handle redirects without showing any message to the user.</p>
	
	<h5>Summary on nested vs shallow URL design</h5>
	<p id="1624476002">Based on above discussion, is there a clear winner between whether nested or shallow URL design is superior? Unfortunately, the answer is No. Both designs have corresponding pros and cons, and the one that closely meets the business requirement should be used. I would suggest using the shallow URL design if possible because it precludes the need for matrix parameters and also keeps open the possibility to accommodate future use cases, although at cost of cluttering the HATEOAS associated with the root url. Herein lies the main understanding of the issue: In RESTful design, the most important design aspect is to maintain discoverability of the URLs. The most important concern is that a user must have means to identify the URL and the data they should send when making a request. Whether this is achieved via deep or shallow URL is simply a minor side-discussion. Since dicoverability of API is related to how good the endpoints are documented, so, further discussions are covered in the <a href="#1612275350" data-nav-id="1612275350">chapter on API documentation</a>.</p>
	
	<h4>Collection URL and single resource URL</h4>
	<p id="1619288885">One way to divide the RESTful URLs into two classes is based on whether the URL acts on the collection of resource or on a single resource. For example, corresponding to <code>User</code> resource, the two URLs can be: <code>/users</code> which acts on the collection of <code>User</code> resources, or, it can be <code>/users/{userSlug}</code> which acts on a single <code>User</code>resource.</p>
	<ul id="1624479332">Following are some points to note regarding the collection and single resource URL:
		<li>It is common knowledge, but just mentioning for completeness of discussion: When creating a new resource, then </code>POST {collection-url}</code> should be used because the intention is to act on the colection of resources by adding a new entry in it.</li>
		<li>For every single resource URL, these must be a collection URL. For example, you cannot have <code>/users/{userSlug}</code> endpoint without having a <code>/users</code>. This is because a <code>GET {collection-url}</code> provides list of resource slugs enabling the end user to then request for information corresponding to a single resource by calling <code>GET {single-resource-url}</code> and providing the resource slug in the URL. Another reason is that if the collection-url were absent, then the end user would not be able to discover the single-resource-url! On the flip side, it need not be necessary for every {collection-url} to also have a {single-resource-url}. One example is if the resource being served are static resources that are managed by some database personnel, and the end user is only allowed to read the resource entries, and there are very few such entries. In this case, an end-user may never choose to invoke the single-resource-url and work only based on response from the collection-url. That being said, it is a good practice to always provide a single-resource-url for every collection-url, even if they both would be used with GET calls only.</li>
		<li>On calling the <code>GET {collection-url}</code> endpoint, it will return list of resources. If the resource list can get unbounded over time, then consider adding a filter to subselect data from the database and return a bound list. Filter details can be added to the collection-url using <a href="#1609008266" data-nav-id="1608303678">query parameter(s)</a>. For example, if the collection url corresponds to retrieving information on all files made by all users, then such a request is expected to return an unbounded list of response. In such cases, it is preferable to add filters, like returning files belonging to one/many user(s), and/or made on particular date(s). The main goal for having filters is to improve overall performance by reducing the burden on database (by reducing the amount of rows queried), application server (by reducing the amount of data it has to read from database and send to user) and on user (by reducing the amount of data they need to go through to get desired result). However, this requirement can initially be relaxed during the initial stages of business when there isn't enough data to query or to send back to user. One special case of filtering is to "paginate" the complete response where only a small portion of the complete response is returned at a time. Since pagination is a big topic, so it is discussed separately in a <a href="#1624549699" data-nav-id="1619574603">later section</a>.</li>
		<li>Consider the example when a user calls a collection-url to retrieve a list of files uploaded by them, but they want to only know about the most recent file made. For such use cases where a filter accepts a collection of resources but only returns one or no resources, then it is suggested to provide this filter functionality via a separate endpoint nested within the collection url. In this example, if the user calls <code>GET /files</code> to get information about the files created by them, then it is suggested to provide a <code>/files/latest</code> URL such that calling <code>GET /files/latest</code> retrieves information about the latest file made by them.</li>
		<li>It is strongly suggested to only use <a href="#1609008266" data-nav-id="1608303678">query parameter(s)</a> when making a GET call on a collection-url. For non-GET calls, like POST, PUT, PATCH and DELETE, one must only read relevant data from the url path and from the request body, and not use query parameters because doing so has negative security implications as dicussed <a href="#1624564932" data-nav-id="1619574610">later</a>. This leaves 2 cases corresponding to making a GET call using a collection-url or a single-resource-url. Since a <code>GET {single-resource-url}</code> call can only return zero or one resource details in response, using a query parameter is almost useless because the end user may as well make a <code>GET {single-resource-url}</code> call without the query parameter, retrieve the data from server and check whether the boolean check being effected by the query parameter applies on the data or not. Hence, from a practical standpoint, the use of query parameters is sensible only when making a GET call with collection-url.</li>
	</ul>
	
	<h4>Path parameter vs query parameter vs request header</h4>
	<p id="1624563686">When making a request to the application server, user input can be send either as one or more of path parameters, query parameters or request headers. Consider an example where a bank administrative personnel wants to get all disputed transactions on a user's credit card account and wants the information in JSON format. The personnel can make a call like <code>GET /users/{userSlug}/bankAccounts/creditCard/transactions?isDisputed=true</code> and also provide a request header of <code>Accept: application/json</code> to tell the application server that they want the response in JSON format. In this example the "userSlug" is the <a href="#1609007236" data-nav-id="1608303678">path parameter</a>, "isDisputed" is the <a href="#1609008266" data-nav-id="1608303678">query parameter</a> and "Accept" is a <a href="#1609038553" data-nav-id="1608303678">request header</a> key.</p>
	<p id="1624630839">As mentioned <a href="#1624479332" data-nav-id="1609472915">above</a>, the query parameters should only be used with <code>GET {collection-url}</code> calls. Any other information that would eventually make into business logic, or database query should be present in the url path or in the request body. It is suggested to use request headers only for authentication purpose, or to provide metadata about the request and response, and it should NOT be used to send any data that gets used in the business logic. The primary reason for doing so is that the HTTP standards set this behavior for request and response headers (see <a href="#1609038553" data-nav-id="1608303678">previous section</a>). Another benefit is that it enables users to bookmark a URL and revisit it, or to share application URLs with each other without worrying that the call will fail due to absence of request headers needed by the application.</p>
	
	<h4>An endpoint for custom action</h4>
	<p id="1624633641">RESTful architecture works great when working within the basic use case of CRUD operations on a resource, i.e., creating, reading, updating and deleting a resource, which maps to HTTP POST, GET, PUT and DELETE calls. However, there may be various business requirements that don't fit into this basic case. For example, in a banking application, a user may want to transfer money from one account to another, which requires simulatneously reducing balance in one account and adding it in another account. The closest it matches to it with a PATCH call, but not even so because the operation of transferring money involves two accounts and not just one. In this e-book, such request are referred as "actions" or "custom actions"; Since RESTful URL invocations can be seen as an action done on the server, so the word "custom" is added to emphasize that these are different from the former. They can be considered as equivalent of <a href="#1608922545" data-nav-id="1608303678">RPC</a> call in a RESTful framework where some complex business method is run on the remote server that does not fit in the mold of a CRUD operation.</p>
	<p id="1624924668">Custom action endpoints can either be added to collection-url or single-resource-url (These terms are defined in a <a href="#1619288885" data-nav-id="1609472915">previous section</a>). Since the most-common use case for custom action URL is that its invocation causes an irreversible change in the data, so these URL(s) are generally associated with a POST call. It is also suggested to define separate custom action endpoints for different user actions, even if those actions end up acting on the same database table. For example, let's say that a user can create a message identifying a fraudulent charge, or they can create a message giving feedback on customer service. Since fraud reporting is a more critical operation, so an alert is also created for someone in fraud department to immediately hanle the issue. One may implement both these feature via the same custom action endpoint, adding in a condition that when a fraud report message is sent by user, then additional followup logic is invoked. While it accomplishes the desired task, such a design makes it hard to identify how many fraud-report calls are made compared to feedback calls, because both the calls will use same url. Also, maybe in future it might be needed to take additional steps, like locking the card, etc. Hence, what may start of as a simple logic can end up having exteremely complex and branched logic in future. One more advantage is that it is more comforting for the end-user to see that a fraud-reporting action is getting handled by an endpoint that seems custom designed to do so, rather than by an endpoint that is same as one used for collecting feedback. Therefore, it is suggested to define separate custom action endpoints for different user actions even if those actions end up acting on the same database table. This also falls in line with the Interface segragation in <a href="#1609301770" data-nav-id="1608344385">SOLID</a> principles.</p>
	
	<h4>URL versioning</h4>
	<p id="1619373122"></p>
	<!--
	--|---- See https://stackoverflow.com/questions/389169/best-practices-for-api-versioning -- for URL versioning
	
	the reason to not have urls like /v1/resource is that then home context, i.e. http://server/ is expected to return values v1, v2, etc.. which is absurd. When hitting home endpoint, it is logically better to return list of resources available from the business, and so the next expected url is htttp://server/resource . But is you've started with resource, best practice is to follow it up with "id", giving http://server/resource/{id} . One way to think of version is that this url is a collection os methods and you want to execute a particular method. Hence, this single-id url becomes a list type.. and so you should add a query para. In addition to being weird, this becomes even more confusing for actual lits type urls.. because then oe of query param is for version.. but not others. If you use header.. that seems to work, is restful - in sense if we consider different versions to have equivalent logic (see later section on response about how request header should just change data format but not response data). for example, just returning data with different format, but returning same data. This is generally not true and versions can be non compatabile. In this case, we want version to be explicitly there in url.. so that if the url is shared, then the ersion is identified ..unlike just using request header where version is hidden in request header, and so if someone reruns the url, they may forget to give speciic version. so we want version in url, but above shows that resource should be the one to follow server in url path. Here's the thing.. for the people / API / organiations that are so particular about versioning and backward incompatibility, chances are they are already know what resources are possible. In this case, add version at front.. so that copies for resource/{id} can be added in path. If you're worries about discoverability, then from http://server, link to http://server/resource which always points to most recent version and has hateoas links to different historical versions with corresponding information on how the do processing. Once again, over here, a totally new user will access versioned url only after knowing about unversioned url.. understanding the resource endpoint from there and then being able to see other historical versions
	-->
	
	<h4>Using proper request method</h4>
	<p id="1619288257"></p>
	<!--
	-- This is also briefly mentioned above in #1619287660
	
	-- say patch and options are not yet considered.. check to see if they are mentioned in 2way or 3way topics. PATCH should only be preferred if one or up to all fields can be overwritten in same request.. and there is no context information based on processing status
	
	-- stick to http spec of keeping GET as a safe method, and of having PUT, GET, DELETE as idempotent. See here: https://developer.mozilla.org/en-US/docs/Glossary/idempotent -- For this reason, never make "delete last entry" as a delete call because it is not idempotent. If it can change, then instead use POST and model it as a RPC call -- done via POSTING of a message that is then picked up and processed
	
	-- How about. get data for some latest "id". If you use GET, system can cache
	-->
	
	<h4>Be Level-2 mature</h4>
	<p id=""></p>
	
	<h3>Request header best practices</h3>
	<!-- Accept, content-type (include encoding)-->
	
	<h3>Response header best practices</h3>
	<p id=""><!--Maybe call this section "response" and describe response related things.. like that response should depend on url and request method.. "communicated" response data content should not change based on request header -- as also said above in versioning --></p>
	
	<!--
	-- Understand and use the http-cache directive, particularly for subset of url serving static data (like those from standard table) ..maybe a better place would be to add in glossary under cahing
	
	-- Add basic security response headers:: https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/headers.html
	Configure Content security policy
	Configure allowed hosts is possible
	--|---- Before deleting it.. at least check if it is mentioned in the security glossary
	--|---- Sidenote: is there a multi-way item for discussion about CORS and security when API is of client provider
	
	"Location" response header
	-->
	
	
	
	<!--
	
	See https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/ -- can it be useful
	
	Includes URL also
	

	Or maybe this should be a 2-way interaction concern You need a validated DTO before sending to service. The problem is coming in whether validation should be as part of DTO construction or otherwise. Since validation being done are as part of field definition, it can be done as part of constructor.. but not sure if that'll raise error in proper way. The framework may require a specific way.. so that makes it a 2-way interaction. ~~> Concern: only do request level appropriate validation, like, if you were expecting list, did you get it or get string. Did you get generic string or only containing a-z,A-Z,0-9, etc. NOTE: Only do validations related to field definitions and no relation with underlying business process or entity involved. Like, you can say that an integer value holding hours of day must be between 0-23 only. But don't assert that it is between 9am-5pm, etc. Can still do multi field validation only if the current form is transformable to new form in which constraints apply. For example, let's say you are collecting start and end time. Other way to represent it could be start time and duration. since duration less than 0 does not make sense, so one can think of having start time less than end time as constraint. But, no business specific ones.. like the difference between two must be certain period, etc.
	
	controller should be even less code, just validating data and passing to service.
	
	
	
	
	
	
	
	
	
	-- This is best done in 2way(user + service): Doing so assigns validations specifically to service, regardless of how it came.. whether in DTO, or URL, or query param. Service gets all objects are "independent" params.. and it starts by first validating DTO, then by validating relations. This gives 404 or 400. 401 and 403 now comes from 2way (user + controller) only - so whether a url is accessible or not! This adds consistency. Maybe, best do it as 3way: user+controller+service
	------- This is what the quote was for above [[This will bring up discussion on handling permissions (exploding validation), and raising proper response status. Is that ok? When to discuss response status -- use header "success is easy, failure is not" -- discuss 400 vs 401 vs 403 vs 404 vs others.. prevent information leak]]
	
	
	
	
	
	2way: controlle+entity
	-- See one-way/controller/#1619285987 -- top level domains will always go directly under root. If something matches one-one with the top-level domain, that can also be made to go under root directly. 
	
	--|---- Let's say you are dealing with a child resource under a parent resource. There are 2 ways to proceed in terms of URL:
			Option-1: "/root/parent/{parentSlug}" and "/root/parent/{parentSlug}/child/{childSlug}", or,
			Option-2: "root/parent/{parentSlug}" and "/root/child/{childSlug}".
			When to use one vs another vs maybe-both:
			--|----|---- First, remember to be flexible.. the decision you come to is very dependent on your application needs. Both cases hold their own merit.
			--|----|---- One difference is that when creating new child, first option will call "POST /root/parent/{parentSlug}/child" and second will call "POST /root/child". First must read parentSlug from url and not from request body, and second must read {parentSlug} from request body since none is available in url. If using 2nd, don't pass a filter-param to pass parentSlug.
			--|----|---- first option is suited if you will only query for a child after having gotten the parent and so you want to keep a referential integrity. Second is lax on that.. an attacker only needs to know the childSlug to get the resource. Note that this concern only holds during GET call. For POST, PUT, PATCH, and even DELETE, you can require a request-body with parentSlug in it.
			--|----|---- If using 2nd option, you can query for child resource from multiple parent resource at once, like, "GET /root/child?parent=slug1,slug2,slug3" (but can also use matrix params)
			--|---- If getting a child resource must always come with some implicit understanding of parentSlug, then Option-2 is better. Like, get child-resources for most-recent/active parent resource. Then "GET /root/child" would work but not first option until the parent slug is obtained via separate query. THAT BEING SAID.. even for second option, use something like "GET /root/child?parent=active" -- This leaves "GET /root/child" as idempotent in that it gives all child resources. The "parent=active" filter now says to get only most active parent. This way, different filters can be made for different use case. Maybe.. define your HATEOAS response to show different url based on different role!!!
	
			
	
	2way: controller + exception handler
	--|---- Ref checks and failures. Consider: GET /root/grandResource/{grandId}/parentResource/{parentId}/childResource/{childId}
			--|----|---- Without the final {childId} and if it's a GET call, then return 404 because the url should not exist. What about instead returning 200 with empty list.. I think it's not very REST like, because if reference checks failed, say, between {grandId} and {parentId}, then how did the list type url for child even get formed? It like saying "GET /root/grandResource/{grandId}/parentResource/{parentId}" is 404, but "GET /root/grandResource/{grandId}/parentResource/{parentId}/childResource" is 200 with empty list?!
			--|----|---- Without the {childId} and if it's a POST call, then, return a 404 if reference check fail in url. Note how this matches with above: Now, it won't even be the case that "GET /root/grandResource/{grandId}/parentResource/{parentId}/childResource" gives 200 with empty list but "POST /root/grandResource/{grandId}/parentResource/{parentId}/childResource" gives 404!!
			--|----|----|---- If reference check fails in the request object, then corresponding field should raise error and there be a 400 status.
			--|----|---- With the {childId} and if it's a GET, PUT, PATCH, DELETE call, then return empty list on reference check fail and 404 status
	

			-- be careful not to leak status by error: Say you got "GET /root/a/{aId}/b" for some other criteria given in header or query param, and there's no match. A good answer could be to return [] with 200 status, saying - we don't want to tell you whether you're breaking any relation or not.. but hey, ythere's nothing matching. Similarly, "GET /root/a/{aId}/b/{bId} now returns 404". What if you do "POST /root/a/{aId}/b" and some header value or query param, but those don't hold reference relation with {aId}.. do you give 404? - can't because if you turn POST to GET, then resource exists and is [].. we just did above. Maybe you do a 400 saying that some value is not available - and rule become that anything 404 type in POST request gets returned with 400 instead. What if both reference relation don't hold and you don't have permission because you belong to {a2Id} not {aId}.. if the service instead returns just verifies your role but not your relation with {aId} as missing and you give some different error, then you leak information of relation. The thing to realize: First authenticate and authorize user, then check validity of url (or raise 404), then check relation between all other user/header data and url and raise 404 again (not 401 or 403) because other data provide additional context around user and so must be verified to form full "definition" of "user". Finally now, go to other status like 400, etc.
			--|---- Expanding further on above:consider url like: /root/a/{aId}
			--|----|---- realize that in sense of usage, the user would have done the following sequence of operations: /root, /root/a, /root/a/{aId}, /root/a/{aId}/b, /root/a/{aId}/b/{bId}. 
			--|----|---- /root wouldbe open to all users since it gives general info. 
			--|----|---- /root/a?{queryParams} - can also be opened to all users because there is no user and url link (..because there is no path param yet). It should return 200 with empty list if there's no data, or no data after filter, or user is not permitted any data.
			--|----|---- /root/a/{aId} (..and always without queryParams) - if it returns 404 for missing data, and 403 if user does not have relation with data, then it leaks info about existence of {aId} to the user. So, best is to return 403 or 401 on initial user validation, and then always return 404 either if {aId} does not exist, or {aId} exists but user does not have relation to it - to prevent leakig the existence of data. THIS IS TEH REASON why above it is suggested to just raise 401/403 for the first time, and then never raise it again, and just raise 404
			--|----|---- What about slugs received in process-serializer as part of request body? With same logic, that should always raise 400 error saying that the corresponding slug is not found. Do't say anything about not having permissions, etc.
			--|---- Consider the case of user adding a phone number. The user is verified (i.e. has email and logged via password), but the phone number is not verified. When user gives a phone number, either it is available (i.e. noone else has mentioned it) and user verifies it via 2fa code. BUT.. consider if there's an overlap where someone else has also mentioned same phoen number. Also, 2 more cases - other person has verified it, or other person has not verified it. when the user gives phone number - should they be told that there's a conflict? Correct answer is "No" - here, the user hasn't verified new number as belonging to them, so ideally it should never get any sort of communication back from the service. In essence, we are still expanding the verification domain.. and phone number is still not verified -- so it should not receive any commuication back! Should other people have given same phone number, should we tell them there's a conflict - Yes! - but only if the previous user has a verified phone number. If the previous user also has an unverified phone number, then don't send any message of "conflict". This gives an example of validating in an "exploding data domain" manner to ensure consistent response/sttus is sent so that any information is not leaked by failure.	
			--|---|---- Related: consider a username/password login system. If username does not exist, or username exists but pasword is wrong, then do you show different messages? - or different status. Many actually do.. but realize that this is a wrong thing todo - because this is authentication step and unless it is successful, you don't know who is the one making request. So, regardless of fact that this errors are coming in post message / form, the only error you return is "username not found or wrong password". You never show the difference between 2 cases above. If you are a system that shows a blank user photo on first login or if username not found.. then that's also wrong. Ideally you should be returning any random photo. This is to prevent information leak.
			
			
			
			
	2way: controller + user-auth:
	--|---- For users with a higher level of authorization use a more nested url. For another subset of user with a hierarchical less set of permission, maybe some values become implicit in context and so can be skipped - give them smaller url. One may say to just make url suited to lower hierarchy user and then add filter for higher hierarchy user.. but then, what guarantees that in future an even lower hierarchy won't come. Or, when just making higher-user, maybe you didn't think that a lower order user will come, so the full path REST structure would have looked good. There's also the idea of YAGNI. Why have filter params just with consideration of future low hierarchy user even when though they don't exist now. **EVEN MORE**: I would say that one should think of filter params as only when it is possible to have an array of values that can get passed to queryParam. If you have a queryParam that can always only take 1 value.. then it may be good to instead have it in path. ALSO NOTE: In terms of architecture, queryParams means you are doing filtering - so there is no parent-child relation.. which could be if there is a strong "sibling" relation. That means one cannot nicely form parent-child classifications and so should pull all data in and then filter...and then to enable hierarchical structure - instead have your views/controller logic route from one to other and setting values based on user-role for sub-user, or from query-param for super-user.. as you go from one view to another
	
	
	
	2way: controller + user
	-- consider the example of user login.. they send username and password. For security, this is done via a POST call so that the password is not displayed. Contrast with with the case where you have some user data stored in the database and now you want to do search over email. For this filtering, you use query-param. here's the question: does doing the filtering over a PII field via query-param constitute a leak of PII.. because now people can see the query-param, so it can identify details about user in the system. The answer is no!
	--|---- Why "No": Understand what PII is.. it is an information that user gave about themselves for safe keeping. It is a leak of PII, if the system now sends out PII to someone not deserving. However, when someone does a query, then the email being searched in the query param is not something the the system is leaking out without authorization. Instead, it is a data that is coming in the system. Any user can give any query param to a request (even if the application does not require it) - so having an email in the query param search text is not PII leak. The consequence of his understanding is that: (1) when doing GET list call, always return a status=200, even if no entries were found. Don't give different status, else it is a data leak that a particular email pattern exists or does not exist; (2) When doing GET call for single resource, then DO NOT also give any query param - because now the particular resource can be related one to one with the query param, and that can make a future leak even worse; (3) When doing POST or PUT or PATCH call, then only accept entries from the request body and never use any values coming from query param - because if you do so, then you've created/updated resource using query params, and by doing so, you turned them from being just some value to PII because now they relate to the user data.
	--|---- From above.. note that there is one more way in which data can leak: If a 404 not found is raised for some resource, then that's generally done very quickly compared to returning 200 status that involves extra processing. Also, the response length is less for non-2xx status compared to others. If you really want to cut down this correlation, then add following behavior: for non-2xx status, identify the average and stdev of how slow 2xx status responses are compared to non-2xx status. Then add a random delay rather than returning request quickly. Similarly, when returning 4xx status, add random response headers just to bulk up the response. Same for returning pagination result.. If you are returning less than the page size, then pad with response headers to make the response look of same size. Now, if someone just looks at packet size and time to respond, they'll not be able to infer the status from it. 
	--|----|---- Maybe pick it up in Advanced topic -- specially for time portion. Using together with (a) adding an annotation for avg/stdev of timing defined at controller level, (b) capture the time when request came -- set by a filter in threadlocal.. and the time when exception is raised add extra delay to make the timing seem similar for 2xx vs non-2xx status
	--|---- What if you want to consider something corollary to: general talk is free and open to all, but top secret talk is restricted. Any so, if there is sensitive query involved, you turn it to POST. The answer: If you really want to contain talk, then use separate servers, do data encryption, take care of what gets logged an purge it, etc.
	--|---- Consider a question.. you have 2 RBAC roles: one of them (admin) is allowed to search for all email, other (worker) is allowed to search for email in only a smaller subdomain. How should the application behave if a worker user tries to search for other emails outside the smaller subdomain allowed to them. (1) Don't return a 403: Return 403 ONLY if all paths of that type are disallowed to the user, and not if certain ones are disallowed because they shouldn't be able to access it. This is done to prevent leaking data due to different status -- it's either a straight 403 or mix of 200 and 404. If a processing is being stopped because the user is not allowed to proceed just for that input - then instead return 404 (for GET request), or 400 (for fields inside a POST / PUT request); (2) Other option is to just make a separate endpoint that by definition searches only over the subdomain. Don't give worker users a right to use that endpoint and not the generic one. For this case now.. if the worker still uses generic search endpoint - returning 403 is valid
	--|---- Somehow a related question that doesn't seem related: Should url(s) be designed with hierarchy.. like: GET /parent/{pid}/child/{cid}, or should it always be single depth: like GET /parent/{pid} and GET /child/{cid} (no mention of "pid" here.. not even in query param). Here's the discussion: If a nested path is used, like GET /parent/{pid}/child/{cid}, then, (a) the application will always be burdened to check that "cid" is related to "pid" before returning resource, (b) If {pid} is absent or {cid} is not inside {pid}, then 404 is returned (not a bad thing, but it'll be used..), (c) When doing POST call.. it creates a dichotomy where all other values are read from request body, but {pid} is read from url, (d) We discussed above to never leak PII in url. This is not a PII leak, but its till leaks out that {cid} is related to {pid}. One place where this makes sense is for url design where {cid} is "count" or some enumeration of child within that parent. However, this goes against the idea of having totally independent primary key or slug! Using just a single depth url does the following: (i) does not burden the application with trying to maintain relation between parent and child. Considering that {cid} itself is hard to guess "slug" field, just having one value is good enough. Plus, authentication, authorization, filtering based on user related fields will also be there in application -- those aren't precluded by using single depth url -- and they can still keep out unwanted access, (ii) If {pid} is absent, or there are some rules on whether {pid} should be returned to user that don't allow - then 404 is returned -- so this behavior remains same, (iii) When doing POST call, only the values from request body is read, (iv) The relation between {pid} and {cid} is not leaked. For example, the single depth url can now be used all many places.. and now when, via some other route, {cid} value comes back but is not authorized, then the codebase deals with it!!! The absence of relation also means that BI leak of relation between parent and child entity is not leaked. The url structure becomes flat -- not sure if that's good or bad. One good thing.. the url can be seen as breaking in standard form of "/{root}/{module}/{entityName}/{entityId}"... this is also good from HATEOAS viewpoint
	
	
	
	
	
	-- when dealing with any inputs that relate to user.. don't do a GET call revealing user details in the url, prefer to do a POST instead. For example, commonly, it is known to send username and password during login via POST request.. but what about doing some GET list type of call and filtering by user first name, or last name, or email.. these are PII, and best to not reveal them in url. In such cases too.. do a POST call to send user PII / sensitive data, even if what you want to do is a filtering call that might be more suited via a GET call and query params! CONTINUING ON IT.. if there are related calls/features, then they should also become POST. For example, maybe search should be done with POST because a sensitive data field is-being, or, has-potential-of-being searched over. What about links to different page results.. the call for paged results would also become POST because each call also sends the search field query. DO NOTE that unlike sending pagination data in response header.. DO NOT send page number being queried in request header -- because a change in page number changes the request and totally changes response. So, it should be part of url.. just that the search query should not be part of url.
	
	
	2way controller+dto:
	-- Model serializer vs process serializer. Even process serializer can be model state change (can be via patch) or a big process combining multiple models with child->parent DTO rather than parent->child structure. Also cover general validation requirements
	-- Always return same DTO for POST, PUT, PATCH, GET call
	-- don't return anything after delete
	
	-- Ideally you should have same serializer class for POST, PUT, PATCH call (DELETE may not use serializer because instance data is deleted.. and since data is deleted, there's no use of returning a json, because there isn't any data to populate it!) -- this hooks on eing able to return same json for all calls.. improving ability to bypass using "If-Modified-Since"
	
	2way service+dto
	-- Let's say you are grouping result by column A,B.. The basic ORM will give result as [{col-A, col-B, count-AB},...] list, but let's say you want answer in form of {col-A: [{col-B, count-AB},...], ...} dict - then rather than changing ORM select sttement.. best change the utility that converts from ORM query result to DTO
	
	2way: 
	-- feature flag based service validation
	
	2way dto+controller
	-- for POST return slug after creation
	-- read slug for PUT, PATCH, DELETE from url only and not from request body. Require slug value to match expected behavior (like, a-z,A-Z,0-9,_) is so is needed in business
	
	2way controller+dto (for file)
	Unless you are sure about the file being returned, use Content-disposition:attachment to trigger download rather than opening as html and triggering script runs. 
	
	3way: 
	-- feaure flag + role based validation
	
	3way: exeption-handling + service + dto: If request body is of list type, then, when sending error, send it against the corresponding list index. This allows matching error with corresponding list entry that triggered it. This can either happen at dto level itself when request body is being converted.. or at service validation, or model level validation. Regardless of where/how it happens, if it a 400 level response - a validation error, then format it properly
	
	-->
	
	<aside class="shown-individually-but-hidden-in-ebook"><i><strong>Read this article, and more, in ebook <a href="/productionizing/productionizing-backend-development/#1609472915">here</a>.</strong></i></aside>
</article>
