<!--
    HTML book section: Entity in 1-way interaction to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<aside class="shown-individually-but-hidden-in-ebook"><i><strong>Read it in ebook <a href="/productionizing/productionizing-backend-development/#1609472905">here</a></strong></i></aside>
	<h2>Entity</h2>
	<p id="1610064998">As mentioned in the <a href="#1611510000" data-nav-id="1611200362">schema section</a> of the data storage glossary, the initial steps in database design involves creating the conceptual design, followed by logical design. Techniques from domain driven design and database normalization is applied in doing so. In current software landscape, it is very likely that an <a href="#1609290898" data-nav-id="1608344385">object-oriented paradigm</a> is used for the development of backend code for the business application. In this paradigm, the database tables in the logical design maps to a class, and a row in the table maps to an object of corresponding class. This object is called as an Entity or a Model (also see <a href="https://stackoverflow.com/questions/2550197/whats-the-difference-between-entity-and-class" target="_blank">this question on StackOverflow</a>). The mapping between an entity and a database table row, allowing an object to be saved as a row, and for a row to be read and converted to an object is achieved through use of software called an <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" target="_blank">object-relational mapping tool, or an ORM</a>.  When working on a backend application, it is strongly preferred to use a database and framework with ORM support. Fortunately, this support is already available in commonly used frameworks. <strong>For purpose of this ebook, it is assumed that the backend application is developed using a programming language and a framework that provides ORM support.</strong></p>
	<p id="1610065800">A quick side note: Database froms an important part of backend development. Database related concerns are covered in more depth in a separate ebook: <a href="/productionizing/productionizing-database-schema" target="_blank">Productionizing Database Schema</a>. Readers are suggested to refer it as needed. The topics covered in this book are not dependent on conent of "Productionizing Database Schema" e-book. So, readers can refer it after finishing this e-book.</p>
	
	<h3>Using domain driven design</h3>
	<p id="1612753728">As mentioned in the <a href="#1611510000" data-nav-id="1611200362">schema section</a>, domain driven design is applied when forming the conceptual model. In context of the <a href="#1612649521" data-nav-id="1612649521">example application</a>, particularly the "<a href="#1612650690" data-nav-id="1612649521">Requirements - Part I</a>" section, realize that a "user" is central to all applications. This is a top-level domain. One sub-domain for the application is banking service, like, creating an account, depositing or withdrawing money from the account. Another sub-domain is optional life-insurance service. Under the banking service sub-domain, an individual account detail entry in the database table for user accounts will never use the information about user's insurance. On the other hand, under the life-insurance service sub-domain, an individual insurance entry in the database table for user insurance will never use the information about user's account balance or what transactions they made. <strong>Domain driven design suggests that the database tables and corresponding entities made to for an application domain are bounded to that context alone (see <a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank">Bounded context</a>) and must not get shared with other domains.</strong> When designing the entities, this means that "bank account" entity must not directly have insurance details in one of its columns, nor should it have a foreign key to entry in the insurance table; And same consideration also applies for the insurance table.</p>
	
	
	
	Normalization
	-- example of failing normalization: If the filepath also contains filename.. even though there's a separate filename column
	<!--
	data denormalization: statistics.. when speed is needed, or when doing
reporting. That's why reporting is generally kept separate from data
modeling, done separately (housekeeping). This can show up in sprint
like behavior, causing your db to have both the entries.


	DB: generally, when you have foreign key relation, you want to save it
from deletion, or cascade delete or set it to null. However,
if-and-only-if you're storing some auditing / reporting value that you
want to save even when original entry is deleted.. then don't have
foreign key relation.. and just store the value. Realize that doing so
can also help table make a column "multifunctional", i.e. the "id"
value stored in a column refers to "id" of different table depending
on value in some other column. Once again.. if-and-only-if, this saved
data must exist even after original data in some table is deleted..
then only do both above, else, have strong foreign key relation - or
risk having inconsistent data that now needs to be programmatically
normalized.

When in agile process.. can any aspect of normalization be done later? I'd say focus of getting 1NF, 3NF, 5NF form because they make relations more explicit and prevent it from being hidden. 2NF, 4NF are useful to split one table in two, but that can also be done at a later stage as you application evolves
	-->
	
	Use table and field level comment
	
	field name suffix
	
	DB constraints: failure of unique constraint cannot be checked anywhere in the code without running in race conditions and is done first by DB only
	
	field value constraint / validation : programmatically
	-- always start with as strong constraint possible; weaken it only if needed later. Don't weaken it at early stage
	-- say it's if constraint is defined by core requirements otherwise not possible in sql; referential checks
	-- updatable = false
	-- html escaping/unescaping should be under dto.. not model's responsibility!! TODO - add in dto. However.. controlling list of accept tags (it should have accept list of tags rather than deny list) is model responsibility
	-- clean vs save
	<!--
	Use blank still, not null -- check with business requriements though. This does not extend to all fields that are string valued, for example, don't use empty datetime field instead of null.. because empty datetime field is an ill-formatted entry. 
	--|----|---- This further related to: As much possible, add default value to a field if applicable. For example, you're making a campaign and want to count people contacted ~~> default=0! Maybe having "null" indicates that campain has been setup but not started.. but doing so is now indicative of even worse thing.. using a field for more than 1 purpose, i.e. if it's null, then campaign hasn't started. But if it is non-null, it has started, and can have value=0 or 1.. Why not just have a separate status column to identify the status. What if in future, you start a campaign, but want to rollback or pause for some time.. you'll reset it to null and lose data?
	
	-- DateTime field, always in UTC. Save timezone as needed - in separate field in data model. Also identify if timezone captured in one domain applies to other tables
	-->
	
	custom field getter / setter - allows for encryption
	-- custom getter:  If a model has fields that override value of a preceeding model, then define custom getter such that it reads the overriden value if available, else read the original value.
	
	keep separate id
	<!--
	-- Why hiding db id is good
* https://stackoverflow.com/questions/396164/exposing-database-ids-security-risk -- best answer, it is a business intelligence security risk!
* https://stackoverflow.com/questions/9904396/is-it-a-bad-practice-to-expose-db-internal-ids-in-urls
			-- Above says to only use Slugs in url. OK - consider when you have a foreign key relation. Now, Since slugs are unique.. do you make a "Foreign key" relation using "id" or using "slug"?
			--|---- I'd say this is where having some understanding of what a "slug" is - would be helpful. See https://stackoverflow.com/questions/427102/what-is-a-slug-in-django -- which shows how slug can be a nifty url line. Now, one could think that, say, if you're writing comments on a post of a given "slug", you'll talk about it as comment on post "about that slug". So, from users perspective, the relation should use slug. This also matches the "idea" that "id" field is just an internal representation and "slug" is what user sees - so slug is what keeps "relations" between data! However, from DB/service perspective, you now have a choice - either you say that (a) you do a foreign key on slug, and return slug. The advantage: when returning slug foreign key, you won't have to do another query.. that value is already in the table. HOWEVER.. if you're looking from the perspective where slugs can become long text so that they look nice in url, then "indexing" over long string can get problematic, and it can be much faster to make foreign key relations using "id", have foreign key index made using "integer" valued id - and then join on it. In such cases, doing a foreign key on "id" is much more beneficial. There is an intermediary case, say, when you have tables with many foreign keys - in this case, even though an integer index lookup is fast, there may be many such lookups needed and that'll slow things down. 
			--|---- A RELATED HUGE ADVANTAGE: Now you can use slug for foreign key. This way, when a query is made on child table, you can return parent's slug back without doing a join query, because child table already has it. Furthermore, if you delve back into actual rationale behind having a slug (https://stackoverflow.com/questions/427102/what-is-a-slug-in-django) - you'll notice that "slug" is supposed to provide context to a resource, so it is natural that every other related resource references the parent-resource using "slug" field (rather than "id" field) - to maintain the contextual coverage. Note that doing so does NOT prevent you from going back and using "id" instead for foreign key - since slugs are unique.. and not changed once it is set (See next point)
			--|----|---- DO NOT DO ABOVE IF YOU'VE USED NATURAL KEY FOR SLUG - for same reason as you never use natural key for making "id" - because natural keys almost always change in span of product, and then you're left scrambling to change all tables ..or even worse, they go from being unique to non-unique.
			-- Disadvantages: 
			--|---- (1) Anyone knowing the "slug" of 1st table can now immediately know about the slugs used elsewhere :: BUT then.. having unknowable slugs shouldn't be your only security aspect
			--|---- (2) What if the structure started as parent > child relation, but later more tables' foreign key were added. NOTE: (a) If, when adding other foreign key, you change the slug to be like `{foreignKey#1|foreignKey#2|...}`, that's bad - don't change the slug once it is set. That being done.. sure the original intent of the table was to have a parent > child relation, but now it grew beyond it.. that's fine.. the "slug" field still remains unique - which it should by definition - nothing wrong with it.
	-->
	
	abstract class/mixins for common fields
	
	standard data : enum vs new table 
	-- standard table as 6NF form because of low cardinality of data
	-- migration
	-- TODO: add 2way model+model: standard data + other table: like a single table inheritance, so clean() can get complex - like a delegation
	-- TODO: add 3way model+model+service: If standard data for a row changes, that is not multi table inheritance but a workflow, and Finite state machine considerations come in
	<!--
	Using Enum rather than standard table creates problems in that old migration files would need changing. Polymorphic is like having different small db table that got joined using a column as a discriminator. The differene between this vs business processing is that i former, the discriminator column does not change. If dealing with former, then you'll need to keep your db table design most generic and then add specific valiation for each case.
	-- This is another reason to prefer storing constant data in table rather than in enum.. because once in Enum, it sort of becomes hidden.. specially the portion that different columns should not have relation between each other.
	
	What are considerations when designing a table for polymorphic entity? It can be modeled via a single table design with one column containing discriminator for different types. NOTE that what differentiates this from a db table for entity that can go through various stages, is that for the former, the enum valued column does not change its value after created. For the polymorphic table.. 
			--|----|---- add a separate validation constrain for each case. 
			--|----|---- Even more important question is how to design the table. Should it contain just one column which contains just the id and no explict foreign key link and the table to which that id corresponds to can change depending on polymorphic type.. or should there be an explicit foreign key dependency added? It depends on the use case. If what you are trying to do is (i) an aspect behavior and not a business behavior, (ii) deletion of original data does not cascade down to deletion of data in this table, (iii) you have no validation requirements on this table based on columns.. then you can store generic id without creating link, else always create link. An example of this is if you want to audit-track changes in model.
			--|----|---- -- When adding a new enum (or even a standard table entry), be careful of adding it to code. Because DB runs before application, the application won't be able to read new value. this can happen both if using standard data table or enum. Best do migration and code changes in separate deployment. If doing so does not fail in lower env, then it's ready to go for prod
	-->
	
	
	
	<h3>Keep model field as much constrained</h3>
	<p id="1612756799">In context of the <a href="#1612649521" data-nav-id="1612649521">example application</a>, particularly the "<a href="#1612650690" data-nav-id="1612649521">Requirements - Part I</a>" section, a "user" will have a username. Let's say the username is stored as a string within the entity, and as a text in database, as is generally done. Here's a question: does it allow having all <a href="https://home.unicode.org/" target="_blank">unicode characters</a>, or just a-z? How about A-Z in capitals? What about special characters like &gt;, &lt;, etc.? - But if these are allowed, then the application may become vulnerable to <a href="#1608866075" data-nav-id="1608343369">XSS attack</a>. <strong>It is suggested that when defining an entity field, it should be such that only the expected values are allowed in the database table.</strong> Maybe down the line, you get a specific customer complaint of how their data is not getting saved and they would like the database to allow storing additional values. For example, you allowed users to store a-z, A-Z, 0-9 in username, which worked good initially. However, when your business expanded to Germany, the users complained about not being able to add umlauts. The suggestion is to expand your entity definition when a complaint comes, and to not do it pre-emptively when it's not going to be used. If your application's current use case is that it'll get usernames containing a-z, A-Z, 0-9 characters, then just allow only those characters to be saved.</p>
	<!-- Mention above that while constraining prevents xss attacks.. it should not be considered mdel's responsibility to fend off all attacks. Not should fending attack be taken as main reason for constraining. The only reason it is done is because it matches modeling - that's it. Fending off attacks is a nice result of that. However, proper attack mitigation should only be kept at relevant layers. For a web-based attack, don't have DB layer take responsibility.. but do so in web interfacing layers.. like controllers and dto -->
	
	<!--
	Follow up to 1612753728: 2way repository + service (This is indirect 3way since repo connects with entity): A service can touch different models and cover various context.
	
	Follow up to 1612753728: 2 way model + model: every model across a domain boundary should have a corresponding new table, with one-way or two-way sync between the two. Combine it with "a table in a domain should only reference others from same domain" -- the syncs form legal rules of use. This can however get tedious and that's where legal agreement comes, following which you can squash the 2 forms to one. However, if squashing, be areful about how the 2 will then interplay with a 3rd domain where the "squash" is also getting sync'd. You want to have clear policies. Or, maybe, the other table in different domain is a view of first table.
	--|---- handles pii concerns. Give example of teacher / student / classroom-as-contract; and how last one can cause extra tables that promote security, but based on legal it can be squashed
	--|---- 3 way: model + model + user : is the "LoginAs" or "ViewAs" behavior. If doing so, maybe just having a "View" (and not a table) that does not allow saving data is useful. Can give different authorization for the view
	--|----|---- "data ownership driven design"; domain profile as corollary of "user" in different domains; 3rd party integration should be seen as different user and so if a data is sent out to it, there should be a new table at boundary
	
	Follow up to 1612753728: advanced/code arrangement: keep each context code in separate folder - has implications in changing from monolith to microservice; incl. follow up to 2way repo+service in that if service uses multiple contexts, keep it separate, or either define one context as being super to another.
	
	Follow up to 1612756799: 2way model+dto: Know how to constrain model vs how to constrain dto
	
	-->
	
	
	
	
	
	
	<!--

	
	2 way (Model-Model):
	-- make audit entries in same transaction as DB changes. One more reason to prefer a single transaction
	--|---- From cis-20: maintenance, monitoring and analysis of audit log.. run as background service. Additional background service can be running transactional outbox conformance.
	
	-- Model model validation: Finite state machine (FSM), PDA. Mention how this is different from traditional REST design and so it causes friction in implementation
	--|---- Keep model level validation and save() separate --- realize, save() related to repository, but validation related to model
	--|---- Understand why the need for separation -- This istaken from own Django notes but can help here (-- Model.clean() contains validations that apply at model level. Likely, this is the place to add referential checks, or any checks that should hold at DB level but likely isn't getting applied due to limitation of SQL language. On the other hand, Form.clean() is to clean the data that is read in the form from user-request. For example, if your form take a time-in, time-out.. then Form.clean() would contain validation like the date-time is not in future.. but Model.clean() will contain validation like time-in < time-out . Note how Form.clean() is user-data and business-process related, whereas Model.clean() is model-definition related. This also explain why `ModelForm` in Django calls `Model.clean()` in its `self._post_clean()` method, which is run separately after the form's `self.clean_form()` method ..and these are different from form's `full_clean()` which by its name, must do all sort of cleaning.)
	
	
	2-way (Model-Auth): 
	-- althought it is mentione separately, it should happen almost immediately as part of data model design
	-- Data ownership driven design.
	-- analyze requests with data ownership in mind. Start with data-ownership first design (good example on back forth communication storage, like in chat -- how to make it PII based - helps with take sanitize. Identify which party accesses which data). Ownership should flow down links. So, manyToMany is like a sink for PII and a good boundary between different roles. You must be very clear on ownership and backed by legal if you are going up up from manyToMany back. The conclusion you come to here must also match for corresponding audit log table
	-- PII Take and Sanitize (if you have separate data domain, this is easier)
	-- If getting multiple data by 3rd party api, store them in separate table and then link to it. This allows easier control if data policies change in future
	-- be careful defining authorization for contract based relation: 
			--|---- Say you have a client and worker. When the two are in contract, then the client can see worker relation. But, if the contract is terminated for any reason, then the client shouldn't be able to do so. This means: (1) have a separate endpoint for clinet where worker's data is available. DOn't bundle it with some other endpoint allowing worker access to the data even after contract is over; (2) have a different authorization to acess the data via endpoint - don't just look for client-role on user making the request, but also if the client is allowed data acess for worker slug in path param. ALSO - best do this check as a permission and not within view because (a) this definition, as a permission is more apt, and, (b) view methods must be declarative in nature
			--|---- ALSO, a second design consideration for "time-bound-contract" type behavior is -- never give slug of one party out to another. Think of it like this.. if you enter into a contract with a 3rd party app to get your name, age from Facebook in exchange for taking some quiz.. but instead Facebook also gives it your "id/slug" and now this site becomes the go-to place where other 3rd party give a Facebook-id and get historical data. Then did Facebook do anything wrong? Yes -- **it shouldn't have given out your unique identifier that remains for perpetuity out to a service with which you have a temporary contract**. The better model design is to make a contract table that has foreign key from 3rd party app and from your profile. Now, what goes to 3rd party app is not you id/slug but the slug of contract. If they want your details.. they are given other fields like name, etc.. which can be general and not constrained to be unique. Here, you can control the degree of personalization on data outflow - maybe just give out first name not full name, maybe just the zip code and not exact coordinates. This way, the 3rd party cannot make something tailored to the user of given slug in their code -- which means, things can still get personalized but not individualized (separate topic: unless facebook offers that feature.. but then, its under their control which is still better than letting it out in wild). With the new model, you become "user associated with a contract", rather than "user with that slug.." which gives your application better control rather than have the providers take control.
	
	
	2way (model+repository): Optimistic vs pessimistic lock. Optimistic clearly in 2way interaction. Pessimistic seems to be just related to repository, but realize that you can lock a top level table to control locks on everything below - and so repo code should do that early on. See data-storage glossary. It has 2 links; also the waybackMachine link on transaction has some good details on when to use what
	
	
	2way (model+dto)
	since timezone is gathered separately, return it's value separately.
	
	
	
	2way (entity + test):
	-- Choose your test fixture utility such that the test dtaa it creates also verify the referential relations
	
	
	
	3way (model+controller+dto)
	the controller may require returning datetime in a timezone different from what is captured in different data domain. Ex.: the teacher and school are in different timezone but are physically close. Here, school start time is in school timezone, but you want to send alert to teacher in their timezone.
	
	
	
	
	3way (Model-Model-controller)
	-- PUT call, being idempotent, should allow you to break constraint of Finite state machine. POST, PATCH gets affected by FSM and so they should be the verbs used in corresponding endpoint. Even delete.. if some state does not allow sudden delete, then it should not be via DELETE operation. 
	-- What about PATCH call? PATCH is in itself non-idempotent. But recall that a past rule says to always return same data - so same data should also go out in PATCH call. Being a model serializer, PATCH will also use same structure in request (as in response) to get data, but now unlike PUT calls, it can only take partial fields. So, how does controller know what action to take ..and what's difference between PATCH vs FSMinducing @action endpoints. Hence: PATCH should allow partial updates where you are modifying one or other portion of data, but it should not cause a business processing. Like, iif you accept time-in, time-out.. PATCh can be used to update just one field. Contrast that with calls to "business process" this data, like, approve / deny, etc. That shouldn't be done by PATCH but via @action. So use PATCH if that does not modify the "business status" associated with the entity.
	
	
	3way (Model+Auth+Controller):
	PII TAKE and SANITIZE
	-- SANITIZE calls : PII should sanitize only the necessary columns, not relations.
			
	
	
	
	-->
	
</article>
