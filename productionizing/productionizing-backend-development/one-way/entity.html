<!--
    HTML book section: Entity in 1-way interaction to Productionizing Backend Development, by Kunj Prasad on Github.
    Copyright (C) 2020  Kunj Prasad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<article>
	<h2>Entity</h2>
	<p id="1610064998">As mentioned in the <a href="#1611510000" data-nav-id="1611200362">schema section</a> of the data storage glossary, the initial step in database design involves creating the conceptual design, followed by creating the logical design. Techniques from domain driven design and database normalization are applied in this design step. In the current landscape of software development, it is very likely that an <a href="#1609290898" data-nav-id="1608344385">object-oriented paradigm</a> is used for the development of backend code for the business application. In this paradigm, a database table in the logical design maps to a class, and a row in the table maps to an object of the corresponding class. This object is called an Entity or a Model (also see <a href="https://stackoverflow.com/questions/2550197/whats-the-difference-between-entity-and-class" target="_blank" rel="noopener noreferrer">this question on StackOverflow</a>). The mapping between an entity and a database table row allows an object to be saved as a row, and for a row to be read and converted to an object. This is achieved through use of software called an <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" target="_blank" rel="noopener noreferrer">object-relational mapping</a> tool, or an ORM. When developing a web application, it is strongly preferred to use a <a href="#1617405655" data-nav-id="1608344368">web application framework</a> that provides ORM support for the database being used. Fortunately, many of the modern frameworks provide an ORM support. <strong>For purpose of this ebook, it is assumed that the backend application is developed using an object oriented programming language and a web application framework that provides ORM support.</strong></p>
	<p id="1610065800">A quick side note: Database froms an important part of backend development. Database related concerns are covered in more depth in a separate ebook: <a href="/productionizing/productionizing-database-schema" target="_blank" rel="noopener noreferrer">Productionizing Database Schema</a>. Readers are suggested to refer it as needed. The topics covered in this book are not dependent on conent of "Productionizing Database Schema" e-book. So, readers can refer it after finishing this e-book.</p>
	
	<nav class="article-toc">
		<h3>Table of contents</h3>
		<ul>
			<li><a href="#1612753728" data-nav-id="1609472905">Using domain driven design</a></li>
			<li>Normalizing tables<ul>
				<li><a href="#1613440014" data-nav-id="1609472905">Example of normalization</a></li>
				<li><a href="#1613445267" data-nav-id="1609472905">Denormalization</a><ul>
					<li><a href="#1613520117" data-nav-id="1609472905">Other examples of denormalization</a></li>
				</ul></li>
				<li><a href="#1613443573" data-nav-id="1609472905">Not relational table</a><ul>
					<li><a href="#1613443385" data-nav-id="1609472905">Audit table: A classic "not relational" table</a></li>
				</ul></li>
				<li><a href="#1613747301" data-nav-id="1609472905">Un-unique table</a></li>
				<li><a href="#1613442382" data-nav-id="1609472905">Normalization in agile development</a></li>
			</ul></li>
			<li><a href="#1613930963" data-nav-id="1609472905">Using table and field comments</a></li>
			<li>Naming<ul>
				<li><a href="#1615260470" data-nav-id="1609472905">Table name</a></li>
				<li><a href="#1613932814" data-nav-id="1609472905">Column name suffix</a></li>
			</ul></li>
			<li><a href="#1614191105" data-nav-id="1609472905">Table constraints</a><ul>
				<li><a href="#1614198575" data-nav-id="1609472905">Not-null constraint and Default</a></li>
				<li><a href="#1614197083" data-nav-id="1609472905">Unique constraint</a></li>
				<li><a href="#1614196319" data-nav-id="1609472905">Primary key constraint</a></li>
				<li><a href="#1614204120" data-nav-id="1609472905">Foreign key constraint</a></li>
				<li><a href="#1614440246" data-nav-id="1609472905">Check constraint</a></li>
				<li><a href="#1614193129" data-nav-id="1609472905">Deferred constraint and database dependency</a></li>
			</ul></li>
			<li>Column data type<ul>
				<li><a href="#1613947629" data-nav-id="1609472905">Identifier and Slug</a><ul>
					<li><a href="#1613946647" data-nav-id="1609472905">Slug</a></li>
					<li><a href="#1614571666" data-nav-id="1609472905">Identifier versus Slug</a></li>
					<li><a href="#1614573090" data-nav-id="1609472905">Three unique constraints per table</a></li>
				</ul></li>
				<li><a href="#1614199557" data-nav-id="1609472905">Text optional-valued fields</a></li>
				<li><a href="#1618178707" data-nav-id="1609472905">Numeric-valued fields</a></li>
				<li><a href="#1614824110" data-nav-id="1609472905">Date vs Datetime vs ZonedDateTime</a></li>
				<li><a href="#1613947022" data-nav-id="1609472905">Enumerated data</a><ul>
					<li><a href="#1615044545" data-nav-id="1609472905">How to implement?</a></li>
					<li><a href="#1615078115" data-nav-id="1609472905">Enumerated data and Inheritance</a></li>
				</ul></li>
			</ul></li>
			<li><a href="#1614440610" data-nav-id="1609472905">Migration</a><ul>
				<li><a href="#1616262915" data-nav-id="1609472905">Migration in agile environment</a></li>
			</ul></li>
			<li>Entity class design<ul>
				<li><a href="#1616345107" data-nav-id="1609472905">Super class</a></li>
				<li><a href="#1616347263" data-nav-id="1609472905">Custom ORM fields</a><ul>
					<li><a href="#1618181027" data-nav-id="1609472905">Blank optional text field</a></li>
					<li><a href="#1618181272" data-nav-id="1609472905">HTML safe vs unsafe text field</a></li>
					<li><a href="#1616350214" data-nav-id="1609472905">Custom fields versus custom getters and setters</a></li>
				</ul></li>
				<li><a href="#1616555826" data-nav-id="1609472905">Programmatic constraint</a><ul>
					<li><a href="#1616556905" data-nav-id="1609472905">Prefer check constraint if possible</a></li>
					<li><a href="#1616634984" data-nav-id="1609472905">Referential checks</a></li>
					<li><a href="#1613746290" data-nav-id="1609472905">Constraint on create and update</a></li>
					<li><a href="#1616833826" data-nav-id="1609472905">Modeling locks</a></li>
				</ul></li>
				<li><a href="#1616830940" data-nav-id="1609472905">Non-updatable field</a></li>
				<li><a href="#1616831542" data-nav-id="1609472905">Constraining vs Saving</a></li>
			</ul></li>
			<li><a href="#1612756799" data-nav-id="1609472905">Keep entity as much constrained</a></li>
		</ul>
	</nav>
	
	<h3>Using domain driven design</h3>
	<p id="1612753728">As mentioned in the <a href="#1611510000" data-nav-id="1611200362">schema section</a> of the data storage glossary, domain driven design is applied when forming the conceptual model. To understand this with an example, let's consider that the business goal is to achieve "<a href="#1612650690" data-nav-id="1612649521">Requirements - Part I</a>" section of the example application. For this requirement, realize that the concept of a "User"  is used by all business domains, i.e. all different groups of related activities / processes that can occur in the business application. This common use throughout all domains makes "User" a "top-level domain". Drilling down into individual process, one business domain is the banking service which consists of related activities, like, opening a new account, depositing or withdrawing money from the account. Another domain is optional life-insurance service. <strong>Domain driven design suggests that the database tables and the corresponding entity classes made for a business domain must be bounded only to that domain (see <a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener noreferrer">Bounded context</a>) and must not be shared with other domains.</strong> Having this separation promotes parallelism in software development because each team can focus only on the database tables related to the one business domain being managed by the team. Less influence from external teams on the design of database tables associated with a domain also promotes easier maintenance, easier design extension and an ownership towards the design. In context of this example, having a domain driven design means that the entities and database table must be designed in a way that the "bank account" entity must not contain insurance details in any of its columns, nor should it have a foreign key to entry in the insurance table; And same consideration also applies for the insurance table.</p>
	<p id="1617244412">If there is a business concept and corresponding database table that is used by multiple business domains, then all the involved teams must meet together to identify and agree on the structure and use of that table. An ultimate case of this is the top-level domain whose design should be agreeable to all teams. For a multi-domain entity, meeting the constraint of maintaining a bounded context imposes an additional requirement that a table being used by more than one domain must not contain reference to the table used strictly by a single domain. However, it is allowed to have references going the other way. For example, a "user" entity, being a multi-domain entity common to both the "bank account" and "lie insurance" domains, must not contain references to either one of "bank account" or "life insurance" concepts and corresponding entities. However, it is ok for a "bank account" can contain reference to a "user". Should the "life insurance" domain ever need to access the bank account details of the user, it shouldn't try to do so directly, and instead query the "bank account" domain to provide it with relevant details. To facilitate the query execution, it can provide one or multiple concepts that are common between these two domains, which, in this case, is "user".</p>
	<p id="1613440831">Above said, the demarcation between the different domains may not always be clear. Here's something to think: The "<a href="#1612650690" data-nav-id="1612649521">Requirements - Part I</a>" says that "All account holders are given an option to buy additional life insurance...". Can there be users who are not account holders? For example, administrative staff at bank. Let's say they are not required to have a bank account, i.e. the bank is not forcing its employees to open an account with it. Can these employees also apply for insurance? Also, why is such a question even being discussed when the requirement doesn't mention anything about non-account-holding users? This is done to highlight two points. One is to highlight that as part of software development, it is necessary to clarify requirements. What is provided as requirements need not be final, it needs to be "clarified" more, and the requirements can change as discussions proceed. Next is to highlight a possible design alternative for the case where all users are also account holders. The alternate design is to define "bank account" as the top level domain which joins together the "user" data along with the "bank account" data because doing so is not prohibited by the requirements. We can as well add insurance information in the same domain and say that the business has just one domain. Rather than being fastidious about trying to identify the ideal breakdown of various domains, it is suggested that one should start with a domain model that satisfies the business requirement as the time. As new requirements are identified, the database tables can be decomposed to maintain normalization as discussed <a href="#1613442382" data-nav-id="1609472905">later</a>, and the domains can also be decomposed along with the tables based on analysis done at that time.</p>
	
	<h3>Normalizing tables</h3>
	<p>This section builds on the discussion about <a href="#1611407572" data-nav-id="1611200362">database normalization</a> under data-storage glossary. It also uses the "<a href="#1613439952" data-nav-id="1612649521">Requirements - Part II</a>" of the example application to highlight additional points on database normalization.</p>
	
	<h4>Example of normalization</h4>
	<p id="1613440014">This section gives some example of database normalization in action. To achieve the business requirements and maintain 1NF form, a new table (let's call it <code>AccountTransaction</code>) must be made rather than adding a list of transactions within a single column in the <code>BankAccount</code> table. The <code>AccountTransaction</code> will have a foreign key to <code>BankAccount</code> table to identify which account the transaction corresponds to. To realize the constraint that there can be only at most 1 transaction for a user in a day, the <code>AccountTransactions</code> table can store the "transaction date", and define that the combination of (user, transaction date) as unique. Within <code>AccountTransactions</code>, a column can also be made to store the transaction amount. Let's say that the transaction amount can be positive for deposits and negative for withdraws. The design produced so far is an example of a very simple schema design and also incorporates basic elements of database normalization. Here's a question: Why not store the start and end balance for the transaction rather than storing the change in balance? Hint: it denormalizes the table, and is discussed <a href="#1613445267" data-nav-id="1609472905">later</a>. Consider a different scenario with a minor change in the requirement: Let's say we were required to also store the exact time the transaction took place; The transactions can still be made at most once a day. This new requirement can be modeled by having a field called <code>createDatetime</code> in the table which captures the datetime when a record is made. Here's the tricky bit: We already saved the date when the transaction was made; It is the transaction date, and it, together with account user field is a unique combination. So would saving the <code>createDatetime</code> repeat the data already saved in "transaction date", and denormalize the table? Technically speaking, the answer is yes. However, this is a weird case because it seems that the requirement is forcing us to have a denormalized design. This is discussed in more details <a href="#1613520117" data-nav-id="1609472905">later</a>.</p>
	
	<h4>Denormalization</h4>
	<p id="1613445267">A discussion on normalization isn't complete without also considering its limitations, and where denormalization comes in. It is mentioned in a <a href="#1611408137" data-nav-id="1611200362">subsection</a> under RDBMS section in data-storage glossary that normalization comes at cost of performance. With reference to the <a href="#1613440014" data-nav-id="1609472905">above example</a>, is there a way to see the performance tradeoff being incurred to maintain normalization? Consider the question posed earlier: Should the <code>AccountTransaction</code> record store the change in balance, or should it instead store the start and end balance? If the <code>AccountTransaction</code> table is designed to only store the change in balance, then, such a design, in combination with the final balance stored in the <code>BankAccount</code> table, is able to idenify the account balance for the "bank account" at every point of time. There is no data duplication in any tables, and this is a normalized design. However, if the business use case is that users may query for <code>AccountTransaction</code> entries very often and they also expect to see the corresponding end balance, the above design is not performant because to construct the account balance for a past transaction, the web application will have to pull all records from the database and crunch numbers using those data, which will be CPU intensive. Instead , consider a design that stores the end balance and the transacted amount in the <code>AccountTransaction</code>. With the new design, only one <code>AccountTransaction</code> entry needs to be read and it can provide relevant details to the user. However, this new design is not normalized because there is a redendancy of data; One may calculate the end balance of a transaction by adding the transaction amount to the end balance of previous transaction, or one may directly read the value from the column. In comparison, the old design is normalized and there is no data redundancy, but is non-performant.</p>
	<p id="1617249805">Realize that above also contains a second and very subtle example in support of the statement that that some designs are more attuned than others to handling a use cases. Here's the hint: Why is it that the normalized design above suggests storing the end value in the "bank account"? An equally valid design can be to instead store the start balance when the account was opened. In this case too, the list of account transactions can be used to identify the final account balance after every transaction. An "end balance" rather than a "start balance" is stored because in real world, users are generally concerned with knowing their most recent bank account balance and not the value that they started with. So, the design of storing the ending balance rather than storing the start balance is more attuned to handling the expected business use cases. While the end balance can be computed using starting balance and list of "AccountTransaction" entries, doing so is computationally expensive and becomes even more expensive with every new transaction. This design also hides an example of performance boost via denormalization. The start balance for an account can be defined to always be 0 because a new account should't have any balance. Hence, the end balance column is a actually a redundant data because it should ideally be same as the sum of all amounts transacted since the account was created. But then, doing and on-the-fly calculation of the end balance will be extremely resource-intensive and not performant. It is instead, simpler and faster to just store the end balance with the account, so users can query it when needed.</p>
	
	<h5>Other examples of denormalization</h5>
	<p id="1613520117">What are few more examples of denormalization? Consider the question in the <a href="#1613440014" data-nav-id="1609472905">above example</a> of storing both <code>createDatetime</code> and <code>createDate</code>. Ideally, this is denormalized data because same data piece has been repeated in two separate columns. It breaks 3NF requirement because now, these 2 columns have a relation between them that is independent of the unique combination. However, since the current databases don't allow simply having a datetime column and make a date-type unique index on it, so it becomes a practical necessity to have this denormalized design. A quick side note: this example shows that there may be certain use cases where denormalization is forced into the database design. However, there is a programmatic way to restore the normalization again, and it is discussed <a href="#1613746290" data-nav-id="1609472905">later</a>. Another tricky example of denormalization is when a table has two columns, one for storing file-name, and other for storing file-path, and the file-path column value includes file-name with/without the extension. This is also an example where two columns have a relation between them and they are unrelated to the unique combination of the record. Another place where denormalized design stands out is in collecting metrics. Since a bank account consists of list of <code>AccountTransaction</code> entries, an <a href="#1613521031" data-nav-id="1608303678">OLAP type request</a> can be made to collect the count of transactions made by the user. One implementation is to calculate this value every time its needed, which is not hard or even non-performant, and can be using SQL statement like <code>SELECT COUNT(*) FROM... WHERE ...</code>. Just for the sake of giving an example, another possible design can be to denormalize the "bank account" table by adding a couting column that is incremented by 1 on each transaction. A side note: realize that reporting data is generally collected via <a href="#1608688160" data-nav-id="1608344358">cron jobs</a> that allow running OLAP type queries for a long time. The cron jobs are unlike a web server which is used to primarily serves OLTP type requests, and which will timeout and close a request if it keeps running for a long time. For businesses that have grown to a scale where having such reports are an essential part of their operation, they also invest in <a href="https://aws.amazon.com/big-data/datalakes-and-analytics/what-is-a-data-lake/" target="_blank" rel="noopener noreferrer">data lakes</a> for OLAP request processing. Thus, the OLTP requests are served using the normalized data from the database and OLAP requests are served using the denormalized data hosted on a different storage than OLTP data, and which are formed by periodically syncing from the data in the normalized database and doing pre-processing it to add denormalized fields.</p>
	
	<h4>Not relational table</h4>
	<p id="1613443573">Let's consider a modified requirement wherein the account holders don't want to see the individual account transaction details, and they only want to know the final balance and other bank account details. However, it is needed to collect data on individual transactions so that it can be used for auditing purpose, or to settle transaction disputes with the customers that occur extremely infrequently. Even with this modified requirement, the previously developed design of having a separate account transaction table with foreign key to bank account can be used to make a business application! Now, the transaction tables can be used to audit the changes in bank account balance. Let's extend the requirements and require that we'd want to include auditing for all tables in business domains. The bank account balance is audited by the transaction table. Hence, it remains to capture modifications in the insurance table, in the bank account table (for example, if bank account is suspended due to low balance or inactivity), and in the user table (for example, change in user first or last name, email, phone number, etc.). One way to achieve the requirement is to make three new tables to facilitate auditing the changes in bank account, insurance and user table. The drawback of this approach is that it causes overall schema to proliferate, and become increasingly bloated and cumbersome because with the addition of a new table, it will now be required to also add a corresponding and new audit table. Another design option could be to have a single table with a column storing table name (let's call this as column-A; it stores table name values like "BankAccount", "User", "Insurance"), a second  column storing identfier of the record in the table (i.e, the table whose name is stored in column-A) which is being added or updated (let's call this as column-B), and a third column holding the details about the changes. This design is still able to accomplish all the requirements because the combination of column-A and column-B uniquely identifies the database record getting modified. However, unlike traditional tables, column-B will not be a foreign key because it does not link to column in any one table. This is a "not relational" table: it behaves like there is a relation, but there actually isn't any. Side-note: I don't know if "not relational table" is the correct term; I couldn't find any existing name for it and "non relational term" seems to convey the idea.</p>
	<p id="1613708229">In the "not relational" table design, since the entry in column-B (described in above example) is not related to another table via foreign key relationship, records in the not relational table will not get affected in any way if the data in any other table is changed. This can be advantageous when the not relational table is used to store auditing records because one can now be assured that entries in audit table won't get mistakenly changed after it has been created due to cascading database operations (Side-note: By adding a notion of "data block" and cryptographic signature over the data block on to this design of not relational table, one gets a blockchain. If your business highly values the need for auditing transparency, then this can be a nice additional feature to explore). Also realize that the same feature, i.e., lack of relations between not relational table and other tables, can also become a huge design drawback because the maintenance of relation could require extra work. So, be very sure when using not relational table and if it'd be preferred to instead use a table that maintains relationship. A good rule of thumb is that any <a href="#1613521031" data-nav-id="1608303678">OLTP request</a> related data must NOT be stored in "not relational" table(s).</strong></p>
	
	<h5>Audit table: A classic "not relational" table</h5>
	<p id="1613443385"><a href="#1613443573" data-nav-id="1609472905">Audit tables</a> are mentioned in <a href="#1608738330" data-nav-id="1608344358">a section</a> under the housekeeping glossary and have been briefly covered <a href="#1613443573" data-nav-id="1609472905">previously</a>; In this section, we go more in-depth on the topic. The goal of an audit table is to keep a record of all changes made to any record in any other table used as part of any business processing. At a minimum, it requires 3 columns: the name of table where the record exists that is being changed (let's call the column in audit table holding this value as column-A), the identifier of the record being changed within the table where it exists (let's call the column in audit table holding this value as column-B), and a column holding the changes made on the record. Two additional field that one can immediately think of to store within the audit table are: user-id for the user who initiated the request that triggered the change and the datetime when the change is being done (side-note: this is also the create-datetime of the audit entry record). Another field that can be stored is if the business application allows a user with higher/privileged permission to impersonate another user or group, then an "on behalf of" column can also be added. This is also useful to capture background processing initiated by the system after the user has requested for a processing to happen asynchronously.</p>
	<ul id="1613711464">Let's explore some topics an questions related to audit table:
		<li>Audit table entry already stores the time when an entry is modified. Should the table whose entry is getting modified also store this value, i.e. the time when it is being modified? As mentioned <a href="#1613708229" data-nav-id="1609472905">previously</a>, if knowing the modification time can be useful in responding to some OLTP type request, then yes, the table whose entry is getting modified can also store it. As an example, let's revisit the <a href="#1613440014" data-nav-id="1609472905">example discussed previously</a>. Let's say that to capture a transaction detail, an entry is made in the <code>AccountTransaction</code> table. In doing so, a corresponding entry is also made in the audit table. For the <code>AccountTransaction</code> table, it is necessary to store its create date entry because the create date is part of the unique combination (user making transaction + date when transaction made). Since, it is required to store the create date in the <code>AccountTransaction</code> table to successfully process an OLTP request, so, it is ok to store same data in both <code>AccountTransaction</code> and audit table. Same reason also supports storing different version of the same data in the two tables, i.e. store a create datetime value as a datetime type in audit table, but only as date type in the other table.</li>
		<li>In a <a href="#1613440014" data-nav-id="1609472905">previous discussion</a>, the <code>AccountTransaction</code> table is designed to store both the create-date and create-datetime values. Storing create-date in the <code>AccountTransaction</code> table is needed because it is part of the unique index. With the understanding that one can have a separate audit tables to store audit related values, should <code>AccountTransaction</code> still be allowed to store create-date and create-datetime? Realize that the storage of create datetime in both the transaction table and the audit table is an example of data denormalization, as discussed <a href="#1613520117" data-nav-id="1609472905">previously</a>. Thus, the answer to the question is that if there is a user interaction that is greatly improved by denormalizing data, the yes, the same data can be stored in multiple tables. More concretely, if there's a need to get the create and/or last modified datetime as part of some OLTP request processing, then storing it in <code>AccountTransaction</code> is a good idea.</li>
		<li>It is said that when making audit table entries, the user-id for the user whose request caused modifications in a table record can also be saved. What happens if the change is initiated by some <a href="#1608688160" data-nav-id="1608344358">housekeeping task run by the system as a cron job</a>? As mentioned in details in <a href="#1613710989" data-nav-id="1609472950">a section under the user auth/auth page</a>, one must run such task by invoking a web-request as much possible. If not possible to do so, then an alternative can be to use some <a href="#1613746933" data-nav-id="1609385771">environment variable(s)</a> when starting the task and read it when executing the task. A last option could simply be to set some default value in the code when change is not triggered by any request or user. However, this option should be avoided as much possible.</li>
		<li>In a <a href="#1613709139" data-nav-id="1611200362">section</a> for database normalization under the data-storage glossary, it is suggested to always try to define for a unique combination for a record in the table. So, what is the unique combination for an entry in the audit table? This definition of uniqueness in audit table depends on how the application is used and what type of data it is getting. It might even be possible for there to be no such uniqueness, as discussed <a href="#1613747301" data-nav-id="1609472905">later</a>.</li>
	</ul>
	
	<h4>Un-unique table</h4>
	<p id="1613747301">In a <a href="#1613709139" data-nav-id="1611200362">section</a> on database normalization under the data-storage glossary, it is suggested to always try to define for a unique combination for a record in the table. However, there's also a comment in the same section that having a unique combination is not always possible. This section explores cases when not having a unique combination for a table may happen. Consider the design of <a href="#1613443385" data-nav-id="1609472905">audit table</a>, as discussed above. An audit entry is made when a record in some other table is created or modified, and it has no other business use case. Thus, under the assumption that there won't be more than 1 modification of a record per user, per millisecond, a four-field combination of unique constraint can be made using the table name, id of record in the table being changed, time of audit entry and the user who made the request. However, this is still a weak definition of uniqueness because it is not based on any business process constraint but on the way a user interacts with the system. Consider another example where you work as a customer service representative, and you receive an incoming message from the POST request made by an user on to some REST endpoint. Your goal is to collect all messages sent by a user. Once again, there's no unique criteria that can be defined on the messages being sent by the user. A user can concurrently send similar messages with trivial differences and they will get still recorded as different messages in the database. The database won't raise a failure saying: "Hey customer! you've already sent a similar message, so I'll reject other messages sent by you because they seem to be repetition rather than you sending a new message". In this example, we have a table that is used in business process is still unable to identify any unique criteria over the data in a table row. It is unlike an audit table which is not part of a business process, but of related housekeeping task, like, auditing. From above examples, it is identified that if a database table serves a role that could have been played equally well by a messaging system, then the table will not have any unique constraints defined on it, which also seems to be a logical behavior. In this book, such tables are defined as "un-unique" tables because of inability to define a uniqueness constraint on it.</p>
	<p id="1613885516">If these tables could be replaced by a message queue, then why not simply do such a thing? One: Using of a message queue may not be possible due to lack of infrastructure availability, or lack of developers, or any other reason. Second: To perform a transaction spanning over a database and a message queue means to do a <a href="#1612128885" data-nav-id="1611200362">distributed transaction</a> - which are more involved and hard to setup. Within the <a href="#1609350800" data-nav-id="1608344385">microservice architecture</a>, there exists a design pattern called <a href="https://microservices.io/patterns/data/transactional-outbox.html" target="_blank" rel="noopener noreferrer">"Transactional Outbox Pattern"</a> that aims to completely do off with distributed transactions using un-unique table.</p>

	<h4>Normalization in agile development</h4>
	<p id="1613442382">One of the key components in modern <a href="https://en.wikipedia.org/wiki/Software_development" target="_blank" rel="noopener noreferrer">software development</a> is the use of <a href="https://en.wikipedia.org/wiki/Agile_software_development" target="_blank" rel="noopener noreferrer">Agile software development</a> practices. Discussion on agile practices is a very broad and tangential topic to what this book intends to achieve, and so, readers are encouraged to use their favorite search engines to explore the topic. A key feature of agile development is to iteratively identify new features, build on it, test it and deploy it; Then identify new patterns in the interaction of users with this new feature, and enhance or modify the feature accordingly. A question to consider is if the agile development practices interfere with the ability to have a properly normalized database schema? A proper normalization requires complete knowledge of the business processes, different data pieces involved in each process, interaction within and outside domain, etc. However, when working in a agile environment, the features are iteratively developed in smaller chunks and there won't ever be a complete understanding of a business process. For example, in a <a href="#1613440831" data-nav-id="1609472905">previous discussion</a> on domain driven design, it is identified that one may choose to only have a single top level data domain. However, as more requirements are added, the various sub-domains of the business application may be better identified and a need to decompose the original data domain may come up. Another scenario that genereally happens is that the product owners want to explore addition of a new features to test whether users would like it or not, and they don't want to commit having the test feature become tightly ingrained in the main database schema. Such cases preclude the ability to have a properly defined schema because one may get asked in future to rollback any newly added feature. In this case, new tables and/or columns should be added in a manner such that it can be removed later on. So, is there any guideline on how to balance normalization in agile development practices?</p>
	<p id="1613927237">A quick side-note: examples for different normal forms are discussed in a <a href="#1613523454" data-nav-id="1611200362">section</a> under data storage glossary. When developing database schema, having it in 1NF should be considered as a necessary behavior and should not be skipped. It is also simple to have the database schema in 1NF through use of foreign keys. 2NF requires that all other columns relate to the complete unique key combination. This is something that may not always apply as the database schema evolves during the agile software develpment. It may also not apply if some feature is added for initial testing and is not yet fully baked-in as a business process. With 2NF, even if a schema does not currently meets the behavior, it's always possible to do custom data <a href="#1614440610" data-nav-id="1609472905">migrations</a> and restore 2NF form by decomposing single table into multiple tables and without data loss. In other words, it is always possible to move from non-2NF design to a 2NF design, and to do in a simple manner and without data loss. So, requirement of having the schema in a 2NF form can be temporarily relaxed and brought in after a business process feature has been established; Hopefully, the data migration is done sooner than later. 3NF requires that there is no relation between the non-unique columns of a table. If not maintained, then it can get hard to identify what all relations are there and the custom data migration to fix the 3NF form can become complex. Even worse, the database may have inconsistent entries where the relation between the non-unique columns weren't checked when entering the data. Due to the complexity of fixing a non-3NF design, it is strongly suggested to maintain it when evolving the database schema. Thus, when adding a new column during agile development, make sure that the new column relates only to the unique key of table and not to some other non-unique column(s). For 4NF and 5NF forms, similar arguments as used for 2NF and 3NF correspondingly can be reused and applied on to the columns that form the unique key combination for a table. Hence, maintaining 4NF can be skipped and maintaining 5NF should be pursued during database schema design evolution.</p>
	
	<h3>Using table and field comments</h3>
	<p id="1613930963">Once the database schema is made, the next step is to create the tables and corresponding columns. In doing so, it is suggested to include both table and column level comments at same time when creating a table. If not, then the comments must be added anytime before the table is used elsewhere, for example, as a foreign key constraint. The comments re-affirm the reasons for choosing the table and column design, and also acts as documentation for any one within and outside the team to understand the purpose of the table. The reason to define the table comment before the it is used elsewhere is to prevent the comment text from having an inconsistent content. For example, consider the example where a column of table-1 is used as a foreign key in table-2. For this to happen, table-1 must be defined before table-2. If that's the case, then it is logical to expect that the comments for table-1, which should explain the purpose for having table-1, must not contain any text about table-2 because table-2 is not yet defined. An inconsistent text is when this expectation is not held in the comment text. This inconsistency in the text content is avoided by having the table comment be defined before the table is used elsewhere.</p>
	
	<h3>Naming</h3>
	<h4>Table name</h4>
	<p id="1615260470">In a <a href="#1611110640" data-nav-id="1608344385">sub-section</a> under the object oriented programming paradigm in the architecture glossary, it is suggested that the class name must be singular and not plural because an object of the class represents one real-world entity. Since ORM maps a class to a database table, a singular noun should also be used for table name to achieve close match between the entity class name and the corresponding database table name. Even though ORMs provide the ability to have different names for the table and the corresponding entity, it is best if the two are kept same to avoid potential miscommunications.</p>
	
	<h4>Column name suffix</h4>
	<p id="1613932814">A <a href="#1613930963" data-nav-id="1609472905">previous section</a> suggests adding comments on all columns for a table to help communicate the role and use of a column. However, IDEs (i.e. integrated development environment, commonly used by software developers to improve coding process) don't have plugin to hook into the database and show these comments to user, and so, the intent of a column may not always get communicated to the developer during coding. To handle this scenario, it is suggested to use suitable suffixes in column name to communicate the intent of the column. For example, if a column stores datetime when an entry is created, then name it as <code>createDateTime</code> (if using camel case; for snake case, this can be <code>create_datetime</code>), rather than naming it as <code>createDate</code> or <code>createTime</code>. Now, anyone looking at the entity class or the table will immediately realize that the field or the column stores dateTime values rather than a date or a time type values. To prevent miscommunication, it is suggested to pursue the standardization of name suffixes at the organization wide level, if possible. Another thing to keep in consideration is that since an ORM maps the column to a field in the entity object, the column should be named such that it is a noun and not a verb. This is in keeping with naming practices for an object discussed <a href="#1611110640" data-nav-id="1608344385">in a subsection</a> within OOP section of the architecture glossary.</p>
	<ul id="1613946477">Some of the suffixes that can be standardized are:
		<li>Using "datetime" vs "date" vs "time" for column that correspondingly contain entries of type datetime, or date, or time. Also, be careful naming field that have a corollary in daily use. For example, name as field as "birthDate" and not as "birthDay", even though in daily use, everyone says "birthDay" and not "birthDate".</li>
		<li>Using "code", or "type", or "name" for column containing enumerated type data - but pick one and use it consistently. More on enumerated type data is discussed <a href="#1613947022" data-nav-id="1609472905">later</a>. For example, the bank account type can be CHECKING or SAVING. These are 2 "type" or "code" values. An equally good alternative could have been to use code values "C" and "S" for the two bank account types. To further describe an enumerated type data, the suffix "name" and "description" may be used. For example, to describe the type "C", the corresponding name can be something like "Preferred Checking Account Type" with a "description" field describing the features of the account.</li>
		<li>Use "indicator" or "flag" for storing boolean values.</li>
		<li>Use "uri" or "url" suffix if it contains information about the path to find some resource.</li>
		<li>Use context appropriate, unambiguous and non-abbreviated suffixes when possible. For example, using "phone_number" as field name or as a column name suffix if storing a phone number.</li>
		<li>Use suffixes that end with a numeric value when storing a list or object type entry but when normalizing the columns to a separate table does not makes sense. For example, when storing the street address, one can have 2 columns and name them as "address_1" and "address_2".</li>
		<li>Use "id" or "identifier" for the column containing the identifier - but pick one and use it consistently. More on "identifier" column is discussed <a href="#1613947629" data-nav-id="1609472905">later</a>. If the identifier column is used as a foreign key, then name the corresponding column as`{tableName}Identifier`. For example, the column in <code>AccountTransaction</code> table that is a foreign key to the <code>BankAccount</code> table should be named as <code>bankAccountIdentifier</code> or <code>bankAccountId</code>.</li>
		<li>Using "slug" for a slug type column. More on "slug" column is discussed <a href="#1613946647" data-nav-id="1609472905">later</a>.</li>
	</ul>
	
	<h3>Table constraints</h3>
	<p id="1614191105">Constraints can be used to limit the type of data that can go into a table. This ensures the accuracy and reliability of the data in the table. Constraints can be applied at individual column level or at row level. The database rejects any <a href="#1611510020" data-nav-id="1611200362">transaction</a> made to add or modify data in a table where the constraints are violated. The "atomicity" (reference: <a href="#1612128885" data-nav-id="1611200362">ACID properties</a>) behavior of a transaction implies that when a transaction is rejected, then all changes made in multiple tables as part of the transaction are also rolled back. Since a transaction may comprise of multiples changes done on one or many tables, a related question is if the constraint check is done multiple times within a transaction after a change is applied, or if it is done after all the changes in a transaction have been done? This is controlled by identifying if the constarint are deferrable or not, as dicussed <a href="https://oracle-base.com/articles/8i/constraint-checking-updates#Deferred" target="_blank" rel="noopener noreferrer">here</a>. When adding constraints, a good idea is to also mention about the constraints in the table or field comments (a discussion on comments is covered in a <a href="#1613930963" data-nav-id="1609472905">previous section</a>). The set of sql constraints that can be used are: Not-null, Default, Unique, Primary-key, Foreign-key, Check, Default constraints (reference: <a href="https://www.w3schools.com/sql/sql_constraints.asp" target="_blank" rel="noopener noreferrer">here</a>).</p>
	
	<h4>Not-null constraint and Default</h4>
	<p id="1614198575">The <a href="https://www.w3schools.com/sql/sql_notnull.asp" target="_blank" rel="noopener noreferrer">not-null</a> constraint is a column level constrainst that requires the column to always contain a value when inserting a new record, or when updating a record. If not set, the the column can store null values. If the business logic is such that a default value should be added when no value is provided, then the "<a href="https://www.w3schools.com/sql/sql_default.asp" target="_blank" rel="noopener noreferrer">default</a>" constraint is applied to the same column. It is inferred from these definitions that there will never be a case where both non-null and default constraints are applied to a column (I'm not sure if that'll raise an error in the database, but it will definitely raise many eyebrows from team members!! Best not to do it). <strong>If a column accepts null values, then, as much possible, strive to associate a default value to the column.</strong> This is because null values behave very differently from non-null values (see <a href="https://www.sqlservercentral.com/articles/database-design-follies-null-vs-not-null" target="_blank" rel="noopener noreferrer">here</a>). The SQL comparisions, query, updates will be lot less error prone and bulky if a lesser number of nullable columns without default values are used in a table.</p>
	
	<h4>Unique constraint</h4>
	<p id="1614197083">In a <a href="#1613709139" data-nav-id="1611200362">section</a> for database normalization under the data-storage glossary, it is suggested to always try to define a unique combination for a record in the table. This is achieved by defining a <a href="https://www.w3schools.com/sql/sql_unique.asp" target="_blank" rel="noopener noreferrer">unique constraint</a> on the table which ensures that all values in one or multiple column(s) over which the constraint is defined, are unique in the table. to enforce uniqueness of values, the constraint utilizes a <a href="https://www.tutorialspoint.com/sql/sql-indexes.htm" target="_blank" rel="noopener noreferrer">table index</a> to identify that the entries are all unique. It should be noted that in the request processing pipeine, i.e. from user making a request up to the user receiving the response back for the server, the database is the first component that can identify whether an entry being persisted has duplicate value for a column / columns. Hence, <strong>having extra code inside the web application should never be considered as a viable alternative instead of defining unique constraints.</strong></p>
	<ul id="1614199777">A few more things to keep in consideration when working with unique constraints:
		<li>If a table has more than one unique constraint, then it is either not 2NF and/or not 4NF normalized. As discussed <a href="#1613927237" data-nav-id="1609472905">previously</a>, this is not something that needs to be immediately corrected when developing codes based on agile practices. However, it should be rectified sooner than later.</li>
		<li>This is an important one: How does the unique constraint behave with null values? Since the database treats "null" as not being any value, 2 null values cannot be compared (reference: <a href="https://www.sqlservercentral.com/articles/database-design-follies-null-vs-not-null" target="_blank" rel="noopener noreferrer">here</a>; Also, this is why the SQL query for null checks use "{column} IS NULL" rather than "{column}=NULL"). Since the 2 null values cannot be compared, so "NULL == NULL" is false, which means <strong>one can add any number of null values in a column and they will all be considered unique!</strong> One can mitigate this behavior by adding not-null criteria over all columns on which the uniqueness is defined. Alternately, one ay exploit this behavior to achieve a non-standard way to have a group level uniqueness. For example, let's say you are collecting information on different activity groups in a school, where one student in each group is a president of the corresponding activity group. There is a notion of uniqueness in that no more than 1 student can be president. However, this uniqueness exists on a "per activity group" basis and not on "per student" basis. One way to solve this is to define a uniqueness criteria over 2 fields, say </code>(groupName, isPresident)</code>, where <code>groupName</code> is string-valued, and <code>isPresident</code> is boolean-valued, and the web-application either puts true (for student who is president) or null (for other students) values in the <code>isPresident</code> column. This will still pass uniqueness criteria since only one student will have true value for it, and all others will be null. This being said, it's not a good practice to do so because: (1) How will you now support having 2 presidents per group such that both the presidents are different? (2) The proposed solution relies on 2 null values being considered unique. This is not something that SQL standards supports! Hence, a solution relying on the database implementation quirk of two null value being considered different may abruptly change in future, or even change from one database to another. (3) This solution itself won't support changing from one president to another within the same transaction unless deferred constraints are used, which does not work for certain databases, as discussed <a href="#1614193129" data-nav-id="1609472905">later</a>. (4) In addition to having unique constraint over <code>(groupName, isPresident)</code>, one can also define a unique constraint on same table over <code>(groupName, studentId)</code> since a student can join a group as a member only once. So now, same table has 2 unique constraints, and this is identified above as being an improper design. With all these problem points, is there an alternate option to use? Yes, and it is discussed <a href="#1614440386" data-nav-id="1609472905">later</a>. Side-note: Kudos to you, the reader, if you realized that in the above example, the field name should preferably be <code>presidentIndicator</code> rather than <code>isPresident</code>, as discussed <a href="#1613946477" data-nav-id="1609472905">previously</a>. There are 2 problems with using <code>isPresident</code> field name that I can think of. One is that "isPresident" is a verb and so should not be used as a field name which should be a name. The second problem is particularly this name doesn't work nicely in a Java code where getter methods for a boolean field uses a prefix of "is". Should the getter method now be "isIsPresident", or "isPresident"?  </li>
	</ul>
	
	<h4>Primary key constraint</h4>
	<p id="1614196319">The <a href="https://www.w3schools.com/sql/sql_primarykey.asp" target="_blank" rel="noopener noreferrer">PRIMARY KEY constraint</a> uniquely identifies each record in a table. It defines the column/columns whose value uniquely identify a row in the table. For this reason, the primary key cannot be null, and must be unique. A <a href="https://www.javatpoint.com/sql-composite-key" target="_blank" rel="noopener noreferrer">composite primary key</a> is when a combination of two or more columns in a table are used to uniquely identify each row in the table. While the combined value must be unique, it is not necessary that the data in individual column is unique. One example is if combination of date and time columns (..rather than a single datetime column) is used to define uniqueness. Different entries can be made for the same date but different time, and also, multiple entries made at same time of day, but for different dates. In either case, the combination of date and time for each entry will be unique and can serve as a composite primary key.</p>
	<p id="1614202345">The column(s) being used for definition of the primary key can also be classified as being a "<a href="https://en.wikipedia.org/wiki/Natural_key" target="_blank" rel="noopener noreferrer">natural key</a>" or a "<a href="https://en.wikipedia.org/wiki/Surrogate_key" target="_blank" rel="noopener noreferrer">surrogate key</a>" (additional reference: <a href="https://www.mssqltips.com/sqlservertip/5431/surrogate-key-vs-natural-key-differences-and-when-to-use-in-sql-server/" target="_blank" rel="noopener noreferrer">here</a>). Let's use previous example and say that we need to use a combination of (date, time) as primary key. What's new is that the date portion must also have a text column which describes the date, like, for "2020-05-20", it says "5th of May, 2020". A simple fix is to make a new table, let's say <code>DescriptiveDate</code> which has 2 columns, 1 containing the date value "2020-05-20", and the other containing the text "5th of May, 2020". With this change, the new primary key can be made by using the combination of (<a href="#1614204120" data-nav-id="1609472905">foreign key</a> to <code>DescriptiveDate</code>, time). Here's the question: There are two design alternatives for defining primary key of <code>DescriptiveDate</code> table; Which one should be used? One option is to turn the column with date value, like "2020-05-20", into a primary key. Another option is to add a new "identifier" column containing unique numeric values, and it can made into a "primary key". Taking the first route of turning "2020-05-20" into a primary key is an example of natural key. Latter is the example of a surrogate key. This topic is discussed further in a <a href="#1614542613" data-nav-id="1609472905">later section</a> and it is suggested to <strong>always use a surrogate key and never a natural key for defining the primary key constraint.</strong></p>
	
	<h4>Foreign key constraint</h4>
	<p id="1614204120">A <a href="https://www.w3schools.com/sql/sql_foreignkey.asp" target="_blank" rel="noopener noreferrer">foreign key constraint</a> is used to link two tables together, with the foreign key value in one table (called the child table) referring to the <a href="#1614196319" data-nav-id="1609472905">primary key</a> in another table (caled the parent table). Hence, each entry in child table links to an unique entry in the parent table. When the foreign key column in the child table is not constrained to be unique, then it forms a "Many-to-one" relation between the child and parent table. For myself, I feel that a good way to remember the relationship is by inserting words "this" and "that", i.e., rewording "Many to one" relationship as "Many [of this] to one [of that]". This means, many entries in "this" child table are linked to one entry in "that" parent table. Converesely, this also implies a "<a href="https://en.wikipedia.org/wiki/One-to-many_(data_model)" target="_blank" rel="noopener noreferrer">One-to-many</a>" relation from the parent table to the child table, i.e. one entry of "this" parent table is linked to many entries of "that" child table. When a foreign key column is constrained to have unique entries, it forms a "<a href="https://en.wikipedia.org/wiki/One-to-one_(data_model)" target="_blank" rel="noopener noreferrer">One to one</a>" relation between the two table. Just to mention again, there can be some cases where one may want to store the primary key for a table but without creating a foreign key relation, as described <a href="#1613443573" data-nav-id="1609472905">above</a>. Another related table structure is when it contains only two columns except the surrogate primary key column, and both these columns are non-unique, non-nullable foreign key to two separate table. This is called a "<a href="https://en.wikipedia.org/wiki/Many-to-many_(data_model)" target="_blank" rel="noopener noreferrer">Many to many</a>" relationship.</p>
	<p id="1614456323">Another question about foreign key: Should it be null? This is different from whether a foreign key column can be null, to which the answer is yes, it can be null. But even if it is allowed, should a foreign key column be allowed to have null values, i.e., have no values? This <a href="https://stackoverflow.com/questions/7573590/can-a-foreign-key-be-null-and-or-duplicate" target="_blank" rel="noopener noreferrer">StackOverflow thread</a> contains posts with real world examples where foreign key can be null. However, I would not recommend following the suggestions in the thread, and instead, would suggest to <strong>never allow a foreign key column to have null values</strong>. The reason being that a foreign key is used to identify a "dependency" relation between a child and a parent table. A null valued foreign key for an entity implies that there is no such parent-child relation. However, if there's no relation, then why even add a foreign key column? If there is a possibility that the child table can exist independently before it is related to the parent table, then instead of a null valued foreign key, an alternate design could be to have a join table that relates the various tables. This way, each entity can exist independently and at all points of time, and can form relationships among each other when required by the business processes. As an example, consider <a href="https://stackoverflow.com/questions/7573590/can-a-foreign-key-be-null-and-or-duplicate/7574042#7574042" target="_blank" rel="noopener noreferrer">this post in the thread</a>. For this case, the reason to not have a nullable foreign key is nicely captured by one of the comments for the post which suggests that a new "ProposalAssignedTo" table should be made to capture the state when the two tables are related. The drawbacks of using a nullable foreign key column as proposed in the design in the post are: (i) the design is not easily modifiable if the requirements change to allow a sales proposal to be related to multiple sales representative; (ii) the sales table in the proposed design has one unique constraint based on sales proposal, let's say a combination of (clientId, salesCampaignName), and then another unique criteria after the sales representative is identified, based on (clientId, salesCampaignName, salesRepresentativeId). As mentioned <a href="#1614199777" data-nav-id="1609472905">earlier</a>, if there are two unique constraints in a table, then it is likely not normalized. Hence, if there is a table (say, table-A) such that: (1) it may or may not have a dependency on an entry in another table (say, table-B), and, (2) both cases, i.e. when its foreign key column is null or non null, correspond to non-trivial business process; In sucg cases, it is better to implement the business requirement by having three tables, where 2 tables, table-A and table-B are designed to not have any foreign key column, and the last table, table-C, has non-null columns for foreign key to table-A and table-B, such that the combination of the 2 foreign keys is unique. Even with these changes, realize that the design doesn't yet implements the requirements that only 1 sales representative can be assigned to a campaign. The discussion on how to implement this requirement is covered <a href="#1614440386" data-nav-id="1609472905">later</a>. In the same Stackoverflow thread, another example that comes close to describing a valid case for using nullable foreign key is in <a href="https://stackoverflow.com/questions/7573590/can-a-foreign-key-be-null-and-or-duplicate/34682951#34682951" target="_blank" rel="noopener noreferrer">this post</a>. However, even for this situation one may avoid having a nullable foreign key column by using a multiple table inheritance design (discussed below, <a href="#1615078115" data-nav-id="1609472905">here</a> and <a href="#1616192250" data-nav-id="1609472905">here</a>) rather than having a design as mentioned in the table (which is called a single table inheritance design). Additional discussion on how to design for this case is covered in a <a href="#1616833826" data-nav-id="1609472905">later section</a>.</p>
	
	<h4>Check constraint</h4>
	<p id="1614440246">The <a href="https://www.w3schools.com/sql/sql_check.asp" target="_blank" rel="noopener noreferrer">check constraint</a> is used to limit the values that can be placed in a column for a table entry. It can be defined both at a table or at a column level. When defined on a single column, it allows only certain values for the column. When defined on a table, it constrains the values in certain column(s) based on values in other columns for the entry. A simple use case is applying check constraint on a column that stores enumerated values. When defining a check constraint, it is strongly suggested to exercise caution and ensure that the constraint have been properly defined if one or multiple columns being used in the constraint can have null values. When defining check constraints, one must also be cautious to define it based on the field or table definition and not based on the business requirements. For example, if a table contains datetime when a particular bank employee clocked in and out for day, then a table level constraint can be to require that each entry in the table have a clock-in time that is less than the clock-out time. This is a good check constraint because by definition, the clock-in time can never be more than clock-out time. However, consider a different requirement that a clock-in time must be between 8:45AM to 9:15AM. This is not something that defines a clock-in time but is a business expectation for a valid entry. It is suggested to NOT put these constraint at database level. The reason being that it may happen where due to some exceptional case, a bank employee may want to clock-in outside this range. For example, what if there was a sudden curfew in the city and bank can only open after 10:00AM! Or, maybe the employee is off for the first half of the day for some personal appointment. The reason why a business requirement constraint shouldn't be added as a database constraint is that these requirements define a "majority" use case, and not "all possible" cases that can happen. There can be some exceptional cases where it will be needed to add "out-of-ordinary" data in the database. However, if a constraint is added at database level, then doing so draws an absolute line on the type of data that can be entered in the database and nothing else beyond that; and having such a hard stance precludes the ability to handle special cases which may not be good for the business (i.e., you don't want to be selling a business application that breaks down at moment of need). That being said, maintaining data integrity is also important. This constaint should be put at a different level, and is discussed in "<a href="#1609472920" data-nav-id="1609472920">service</a>" section.</p>
	
	<h4>Deferred constraint and database dependency</h4>
	<p id="1614193129">As mentioned <a href="#1614191105" data-nav-id="1609472905">earlier</a>, database constraints can be deferred. However, some databases, like MySQL, does not allow constraints to be deferred, as discussed in this <a href="https://stackoverflow.com/questions/5014700/in-mysql-can-i-defer-referential-integrity-checks-until-commit" target="_blank" rel="noopener noreferrer">StackOverflow post</a>. Hence, if your business logic requires having operations where the constraint check must be deferred, then the ability to complete the operation will depend on the type of database being used. Such couplings are not a good implementation practice because it prevents the application from changing / upgrading databases. For this reason, it is strongly suggested to not design or use any business logic that requires having deferred constraint. Another important reason to avoid having deferred constraints is that as the business operation grows, it might happen in future that a single service gets split into multiple <a href="#1609350800" data-nav-id="1608344385">microservices</a>, and each of them are given an ownership over a small portion of original data and over the corresponding tables. With this split, it will no longer be possible to define deferred contraints without performing a <a href="#1612128885" data-nav-id="1611200362">distributed transaction</a> which is an expensive and non-performant operation. Bottom line: If you are using deferred constraint, then have a wider discussion with developers and product. Maybe there's a better implementation or maybe you realize that the product does not need the operation that is using a deferred constraint. If the discussions don't work, then do use a deferred constraint (..because the business should continue). I would also suggest waiting for a year or so to identify if any long term issues or advantages are seen and write about it to inform others on your experience. I won't go further on this topic because I've only ever had the need for adding a deferred constraint once. In that case, after an internal discussion, the requirement to have the operation needing a deferred constraint was removed.</p>
	
	<h3>Column data type</h3>
	<p>With the column name and the constraints defined, a natural next step is to identify the type of data stored in a column. This section identified considerations that must be kept in mind regarding the type of data that should be stored for certain columns. 
	
	<h4>Identifier and Slug</h4>
	<p id="1613947629">Every table record has a unique and non-null <a href="#1614196319" data-nav-id="1609472905">primary key</a> associated with it. One way to do so is by defining a <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_6015.htm" target="_blank" rel="noopener noreferrer">database sequence</a> and querying it for values. The values obtained from a sequence monotonically increases and is not rolled back even if the transaction fails. To keep this behavior consistent, the sequence should also be defined as being non-cyclic. This enables using a sequence to provide numeric values for use as primary key in one/many tables. I've not seen any particular pro/cons of using same sequence to generate primary key for multiple table. As <a href="#1613946477" data-nav-id="1609472905">discussed previously</a>, a preferred convention is to name the table column that stores this value with a suffix of "identifier" or "id". Another implementation practice is to define the "identifier" column such that it can store large numeric values, i.e. store up to 10 digits in database, and model using a <code>BigInteger</code> data type in the entity class. This is done to enable the database tables to store a huge count of records before needing maintenance.</p>
	<p id="1614542613">Defining the primary key using values obatined from a sequence is an example of a surrogate key. This can be contrasted to the example in a <a href="#1614202345" data-nav-id="1609472905">previous discussion</a> where the data in a unique, non-null table column is used as primary key; This is an example of a natural key. Here's a question: It is <a href="#1614197083" data-nav-id="1609472905">previously discussed</a> that every table should have at least one unique constraint, then should that value be reused as primary key, or should there be a separate column for primary key? There are a couple of reasons for why <strong>natural key shouldn't be used and instead a surrogate key should be used for defining the primary key</strong>: (1) Let's say there is a need to change the value in the unique column to a new, different unique value. Had a natural key design been used, then doing this change will trigger cascading changes in all other tables that has a foreign key to this entry. This slows down the database while the changes are being made, and will interfere with other requests in flight. However, the cascading changes are avoided if the primary key and unique data columns are kept separate. (2) From the viewpoint of database, using a natural key makes it ambiguous if a request is trying to update the value of a unique column, or if it is trying to change the primary key of a record. Former might be expected for some business processing, but the latter should never be needed. By using a surrogate key, these two concerns are kept separate from one another. One may develop the application in a way to never modify the primary key after a record has been made, and also include alerts for inappropriate operations attempting to modify the primary key after a record has already been created. (3) When the primary key constraint is defined, an underlying index is also made. <a href="https://dba.stackexchange.com/questions/137945/indexes-integer-vs-string-performance-if-the-number-of-nodes-is-the-same" target="_blank" rel="noopener noreferrer">This StackOverflow post</a> suggests that the index performance for numeric column is much better than a text or varchar type column. The performance downgrade due to the use of a text valued natural key rather than a numeric valued surrogate key piles up for every foreign key reference made to this table. (4) When developing in an agile environment, it may happen that a column that was initially identified as being unique, gets changed and no longer remains unique at a later point in time. Maybe, instead of one, it is a combination of two columns that end up defining uniqueness at a later time. Such changes are hard to incorporate if natural key was used for the primary key constraint, rather than using a surrogate key.</p>
	
	<h5>Slug</h5>
	<p id="1613946647">Let's say that a user made a request to create data in the database. To be able to retrieve the data in future, the server must return some value or token in the response that it sends to user, such that, at a later time, whenever the user needs to access the created data, they will provides the same token back to the server. The question is: what value should the server send back? One option is to send the primary key field itself because by definition, it uniquely identifies the data entry that was created. However, as discussed in these two StackOverflow posts <a href="https://stackoverflow.com/questions/396164/exposing-database-ids-security-risk" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://stackoverflow.com/questions/9904396/is-it-a-bad-practice-to-expose-db-internal-ids-in-urls" target="_blank" rel="noopener noreferrer">here</a>, <strong>it is a business intelligence risk to return the <a href="#1613947629" data-nav-id="1609472905">identifier column</a> values back to the user.</strong> As an alternative, the recommended practice is to send something called a "slug" back to the user. The term "slug" comes from the world of newspaper production and is an informal name given to a story during the production process. As an article / story winds its path from the reporter  through to editor through to the "printing presses", it is referenced by its slug. For example, instead of saying "Have you fixed the errors in story number 123", it is instead said "Have you fixed the errors in the 'kate-and-william' story?", with 'kate and william' being the slug (Reference: <a href="https://stackoverflow.com/questions/427102/what-is-a-slug-in-django" target="_blank" rel="noopener noreferrer">this StackOverflow post</a>). In my experience, I've mainly seen teams developing Django applications to use the term "slug". However, this ebook suggests using the "slug" field in entity class, regardless of the application framework used. For the purpose of current discussion, a "slug" is defined as a text valued, unique, and non-null field that is associated with every database entry. It can be interpreted as being a human-friendly tag for referencing a table data rather than doing so via a machine friendly and numeric valued "identifier" column. However, in the absence of having a more business context appropriate way to generate slug for a database entry, a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener noreferrer">UUID</a> or random text of certain length can also be used. Since slugs are random values, they don't leak business intelligence data that might happen when identifier column values are returned in response. Finally, since slugs are used to identify the data resource at the server, so they should always be unambiguous. Hence, they must be unique, and also must not be modified once they are created.</p>
	<p id="1618108194">In a <a href="#1614199777" data-nav-id="1609472905">previous section</a>, it is suggested that a normalized table should have 1 unique constraint. If so, then why make another slug column instead of reusing the unique constraint? Some reasons for doing so are similar to those <a href="#1614542613" data-nav-id="1609472905">discussed previously</a> on why a numeric valued, surrogate primary key should be preferred rather than having natural key. For example, the unique values can change over time, but the slug field value must not change. Uniqueness could be defined over a group of column(s), and the group size can change over time, but the slug field is a single column and should always remain unique. Also, the columns over which uniqueness is defined may not be text valued, but the slug field needs to be text valued. Last, the unique column(s) can contain personal and/or sensitive user data and so, it shouldn't be used as a slug to avoid putting the user in a risky situation. For example, think how you would feel if everytime you want to access some data, then you are asked to put your social security number in the url. That would be a very bad design and experience!</p>
	<p id="1618607005">In a previous section on <a href="#1614204120" data-nav-id="1609472905">foreign key</a> constraint, it is identified that there can be "many-to-many" tables that only serve to establish relationship between different entries of two tables and do not contain any other user data. Despite not having any user data, it may still be beneficial to add a slug column to these tables to handle the use case that if the user provides this slug to server in a request, then they intend to request for the information on table entries related to by the corresponding many-to-many table entry.</p>
	
	<h5>Identifier versus Slug</h5>
	<p id="1614571666">If slug field is unique and non-null, and can also be returned back to user for reference in future requests, then why even have a separate identifier column and why not only use a slug column? Referring back to a <a href="#1614542613" data-nav-id="1609472905">previous discussion</a>, the reason for doing so is that a surrogate, numeric valued primary key has better indexing performance than text valued slug fields. However, there is also a downside of this design. Let's say there is a child table, table-A, with foreign key to 2 tables, table-B and table-C. Let's say that a business use case is that when a user requests for data about table-A, then they must also be provided with slug for the corresponding entries in table-B and table-C. Since table-A contains foreign key to numeric valued identifier column of table-B and table-C, getting the slug values requires making a join call to these tables, and join calls are performance heavy operations. Instead, if the slug columns in table-B and table-C had been used as a foreign key in table-A, then table-A could have simply returned the values and not made the join call. Hence, there is a slight database performance degration due to the use of numeric identifier column for foreign key relation, and combining it with the requirement to return slug values back to user in response. That being said, since the index over number valued columns are much more performant, it does not degrade the overall request processing performance. Also, in a request processing pipeline, making HTTP calls are many order of magnitudes slower than having to perform an extra join operation, and so business web application should not used the latter as a reason to instead return identifier values in response.</p>
	
	<h5>Three unique constraints per table</h5>
	<p id="1614573090">In a <a href="#1613709139" data-nav-id="1611200362">section</a> under database normalization in the data-storage glossary, it is suggested to always try to define for a unique combination for a record in the table. In a <a href="#1614199777" data-nav-id="1609472905">previous section</a>, this criteria is further strengthened and it is asserted that a normalized table should only have 1 unique constraint. However, with recent discussion about the identifier and slug columns, this criteria should be updated to: <strong> Each table should have 1 primary key constraint over a numeric valued column (which is unique and not null), 1 unique and not null constraint over slug field, and finally, one more unique constraint derived from the role of the table in the overall business process.</strong>.</p>
	
	<h4>Text optional-valued fields</h4>
	<p id="1614199557">Let's say that you need to collect user feedback which consists of an optional comment field. One way to design the feedback entity class is to have the corresponding database table consist of a text field to collect the response, a foreign key to user that is giving the feedback, and a primary key field and slug field, as <a href="#1614573090" data-nav-id="1609472905">discussed above</a>. Here's the question: When a user does not provide any feedback text, then should the text valued response column be allowed to store null value, or should it instead store a default value of "empty string". It may be said that a null value is different from empty string, in that, null means the user has seen the feedback form, but hasn't submitted any value, whereas, empty value means that the user purposely submitted an empty value for the comment. There are 2 problems with this design: (1) Why is the business process designed in a way such that it creates a database entry when a user has not yet submitted the feedback form? If a user has not yet submitted the form, then instead of having a table entry where the response is null valued, a better processing would be to simply not make an entry. (2) From the user interface perspective, are the 2 response values, i.e., null or empty string, treated differently? For example: does null value cause a message to show up that the user has not provided any response, but this does not happen with empty string. Can the user choose to change their answer at any time from non-empty string to null value or to empty string? In most practical cases, the null and empty values are always treated in same manner. Hence, for a table column that contains optional text, a good design is to set the default value of empty string and not allow it to store null value. This also follows from a statement made <a href="#1614198575" data-nav-id="1609472905">earlier</a> that whenever possible, a default value should be added in the column. Just for context, the suggestion of having empty string values and not null values is something that I first read in <a href="https://docs.djangoproject.com/en/3.1/ref/models/fields/#null" target="_blank" rel="noopener noreferrer">Django documentation</a>. Above being said, it is also cautioned to not use the suggestion indiscriminately. Don't set any string valued database field to have a default value of empty. For example, a datetime column should allow for null values and must not be given a default value of empty string because an empty datetime string is an ill-formatted and wrong datetime entry. In such cases, the field should be nullified when no value exists.</p>
	
	<h4>Numeric-valued fields</h4>
	<p id="1618178707">For table columns that contain numbers, a good constraint to add is on the minimum and/or maximum allowed value that the column can take. For example, if a field contains salary information, then a constraint can be added that the salary value can never be negative.</p>

	<h4>Date vs Datetime vs ZonedDateTime</h4>
	<p id="1614824110">"To time or not to time" would be one of the big questions you'll come across when developing schema. The advantage of not storing time, and just the date portion, is that the indexes will be comparatively smaller. It is easier to query for table entries matching a particular date, rather than querying for entries with dateTime values lying in range from midnight of a given date up to midnight of the next date; And if that's not complex enough, try doing the same for multiple dates. That should clarify it very quickly that wherever possible, it is advantageous to only store the date portion without a time. That being said, storing date and not time, has its disadvantages. Doing so means there is a loss of data that could have been collected and probably could be useful later. Even worse, a "date" data-type also precludes associating a timezone to the database record; A "dateTime" data-type does not suffer from this restriction. As an example, consider a laughingly simple question: What is the date on 14th of March, 2021? Astonishingly, though, the answer to it is not an obvious "14th of March, 2021"? To understand the reason, let's expand the question: "What is the date in New Delhi (India), on 14th of March, 2021 in Seattle, Washington (US)?" This highlights the ambiguity of the question. At 2AM on 14th of March, 2021 in Seattle, the date in New Delhi (India) is 14th of March. But at 11PM on 14th of March, 2021 in Seattle, the date in New Delhi (India) is 15th of March, 2021. From above, it seems that the ambiguity of the question is resolved if both the date and time components are provided, but not yet! Consider a new question: "What is the date in New Delhi (India), on 14th of March, 2021 in Seattle, Washington (US) at 12:30AM"? The answer seems like a sureshot "14th of March, 2021", but chances are the some applications, the ones which are good ones, would break when given this question. This is because 14th of March, 2021 marks the start of daylight savings in Seattle and so 12:30AM isn't uniquely defined. Is it 12:30AM Pacific Standard Time (or, PST), or 12:30AM Pacific Daylight Time (or, PDT)? This matters because the answer to "What is the date in New Delhi (India) on 14th of March, 2021 in Seattle, Washington (US) at 10:40AM PDT" is 14th of March, 2021 (because it'll be 11:10PM in India), but the answer to "What is the date in New Delhi (India) on 14th of March, 2021 in Seattle, Washington (US) at 10:40AM PST" is 15th of March, 2021 (because it'll be 12:10AM for the next day in India). *Sigh*! So, is it necessary to provide timezone? Could this issue not be solved by simply using the timezone for the corresponding time? For example, 10:40AM on 14th of March, 2021 is clearly going to be in PDT and not PST! There are 2 issues with this thought process: (1) The timezone isn't defined for when the daylight savings cross over is happening. (2) if a user queues up this request, say, on 1st of March, 2021, then what is the definition of "correct timezone to use" - should it be the date in the question (i.e., 14th of March, 2021) or date when the question was queued up (1st of March, 2021). There is no single answer for it because it depends on business use case. Hence, "To time or not to time" is a question that will test your understanding of business requirements and how it relates to the design of the database tables. Bottom line: You either deal with "date without time zone" or "dateTime with time zone" - there's no middle.</p>
	<p id="1614827655">So, you started with wanting to store date, got some business use case and quickly switched to storing dateTime, just to find timezone also needs to be stored. What now? First thing first, timezone is traditionally defined as the constant offset from the <a href="https://en.wikipedia.org/wiki/Greenwich_Mean_Time" target="_blank" rel="noopener noreferrer">GMT</a>, also called as Zulu time. Most literature wrongly suggest that GMT is the same as <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time" target="_blank" rel="noopener noreferrer">UTC</a> (other references: <a href="https://www.timeanddate.com/time/aboututc.html" target="_blank" rel="noopener noreferrer">here</a>); UTC is a <a href="https://en.wikipedia.org/wiki/Time_standard" target="_blank" rel="noopener noreferrer">time standard</a> and not a timezone. For simplicity though, rather than fighting it, just remember that whenever you see UTC being mentioned as a timezone, it means GMT. However, this definition of a timezone as having constant offset from GMT is not totally correct. As shown in above example, the offset value can change when transitioning to/from daylight saving. For the same longitude, cities that lie close to Earth's equator, will typically not have daylight saving, whereas those close to poles will have it. And then there's <a href="https://stackoverflow.com/questions/35462876/python-pytz-timezone-function-returns-a-timezone-that-is-off-by-9-minutes/50613134#50613134" target="_blank" rel="noopener noreferrer">this StackOverflow post</a> which identifies that the definition of a timezone can change over time! With this understanding, here are some of the helpful tips to navigate this quagmire: (1) If you need to only store date and not time, then just store date. However, realize that in doing so, you'll miss out the time data. With date alone, one cannot define timezone, and so "date" quries do not mix with other queries that directly or indirectly relates to timezone. For example, "date" and and "location" based queries won't mix. If you want restaurants in Dallas, TX and San Francisco, CA that is open even after 11PM local time on a certain date, that'll be an ill formed query. As explained above, 11PM in San Francisco, CA would mean that it's the next date in Dallas. Even with the loss of ability to perform certain queries, it's an all-out bad option to skip storing time. For one, you can always start developing your application and only use the date portion. When the application hits a roadblock due to new business requirements, then modify all previous date values, appending a "00:00:00" (i.e. midnight) to all date entries, and you've got dateTime type data now for the historical entries! (2) All the examples above show that when storing dateTime, then timezone should also be stored. But how? Storing offset from UTC is not a correct way to store timezone. The suggested solution is a 3-part implementation: (a) Always store all your dateTime entries in database in UTC, no exception, and, (b) add a separate timezone column in one or more database tables. Wherever needed, use the timezone column to translate from the UTC dateTime stored in database to the value expected by user, or vice-versa. Due to relation between different table, it might be possible that many child tables use the same timezone column defined in a parent table. So, realistically, you'll just have only a few timezone columns and not one for every dateTime column made in the schema. (c) For storing timezone values, use text-valued "TZ database name" from <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener noreferrer">list of timezones</a> and don't use constant offset value. For example, use values like <code>America/Chicago</code> or "<code>Asia/Seoul</code>.</p>
	<p id="1618367041">In above paragraphs, it is explored how the definition of datetime is incomplete without also including timezone. However, the change in timezone offset during transition in daylight savings can create friction in how colloquial terms are used. For example, it is mentioned above that daylight savings change for Seattle, Washington (US) on 14th of March, 2021. Before this date, PST timezone is used, and after this date, the PDT timezone is used. Here's the question: What time is 1 week after 10th of March, 2021, 1:00:00PM PST? There's no trick in 10th of March having the PST timezone because that is expected. The problem comes because after one week, i.e., on 17th of March, 2021, the timezone in Seattle is PDT. So, should the answer be "17th of March, 2021, 2:00:00PM PDT"? While this is technically true, realize that in colloquial use, when 2 people say that they'll meet same time next week, it is almost always implied that they will meet at same hour of day but after 7 days. With that understanding, the expeted answer to the question would be "17th of March, 2021, 1:00:00PM PDT" - but the difference between this datetime and the one in question isn't strictly 7 days, or (7 X 24 X 60 X 60) seconds, it is (7 X 24 X 60 X 60 - 60 X 60) seconds, but chances are that's the functionality the customers of the business applications are looking for, and not the one which is technically correct. The bottom line, when dealing with dateTime and timezones, also be careful of "time deltas" or "intervals of time", and compute it in a manner as expected by the business customers. Finally, add tests around the functionality to make sure it doesn;t get mistakenly broken.</p>
	
	<h4>Enumerated data</h4>
	<p id="1613947022">An enumerated data is one that can only take certain fixed values. Almost always, they are text valued fields and are represented in the entity class using an <code>Enum</code> data type. These values can be used to associate special business related meaning to the table entry. In context of the <a href="#1612649521" data-nav-id="1612649521">example application</a>, particularly the "<a href="#1612650690" data-nav-id="1612649521">Requirements - Part I</a>" section, enumerated values can be used to identify a bank account as either being a "CHECKING" or "SAVING" type account. As another example, let's consider the scenario described <a href="#1613440014" data-nav-id="1609472905">above</a> that suggests to store positive values if a deposit was done and negative values if a withdrawl is done. However, for someone looking at the data for the first time, it can be confusing because a positive value might equally well mean that money was given back to customer which is opposite of the intended use. Since "DEPOSIT" and "WITHDRAW" are a business concepts / terms in themselves, and the amount transacted is a different concept, so, a better design would be instead have two columns, one containing a non-negative amount transacted and the other being the transaction type, which can be "DEPOSIT" or "WITHDRAW". Doing so makes the tables more intuitive to understand for someone looking at the data, and reduces the chances of error due to miscommunication. A word of caution: don't have a design where enumerated deposit / withdraw type column is stored, alongwith the transacted amount as being positive or negative. If done, then it establishes a correlation between the two columns (i.e. if transaction type is "DEPOSIT", then amount transacted is positive, and if transaction type is "WITHDRAW", then amount transacted is negative), and this breaks 3NF normalization.</p>
	
	<h5>How to implement?</h5>
	<p id="1615044545">What type of values should be used when storing enumerated data? Should it be values like "CHECKING", "SAVING", or small codes like "C", "S", or even numbers like 0, 1? Comparing full names like "CHECKING", "SAVING" compared to codes like "C", "S", the use of full name is better because it gives someone looking at database entries a quick idea about the data being stored. This can be useful in avoiding communication pitfalls, specially as the team grows. Additionally, as the functionalities offered by the web application increases, it is more probable for collisions between different small-length codes to happen compared to if the full code name is used. For example, using "C" for both checking and credit card accounts! It may also be possible that some other table ends up using same small code which has a different meaning than the code used in another table. For example, using "C" for CHECKING account type and also for the child insurance option selected by a member. Using same code values is just something that can increase the potential for miscommunication and for them leading to errors. How about using values like 0, 1 instead? The design of using numerical valued codes also suffers from the same problem as using small text codes; And one more problem: presence of a numeric value mistakenly implies the presence of an implicit order among different options which need not be true and/or may change in future. For example, let's say the codes 0, 1 are used for checking and savings account. Sometime soon, a new requirement comes to allow a checking account to automatically pull money from savings to cover overdraft, but for savings account to pull money out from checking account is not allowed. Someone may look at the requirement, and account-codes, and deduce that an account type with a certain code can pull money from any account types with a higher code. This achieves the desired behavior, but is done by using an ordered relation between the values 0 (the code for checking account type) and 1 (the code for savings account type), which wasn't the original intention for using these code values. That can become a potential problem. Let's say in future, a "CREDIT-CARD" type account is made with code=2, then it will not be able to pull money from checking or savings. Maybe that's the intention. Or, maybe the intention is to allow it to do so, in which case someone needs to study the how the codes are being used throughout the codebase and identify that it should be given a value of -1. What if the goal is to allow this account to pull money from checking but not from savings? The code ends up being in a state where it only gets more complex over time. Therefore, if you're trying to model "enumerated" data, then it is strongly suggested to not use "ordinal" values to achieve the goal.</p>
	<p id="1615044550">There are 2 ways to include enumerated data: (1) use an <code>Enum</code> field in the entity class that gets stored or "serialized" in the database as a string, and, (2) create a new table containing these enumerated data in different rows and then add a foreign key reference to those rows wherever it's needed. In the first case, it may be beneficial to also add a <a href="#1614440246" data-nav-id="1609472905">check constraint</a> to the column which stores the name of enumerated type. An advanage of the second option is that it is possible to add, modify and delete enumerated data details in the database while the application is running and the changes get automatically picked up in subsequent calls. For example, instead of labeling the account type as "SAVINGS", if it is needed to label it as "SAVING", without an extra "S" at end, then the change can be made in database and the application will pick up the updated value. If using Enum type data in the application, doing this change would require making a code change, committing it, and then deploying the code again. But then, doing a redeployment is not a hard thing. An advantage of using the first option is that when the application is deployed, then the <code>Enum</code> data type is loaded, and so, all enumerated data gets loaded in-memory. This contrasts with the second option of making a new table where the enumerated data is obtained by querying from database and an extra join operation must be done everytime it is referenced by some entity. However, the fix to improve performance degradation is also simple: Cache all row from the corresponding enumerated data table when the application is deployed and read from it, and don't perform extra join calls! ORMs provide ability to do so. Another advantage of using the first option is that if any table uses the enumerated field, then a default value can also be assigned to it. Doing so is possible because all enumerated values are already defined in the <code>Enum</code>, and the application can simply use one of those values as a default. With the second option, it is still possible to assign default value but only if a natural key is used when defining the primary key for the enumerated data table. However, doing so goes against a <a href="#1614542613" data-nav-id="1609472905">previous suggestion</a> to only use numeric valued primary key. This being said, adding an enumerated default value for a column, as suggested for the first design, comes with some problems. Let's try to understand it with some examples. Let's say that the default back account type is "SAVINGS" type. An <code>Enum</code> with 2 options, "CHECKING" and "SAVINGS" is defined, <code>Enum.SAVINGS</code> is used for default value, and corresponding <a href="#1614440610" data-nav-id="1609472905">migration</a> codes are made. Sometime in future, let's say that <code>Enum.SAVINGS</code> is changed to <code>Enum.SAVING</code> (without 'S' at end). However, doing so breaks the previous migration which is expecting <code>Enum.SAVINGS</code> entry to be present. Modifying old migration file is not a good practice because we want to leave intact the set of historical changes done to a database. One way to bypass this problem is by creating the initial migration file by using the text "SAVINGS" and not by importing <code>Enum</code> and using <code>Enum.SAVINGS</code>. However, doing so breaks the causal relation that the word "SAVINGS" is used as default value because it is the serialized form of <code>Enum.SAVINGS</code>. Another point to consider is that when using the first option, then it is easier for the developers to see the list of enumerated options and pick a value from it. However, when using the second option, it is easier for external teams to identify the complete set of enumerated data entries by querying it from the database, and not needing to search for it in the codebase. In the end, there are positive and negative points to both approaches - pick the one that you feel most comfortable with, and then stick to that approach. A small digression: note that using the second option of creating a different table for low <a href="https://en.wikipedia.org/wiki/Cardinality_(SQL_statements)" target="_blank" rel="noopener noreferrer">cardinality</a> enumerated data is one of the few good use cases for having a 6NF normalization. Database schema normalization is otherwise stopped at 5NF normalization (<a href="#1613523454" data-nav-id="1611200362">reference</a>).</p>
	
	<h5>Enumerated data and Inheritance</h5>
	<p id="1615078115"><a href="#1613947022" data-nav-id="1609472905">Previous discussions</a> identified the use of enumerated data type to capture the type or status of some business process. Realize that by doing so, the enumerated data field can be used to achieve "<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" target="_blank" rel="noopener noreferrer">Inheritance</a>" behavior in entity class(es). For example, consider if "checking account" and "savings account" are defined as two concrete implementation of some "account" abstract class. One way to model this is by having the database schema contain two separate tables for checking and savings account. An alternate design is to use a single database table to store all account data, and to identify whether they are checking or savings type account by adding an enumerated "account type" column. This is called <a href="https://en.wikipedia.org/wiki/Single_Table_Inheritance" target="_blank" rel="noopener noreferrer">single table inheritance</a> design (additional reference: <a href="https://en.wikibooks.org/wiki/Java_Persistence/Inheritance#Single_Table_Inheritance" target="_blank" rel="noopener noreferrer">here</a>) which is typically the simplest and the best performing solution. Single table inheritance design can be contrasted the multiple table inheritance design (reference: <a href="https://en.wikibooks.org/wiki/Java_Persistence/Inheritance#Joined,_Multiple_Table_Inheritance" target="_blank" rel="noopener noreferrer">here</a>) where data columns that are common to all the concrete entity class implementations are stored in one table and the data columns unique to each entity is then stored in separate tables. Multiple inheritance table is a preferred design if the different concrete implementation have very different columns and so, it is more intuitive and space saving compared to using a single table inheritance design. However, due to the need for joins, the multiple table inheritance design does not have good query performance compared to single table inheritance design (..that being said, don't let it stop you from exploring the design because database latencies form a very small fraction compared to network calls). </p>
	<p id="1615177377">Let's consider the "<a href="#1613439952" data-nav-id="1612649521">Requirements - Part II</a>" of the example application where it is required to provide a feature where the users can create messages, that can then be followed up. The two types of message that can be made have different requirements on what additional information must be provided and who is allowed to follow up on the message. The huge difference between the two message types is a good reason to model messages using a multiple table inheritance design. One example on how this can be implemented is by having, say, a <code>CommonMessage</code> table consisting of a column for numeric valued identifier (that acts as primary key), a foreign key column to the <code>BankAccount</code> of user who creates the message, and an enumerated data column for the message type. Two separate tables, <code>OtherMessage</code> and <code>TransactionMessage</code> can be made, where, the <code>OtherMessage</code> table contains a foreign key to the customer service representative who handled the issue, and the <code>TransactionMessage</code> table contains a non-nullable foreign key to the disputed <code>AccountTransaction</code> entry and a non-nullable foreign key to the bank official who handled the issue. Both tables also contain a foreign key column to an entry in the <code>CommonMessage</code> table. With this design, when user submits a message, then the web application code should either insert an <code>OtherMessage</code> and corresponding <code>CommonMessage</code> entry, or, it should insert a <code>TransactionMessage</code> and the corresponding <code>CommonMessage</code> entry. When developing the application code, additional care must be taken that it is never allowed to directly insert or delete into the <code>CommonMessage</code> table. Doing so ensures that for every <code>CommonMessage</code> entry, there is strictly one (i.e., no less than one, no more than one) of either an <code>OtherMessage</code> or a <code>TransactionMessage</code> entry. Note that in this design, at every place where a foreign key is used, the foreign key value is also non-nullable. This aligns with <a href="#1614456323" data-nav-id="1609472905">previous discussions</a> that foreign key columns should not be nullable. Returning back to the table design, another use case that needs to be supported is that it should be possible to query all messages regardless of its type. To do so, one must query on the <code>CommonMessage</code> table and then left join with <code>OtherMessage</code> and <code>TransactionMessage</code> table. As mentioned above, by controlling how entries are added to these tables, it is ensured that each <code>CommonMessage</code> entry will have either an <code>OtherMessage</code> entry or a <code>TransactionMessage</code> entry, but not both. The enumerated column in the <code>CommonMessage</code> entry can be used to identify which one of <code>OtherMessage</code> or <code>TransactionMessage</code> entry is non null. In the design, notice how the <code>CommonMessage</code> entity is never directly used for writing data to the database; It is used only for reading data. On the other hand, <code>OtherMessage</code> and <code>TransactionMessage</code> entry is not directly read from the database and is only used for writing data to the database. This practice of using one entity to update information and a different entity to read information is called <a href="https://martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener noreferrer">Command Query Responsibility Segregation, or CQRS</a>. This is a level-up from method level command-query separation within a single class, discussed in a <a href="#1610226800" data-nav-id="1608344385">sub-section</a> under OOP in the architecture glossary. In here, a different entity class, and not just a different method, is used when inserting or retrieving data. A heads up, this concept will get another level up in a <a href="#1615299781" data-nav-id="1615299814">later chapter</a>.</p>
	<p id="1618276012">Let's say that we plan to use the CQRS design discussed in previous paragraph. As part of a future requirement, it is needed to make a new table, let's call in <code>Table-X</code> with a column that has a foreign key relationship to the "message" table? In this case, should the foreign key relation be made to the entry in <code>CommonMessage</code> table or to the <code>OtherMessage</code> or <code>TransactionMessage</code> table? The answer can get a bit more involved than usual. If <code>Table-X</code> is related specifically to <code>OtherMessage</code> or <code>TransactionMessage</code>, then the foreign key relation should be made to those tables and not to <code>CommonMessage</code> table. The <code>CommonMessage</code> entry can be accessed indirectly via the <code>OtherMessage</code> or <code>TransactionMessage</code> entry. However, if the foreign key relation needs to be made to the <code>CommonMessage</code> table, then, the entity class for the foreign key object must be defined in a way similar to the CQRS patterns discussed above, i.e. it can be used to read entries from the table, but it shouldn't be used to update entries. Only the entity class corresponding to <code>OtherMessage</code> or <code>TransactionMessage</code> must be used to update the foreign key entry.</p>
	<p id="1616192250">For sake of discussion, let's consider what would happen if a single-table design is used to model the requirements, instead of using a multiple table design <a href="#1615177377" data-nav-id="1609472905">discussed above</a>. The single table design will need to have the 3 columns corresponding to those in the <code>CommonMessage</code> table. Additionally, it will need a column with foreign key to the customer service representative who handled the message if it were an "Other" type message; And to enable storing the messages relating to a transaction dispute, the same table wouldalso  need a foreign key to the "transaction" entry and a foreign key to bank agent's profile who handled the trandaction dispute issue. However, since a message can be only belong to a single type, i.e. either be a "other" type message or be a "transaction" type message, so, two new constraints need to be put on this single table design: (1) if the message type is "Other", then the foreign key to the custom representative is not null and the foreign key to the transaction and to the bank agent is null, and, (2) If the message type is "Transaction", then the foreign key to the custom representative is null and the foreign key to the transaction and to the bank agent is not null. With these two constraints getting added, the single table design is already starting to become complex; And it will only get more convoluted as new message types and corresponding constraints are added. In this single table design, onserve that for each entry being made, one of customer service representative foreign key or bank agent foreign key will always be null. Having a null valued foreign key goes against the <a href="#1614456323" data-nav-id="1609472905">previous design suggestion</a> to never have a null value in foreign key. In the same previous discussion, it was mentioned that one of the <a href="https://stackoverflow.com/questions/7573590/can-a-foreign-key-be-null-and-or-duplicate/34682951#34682951" target="_blank" rel="noopener noreferrer">post</a> on the StackOverflow page giving example of places where a nullable foreign key can instead be modeled using a multiple table inheritance design. This section shows that if a single table design is pursued, as mentioned in the StackOverflow post, then it can get extremely hard and complex to manage and extend it.</p>
	<p id="1616194397">Consider a slightly different scenario, where it is needed to "capture" the id of personnel who handled the message. So, capture the primary key of the custom representative if an "Other" type message comes and gets handled, or, capture the primary key of the bank agent if a "transaction" type message comes and gets handled. Also, let's say that for now, there's no need to capture the primary key of the transaction being disputed when a "transaction dispute" type message is being made. In this case, an alternate design could be to use a single table design, and add a column called <code>handledIdentifier</code> which captures the primary key of the customer service representative or the bank agent whoi handled the message. In this design, anyone who reads the table record will know based on the message type whether the handler identifier belongs to the customer service representative or the bank agent, even though there isn't a foreign key constraint defined over the column. Another advantage of this design is that it can be easily extended to include new message types and store corresponding handler iedntifiers. So what's the trade off? The downside of this design is the lack of foreign key relation. This is an example of a "not-relational" design discussed <a href="#1613443573" data-nav-id="1609472905">previously</a>. The trade-off with this design is it causes no database relations to form between the message table and the corresponding handler table(s). Hence, the entries in each table will exists independently of the other. Constraints like protection on delete, or cascading delete cannot be applied in such cases.</p>
	
	<h3>Migration</h3>
	<p id="1614440610">After a logical design for the database has been made, the designs need to be realized within the database using database specific commands. The transference process that results is creation of actual database tables is called "Migration". A quick side note: The word "migration" is originally borrowed from <a href="https://docs.djangoproject.com/en/3.1/topics/migrations/#module-django.db.migrations" target="_blank" rel="noopener noreferrer">Django migrations</a>. Even though the term is used in a generic sense in the book, I am not aware if it is also used in the same generic sense in the software development lingo. Coming back to the discussion.. the "migration" process can also be used to add entries in <a href="#1615044550" data-nav-id="1609472905">tables containing enumerated data</a>, create user groups and add permissions. Generally, the application that performs migrations, does so by processing a list of commands provided by the user. From the list of user commands, if there's any command that has already been applied to the database, then those are ignored. The remaining commands are translated into DDL statements specific to the database provider being used by the web application. Those DDL statements finally get applied to the database to effect changes like creating or altering table, indexes, etc. For example, the <a href="https://www.liquibase.org/" target="_blank" rel="noopener noreferrer">Liquibase</a> application effects migrations by reading commands given to it in xml or groovy file(s), and translating them into corresponding DDL statements specific to the database provider. The advantage of accepting command and then translating it into DDL statements, rather than only accepting DDL statements, is that former enables achieving same schema in different databases and thereby increases the portability of the web application (meaning, one is not stuck to using a single database, they can also run the same commands on a different database and get the same schema). For example, Liquibase translates same commands into different DDL statements depending on the database provider being used by the application. This translation is done in a manner such that, eventually, the same schema gets generated in the database. Performing migrations via commands rather than making ad-hoc changes in the database has other advantages. Since these commands can be stored and tracked in the <a href="#1608564873" data-nav-id="1608344368">code repository</a>, it allows developers to understand past changes done on the database. This is useful to identify if any migration might have been missed, or was applied erroneously. Having the commands also enables automatically setting up same schema without manual intervention in any database. A huge advantage of being able to replicate schema is that by doing so in an in-memory database enables execution of functional tests, without needing a physical database. This check can be done every time new code is added or updated to ensure that teh code changes are not breaking any existing functionalities. Hence, it ultimate enables a <a href="#1608565983" data-nav-id="1608344368">continuous delivery</a> of the application.</p>
	
	<h4>Migration in agile environment</h4>
	<p id="1616262915">When developing in an agile environment, the database schema will evolve over time. Table and columns can get added or removed or altered. There are two different ways in which the commands to effect these migrations can be provided. In either case, the end goal is to insert new commands within the full list of migration commands used by the migration application in a way that if the complete list of commands are run again on a new database, then the generated schema will be similar to one formed if only the new commands are run to update an existing schema. The first way is to add new commands such that it preserves the "relationship order" of tables. Thus, all commands relating to some parent-table are added before commands relating to the corresponding child-table. In future, when new commands to update the parent table needs to be added onto this list in future, then those commands are added above any past or future commands relating to child table. This way of arranging the commands within the list keeps together all commands relating to formation of a particular table. The second way is that when adding new commands, it must only be appended at the bottom of list of existing commands. Doing so preserves the chronological ordering of commands executed on the database. By design, this way of migration produces same schema if the whole list of commands are run from the starts or if only the new commands are run on an existing schema. However, the trade-off is that the commands relating to a single table can get distributed at different locations in the complete list of migration commands, and so it can become more involved to track the evolution of a table over time. When performing migrations, it is strongly suggested to only use the latter way of migration, i.e. append new commands at the end of existing list. This is suggested because doing so strongly guarantees that a consistent schema is maintained over time. The other way of migration may look aesthetically pleasing because all commands relating to a single table are co-located, but it cannot provide guarantees of a consistent schema. Even worse, in some cases, it may even preclude certain migrations or changes from being applied in future. </p>
	<p id="1616265894">As mentioned earlier, it is also possible to create new data during the migration process. So, if needed, the commands to create, update, or delete data entries may also be appended to the full list, and along with other migration commands. If the migration application being used allows adding text tags to the commands, then information like the software ticket name, software release version can be added to the command tag to help with auditing of the migration process, i.e., to understand who added the command, what's the related software ticket and the software release when the migration was applied . A very important point relating to migrations: Do not delete a migration command entry after the corresponding change has been effected on the database. This is because the migration application keeps a record of any commands they have previously run so that a command that has been previously executed is not re-run in future. Deleting a command from the migration command list can cause the application to behave unpredicatbly because it won't be able to find the command that it ran in the past. Another reason is that if a command is deleted, then it can never be said with full certainty that running the complete list of migrations on a new database will give the same schema as running only the newly added commands on the existing schema. This is because the effect of the deleted command will not be realized when running the complete list of migrations on a new database. Lastly, deleting a command hides the corresponding information from the developers. This can make it hard to identify and debug any issues introduced by past migrations.</p>
	
	<h3>Entity class design</h3>
	<p>Up until now, the discussions centered around design of the database tables. If the web applications uses an object relational mapping tool, or ORM, to map a database table to a corresponding entity class, then the design considerations around database tabled discussed in sections above must also be borne when designing the entity class design. This section and its subsections delve into additional considerations that must be kept in mind when designing the entity class.</p>
	
	<h4>Super class</h4>
	<p id="1616345107">In a <a href="#1614573090" data-nav-id="1609472905">previous discussion</a>, it is suggested that a numeric identifier and a unique slug should be added for all database records. In a <a href="#1613711464" data-nav-id="1609472905">separate discussion</a>, it is suggested that fields like record create datetime and last modified datetime can be stored with each record if it serves a business need. Since these requirements are common to the definition of all entity classes in the application, these requirements are codified in a better manner by creating a super class and having the entity class extend it. In doing so, these common behaviors get consistently applied across all entity class definitions.</p>
	
	<h4>Custom ORM fields</h4>
	<p id="1616347263">Consider the use case of storing a datetime entry in database. At the code level, the corresponding field in the entity class is of <code>DateTime</code> type. However, when persisted in the database, the dateTime value is generally saved as a string in a certain format, or, it can also be saved as the long value equivalent of a dateTime. Either way, one doesn't worry about the type conversion from <code>DateTime</code> to string or number format because the ORM handles it transparently. Contrast this to a different requirement of storing an <code>Enum</code> type field. When storing it in database, should the enum's name be stored, or its value, or should the enum be stored in some other format? A common way to handle such requirements is to define custom ORM field definitions that explicitly defines how to serialize a field value when persisting it to database and also how to deserialize a column value after reading it from the database. An an example, let's say that the application accepts sensitive data from the user, like, an image of their signature, or their social security number, date of birth, etc. For all these fields, it may be required (..or just a good practice even if not required) to encrypt it before saving it in database, rather than saving the data in clear text form. Since the business application can have multiple such data fields in one entity class and multiple entity classes, so it is preferable to define a custom ORM field that encrypts data before writing to database and decrypts it before handing out the data. Defining a custom ORM field also enables consistently reusing the code at different places in the codebase.</p>
	
	<h5>Blank optional text field</h5>
	<p id="1618181027">A <a href="#1614199557" data-nav-id="1609472905">previous section</a> discusses that optional text field should define a default value of empty string and should not allow null values. It may be a good idea to capture this behavior in a custom ORM field definition so that it can be reused.</p>
	
	<h5>HTML safe and unsafe text field</h5>
	<p id="1618181272">When designing the entity class, the <code>string</code> data type is used as the data type for fields in the entity class that can store text values. However, just doing so does not convey restrictions on the string values contained within the field. For example, does this string valued field contain all <a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener noreferrer">Unicode</a> character, or does it only contain <a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener noreferrer">ASCII</a> characters? Are the unicode values normalized? Are there even more strict constraints on the field, like, allowing it to only having characters A-Z, a-z, 0-9 and space. Are the contents of the string html escaped or not? For example, a person's first name like "Andrea" or "Michael" is html safe and doesn;t need to be escaped, but a company's name, like, "Marks &amp; Spencer" isn't html safe! Should the text value be necessarily escaped before saving it in the database? Maybe there's a requirement to store the string values without any restriction, i.e. allow for the content of a text field to have all unicode characters and are not html escaped. The point that this paragraph makes is that rather than using a string data type to capture text values that can either have no restriction or have varying level of restrictions, it is a better practice to make custom ORM fields with suitable names to better communicate what can be expected of the content of the fields. For example, a better option would be to associate an ORM field to a data type like <code>UnicodeNonEscapedTextField</code> rather than simply associating it to a <code>TextField</code>. The former name makes it more visible on what should be expected of the field contents. Another alternative is to simply use <code>TextField</code> data type and always expect that its contents have no restrictions.</p>
	
	<h5>Custom fields versus custom getters and setters</h5>
	<p id ="1616350214">Another way to achieve the same result but without using custom ORM fields is by defining custom getters and setters for the field in the entity class. The getter methods act as a proxy layer between the values read from the database and the ones returned to any other method wanting to get the field value for an entity. Thus, it can be used be to customize the field value sent out. Same can also be done when storing data into the database and customizations can be added by defining cutom setter methods. Custom getter and setter methods can be used when a special behavior is needed for a single field in an entity class and the code is not reused at any other place in the codebase. An example for preferring a custom getter is if there's a requirement to return the complete social security number stored in a table only to an admin user, and otherwise only return the last 4 digits. Another example for using a custom getter is if a child entity extends a parent entity and a field is the child entity is modeled as overwriting value of similar field in the parent entity. In this case, a custom getter can be defined in the child entity class that returns the value read from database, or if no value exists, then it returns the value for the field in the parent entity. With this custom definition, one only needs to call the getter method on the child entity, and it will either return the overwritten value or the original value if no overwritten value exists. An example of having a custom setter or even a custom constructor is when a default value for a field is programmatically added. A <a href="#1615044550" data-nav-id="1609472905">previous section</a> mentioned that there may be certain designs where setting up a default value for column containing enumerated data in DDL statements isn't possible. Custom setters or constructors can be used in such cases. Custom setter can also be used when a field value is allowed to change only if user has certain roles and not otherwise.</p>
	<p id="1618180749">Note that the boundary between defining custom ORM fields versus having custom getter and setter is based on the reusability of the code. The advantage of defining a custom field, rather than defining custom getters and setters, is that it is more generic and the code can be reused. Hence, it is perfectly ok for some code to start as a custom getter and then get refactored to form a new field definition because the code starts getting reused at multiple places.</p>
	
	<h4>Programmatic constraint</h4>
	<p id="1616555826"><a href="#1614440246" data-nav-id="1609472905">Check constraints</a> are an important sub-type of constraints used to limit the type of data entering the table. They can be applied both at table row level and at individual field in the row. However, sometimes it may not be possible (or, easily possible) to add a check constraint. A simple example is if a column can only hold enumerated values, but you don't want to go and change the check constraint everytime the enumerated list changes, maybe, because the list is too big, or, because the <a href="#1614440610" data-nav-id="1609472905">migration</a> application being used does not provide the capability of turning an enumerated list into a check constraint and you want to avoid manually adding the constraint since it can become a source of error. For cases where it is not possible to add a check constraint, one may instead considerprogrammatically enforcing the data restrictions. This section covers such cases. A programmatic constraint can be thought of as filling the gap in defining data constraints when a check constraint couldn't be defined due to limitations of the SQL language (..or maybe the developer didn't realize that a check constraint could have been defined)! Since programmatic constraints are doing a work that should ideally be done by the database, there are a few things to keep in mind: (1) ensure that if any additional processing occurs on the entity between constraint verification to when it is saved in the dataase, then the processing does not break the constraints, or, simply don't do any extra processing; (2) ensure that all create or update or partial-update of the class is validated against the method containing programmatic constraints; (3) ensure that the programmatic constraints are thread safe and will not run into concurrency issues. A good way to enforce this is by having the constraints be defined in a functional manner (see discussion about <a href="#1609379598" data-nav-id="1608344385">functional programming</a> in architecture glossary); (4) And lastly, just like check constraints, the programmatic constraints should be based on field definitions and not on the business requirements.</p>
	
	<h5>Prefer check constraint if possible</h5>
	<p id="1616556905">An unfortunate case that most often happens is that the <a href="#1614440610" data-nav-id="1609472905">migration</a> application does not allow defining check constraints, thereby forcing the entity class to define programmatic constraints. When adding programmatic constraints, it is strongly suggested to spare some time and think if it is really needed to add programmatic constraints, or if it is possible to modify the migration code manually and include check constraints. If possible, always prefer adding check constraints because they apply at the database level and strongly ensure the validity of data in the database, regardless of the application that is creating or updating it.</p>
	<p id="1616637839">Above being said, programmatic constraints can be helpful in improving data consistency of existing tables that did not define check constraint and maybe couldn't do it anymore. One example would be <a href="#1616192250" data-nav-id="1609472905">use of single table</a> to store entities with different fields / constraints in each concrete implementation. By adding a "if-elseif-else" branching statement performing validations specific to an individual implementation, an effect can be obtained similar to validating the data against corresponding check constraint and before saving it in the database.</p>
	
	<h5>Referential checks</h5>
	<p id="1616634984">Consider the "<a href="#1613439952" data-nav-id="1612649521">Requirements - Part II</a>" of the example application, and that there is already a <code>User</code> and <code>BankAccount</code> table. Let's say that based on user interaction research, it is identified that users would want to see the most recent transaction and they do so much more often that actually making a transaction. Let's also consider the case that there are a lot of users for the bank. With this setup, if the <code>AccountTransaction</code> table is made such that it has foreign key to the <code>BankAccount</code> table, which itself has a foreign key to the <code>User</code> table, then it is not be a very performant design. This is because for each request, the database will first to find perform 2 join operation over the <code>BankAccount</code> and <code>User</code> table to find the most recent entry in <code>AccountTransaction</code> for the user who made the request. It is identified in a <a href="#1611408137" data-nav-id="1611200362">sub section</a> with the data-storage glossary that a normalization schema should be expected to hurt performace in order to provide data consistency, and the way to get better performance is via denormalization. Applying this knowledge to the problem, an alternate solution can be identified where a foreign key to the <code>User</code> table is stored in the <code>AccountTransaction</code>, in addition to also storing a foreign key to the <code>BankAccount</code> table. Now, one can directly query the latest <code>AccountTransaction</code> entry for a <code>User</code>. However, doing so leave open the possibility of having inconsistent data relations, i.e. the <code>User</code> in an <code>AccountTransaction</code> not being the same as <code>User</code> for the <code>BankAccount</code> in the same same <code>AccountTransaction</code> entry because there is no constraint to enforce it. Rather than throwing away the alternate design using denormalized schema, let's consider the following: if it can be guaranteed that every time an <code>AccountTransaction</code> entry is created or updated, then an extra check is done to verify that the <code>User</code> in the <code>AccountTransaction</code> entry is same as the <code>User</code> in <code>BankAccount</code> entry associated to the <code>AccountTransaction</code> entry, then the data in the tables will always be consistent. With there being much more requests to read the latest transaction than to create a new one, the performance benefit from faster reads over the denormalized schema will outweigh the performance reduction in doing the extra check when <code>AccountTransaction</code> is created. This extra check is called a referential check because it checks the consistency of various references, and this is an example of enforcing a constraint via code and which is not present in the database.</p>
	<p id="1616807737">In a previous section, the concept of a "<a href="#1613443573" data-nav-id="1609472905">Not-relational</a>" table was introduced. One example of its use is in making <a href="#1613443385" data-nav-id="1609472905">audit table</a> where a single table can store details about add / update operation done on entries in other table. In doing so, the "not-relational" design prevents us from otherwise having to make lot many tables. Consider the use case where it is needed that when a table entry is deleted then all the related audit tables entries are also deleted within the same transaction. Quick side note: It is not being suggested that one should delete entries from the audit table. On the contrary, they should not be modified. This is just an example to show how non-existing database table references can be created programmatically. Coming back to the discussion.. To achieve this requirement, an extra code can be inserted such that when the entity is being deleted, then all related entries in audit table are searched for and also deleted. This shows that programmatic constraints can be used to realize "relations" between tables that aren't defined in the database schema. However, it is strongly suggested that as much possible, this should not be turned into a mainstream code-pattern because if the foreign key relations are not defined between the tables in the schema, then one loses the benefit of defining data relationship and consistency checks provided by the database. A single slip in the application code where the relations are not accounted for will let bad data creep inside the database table; And with the growth in application features, it is just a matter of time before an accident like this happens.</p>
	
	<h5>Constraint on create and update</h5>
	<p id="1613746290">In a <a href="#1613520117" data-nav-id="1609472905">previous section</a>, an example is provided on how a business requirement may impose the adoption of having a denormalized schema design. In such cases, programmatic constraints can be used to make the interaction between the application and the database behave as if it is normalized. Consider the example where a database table needs to store both the last modified datetime and the last modified date of the entry. The denormalization is coming from the fact that same data, i.e., the last modified datetime, it is being stored in two different formats. One way to restore the normalization is to only define a getter for the last modified date, and not define a setter for it, and define a setter for the last modified datetime field that updates both the last modified datetime and the last modified date at same time. With this change, the values in the two fields will never get out of sync with each other, and will maintain data consistency. A database level check constraint can also be added to ensure that the date portion of the 2 columns are always same.</p>
	<p id="1618602730">Consider the example discussed in a <a href="#1614456323" data-nav-id="1609472905">previous section</a> having <code>Client</code> and <code>SalesRepresentative</code>. Let's say that there can be "department" categories to which clients can belong to, and a sales representative specializes in a particular department. For example, Google can be an example of a client in "Software" department and McDonald's can be an example of a client in "FastFood" department. Since the "department" value is an intrinsic property of a "client", it is expected for the <code>Client</code> table to have a <code>department</code> column with enumerated values. For same reason, it is also expected fo the <code>SalesRepresentative</code> table to have a <code>department</code> column with enumerated values. In this case, there's no good normalized way to design the tables such that when a sales representative is assigned to a client, then it is also constrained that the two have same department. This is a good example of where programmatic constraints can help maintain data consistency because doing so at the database is not viable.</p>
	
	<h5>Modeling locks</h5>
	<p id="1616833826">Consider the example discussed in a <a href="#1614456323" data-nav-id="1609472905">previous section</a> where the scenarios with null valued foreign keys were discussed. Continuing on that discussion, it was suggested to make a <code>Client</code> table, a <code>SalesRepresentative</code> table, and when a sales representative is associated to the client, then create an entry in the <code>SalesCampaign</code> table having a non-nullable foreign key to the corresponding <code>Client</code> and <code>SalesRepresentative</code> entries. If only a single <code>SalesRepresentative</code> can be added to a <code>Client</code>, then an equivalent design is have a column in the <code>Client</code> table, that foreign keys to the <code>SalesRepresentative</code> table, and which can hold nullable values, and with the understanding that a null value means that a sales representative has not been assigned to the client. This is similar to what's mentioned in the corresponding StackOverflow thread. Let's expand on the requirements to see if we can get more insights. Let's say that for each client, two sales respresentative must be assigned before any work starts. This assignment is done by some administrator who should be able to see the list of clients and the 0-2 sales representative associated to them. How should this be modeled? A quick but important note: This requirement of gathering multiple entities so that they can be assigned on some task is called "locking". I am not sure if this is standard term in database modeling, but it does relate to similar feature being provided by various programming languages.</p>
	<p id="1616835133">There are a couple of design options that can be pursued. Let's start by picking up the design in the StackOverflow thread, with the <code>Client</code> table having a nullable column with foreign key to <code>SalesRepresentative</code> table. Let's call this column as <code>representative_1</code>. This design can be extended to add another nullable column with foreign key to <code>SalesRepresentative</code> table. Let's call the new column as <code>representative_2</code>. This design works great for many use cases, but is not a proper one to use when the assignment of sales representatives to a client starts becoming intricate. This is because with the rise of complexity it might become necessary to make additional columns in the <code>Client</code> table to store the data, but those columns don't relate to the <code>Client</code> unique constraint, but instead related to <code>representative_1</code> or <code>representative_2</code> columns. This breaks the 3NF and it is <a href="#1616262915" data-nav-id="1609472905">suggested above</a> that in an agile setting, one should strive to have the database schema in 3NF. For example, let's say that 2 sales representatives are assigned and then the first one leaves. What happens at this time? Does the next assigned representative gets added as <code>representative_1</code> even if they are assigned after the one in <code>representative_2</code> column? If there can be a hierarchy between the representative in having a final say on the decisions for the sales campaign, then that is not easily modeled? The design also assumes that anyone with access to the <code>Client</code> table would also be allowed access to information on the assigned sales representatives which need not be true. For completeness, let's also ask a different question: How is it that the design works great for many use cases where no additional details on assignment of sales representatives to a client needs to be stored? The reason is that for these use cases, adding two columns allows defining more than 1 unique constraint in the <code>Client</code> table and breaks 2NF. However, as mentioned <a href="#1613442382" data-nav-id="1609472905">earlier</a>, when developing in agile environment, it is possible for database to lose 2NF, and this is ok to happen, and this can be restored in future without any data loss.</p>
	<p id="1618610715">Let's start by asserting that the only change of having <code>representative_1</code> and <code>representative_2</code> columns in a table other than the <code>Client</code> table is sufficient to meet the business use case, and there's no need to capture or worry about any other data related to the assignment of sales representatives to a client. A scenario where this can happen is if fewer users are allowed access to information on the assigned sales representative information compared to those allowed access to information about clients. A design that can be pursued is to add a many-to-many <code>SalesCampaign</code> table with non-nullable foreign key to the <code>Client</code> table and two more nullable columns, <code>representative_1</code> and <code>representative_2</code>, with foreign key to <code>SalesRepresentative</code> table. Everything else about the use of these column remains the same as in previous design. Programmatic constraints can be added to ensure that if 2 sales representatives are provided, then they are not same. Another way to approach this requirement is to do the following: (i) define <code>SalesCampaign</code> table to have non-nullable foreign key to the <code>Client</code> table and another column with enumerate value like, "ONE", "TWO", where, "ONE" means that one sales representative has been associated to the client, and so on, (ii) add a new table <code>OneRepresentativeCampaign</code> having a non-nullable column with foreign key to <code>SalesRepresentative</code> table and a non-nullable column with foreign key to <code>SalesCampaign</code> table, and, (iii) add another new table <code>TwoRepresentativeCampaign</code> having two non-nullable column with foreign key to <code>SalesRepresentative</code> table with constraint that the two cannot be same, and a non-nullable column with foreign key to <code>SalesCampaign</code> table. This is a multi-table inheritance design comapred to the single-table inheritance design described earlier in the paragraph (reference: <a href="#1615078115" data-nav-id="1609472905">previous discussion</a> on single-table and multi-table inheritance design), and as such, the pros and cons of one design over the other, or scenarios in which one should be preferred over the other is same as that discussed for single-table and multi-table inheritance design. When one sales representative is associated to the client, then an entry can be made in the <code>SalesCampaign</code> table, choosing value of "ONE" for the numerated column, and another entry can be made in the <code>OneRepresentativeCampaign</code> table. When one more representative is associated, then the enumerated column value in <code>SalesCampaign</code> table can be changed from "ONE" to "TWO", the entry in <code>OneRepresentativeCampaign</code> table can be deleted, and an entry can be made in <code>TwoRepresentativeCampaign</code> table. Opposite can be done when one or two representatives are unassigned from a campaign.</p>
	<p id="1614440386">Another design that can be pursued is to define the many-to-many <code>SalesCampaign</code> table, with non-nullable foreign key to the <code>Client</code> table and another non-nullable foreign key to the <code>SalesRepresentative</code> table, and to remove <code>representative_1</code> and <code>representative_2</code> columns from the <code>Client</code> table. In this design, it is easy to track the dateTime when a representative joined a campaign, what's their hierarchy in the campaign, or any other data. This design also allows easily adding new columns to capture data related to assignment of sales representatives to a client. This design also allows to meet the "foreign keys cannot be nullable" rule (discussed <a href="#1614456323" data-nav-id="1609472905">previously</a>). However, it suffers from a drawback that there isn't any way to constrain that a client should only be assigned 0-2 sales representatives. One way to solve the problem is by adding programmatic constraints preventing creation of new <code>SalesRepresentative</code> entry for a client if they have already been assigned 2 sales representative assigned. The drawback of doing so is that the constraint definition lives only in the web application codebase and won't be visible in any manner to someone looking at the database schema. Another way to solve the problem is by adding a <code>assignedSalesRepresentativeCount</code> column to the <code>Client</code> table, and increasing / decreasing it by 1 when adding / removing a sales representative, and also adding a check constraint at database level to ensure that <code>assignedSalesRepresentativeCount</code> column can only take values 0, 1, 2. At the database schema level, this is a denormalized design because the count of sales representatives assigned to a client can be obtained either by counting the entries in <code>SalesRepresentative</code> table or by obtaining the value from <code>assignedSalesRepresentativeCount</code> column in the <code>Client</code> table. Hence, the responsibility to ensure that the two values are same comes up on the programmatic constraint. Side-note: This design also can also be used as an alternative when wanting to define uniqueness in a group of row rather than at a row level, as described in a <a href="#1614199777" data-nav-id="1609472905">previous section</a> under the discussion on unique key constraint. In context of the problem discussed in that section, one can define <code>Student</code>, <code>ActivityGroup</code>, <code>ActivityGroupPresident</code> tables, add a <code>presidentCount</code> in <code>ActivityGroup</code> table, update its value by 1 when adding / removing presidents, and constrain the count column to only accept values 0, 1.</p>
	<p id="1616902428">In the above paragraphs, different ways to model the locking requirement is provided. Generally speaking, same considerations also apply when designing for a situation where an enumerated data column identifies the one among multiple concrete implementation that should be used for defining the entity. So, why is it that the data modeling guidelines for other situations are clear cut, but it becomes very vague when modeling the locking requirement, or modeling enumerated data. I believe it is because of 2 reasons. One is that for such cases, it is relatively easy to switch from one design to another without losing any data. Hence, the advantage of chosing a design over another isn't as clear cut. Another reason is that there is no clear-cut, unambiguous guideline for designing an entity which goes through different stages between it's initial and final form. For example, a client entity starts its lifecycle with no sales respresentatives being associated with it. Then, it can have one representative, and this is still a valid stage in the lifecycle of the client entity, but it is not a final stage where it becomes useful to the business. Only when it has two representatives associated to a client, then it arrives to its final form signalling that additional work can now be done on it, i.e, sales campaign for the client can start, and start being useful to the business. Here's the question: at the time when the client has one sales representative associated with it, should it be treated as an altogether different entity than its start and end stage, or should all three stages be treated as same entity with just some information missing? If it is the latter then what constraints apply on the table at all time versus what constraints are specific to an intermediary stage? And is there a way to define any intermediary stage constraints on the table itself, or should it only be enforced via programmatic constraints? And finally, does the answer to above question depends on how many intermediary stages are there? Would one design be preferred if there are 2-3 intermediary stages, and would another one be preferred if there are 20-30 stages? To matters a bit worse, development in an agile environment means that new stages can come up in future. Maybe something started as a good choice but would later need to be refactored! My suggestion would be to just start with one of many possible designs to handle the solution. The worst thing to do would be to have hair splitting architectural discussions and not have a developed product in time.</p>
	
	<h4>Non-updatable field</h4>
	<p id="1616830940">ORM framework provide capability to identify a table field as something that should only be created but can never be updated again. This behavior of not being able to update a field can be used in different scenarios. For example, to disallow update of the identifier column of a table. The reason for doing so is based on <a href="#1614542613" data-nav-id="1609472905">previous discussion</a> which identified that it is a good practice to never update the identifier of a table entry. Anothe example is to disable updates for all column of the <a href="#1613443385" data-nav-id="1609472905">audit table</a> because the entries in an audit table should not be changed once it is created. A third example could be to disallow update of values that strongly relate to entry creation event, like, the entry create datetime. There's no reason to modify it and it should always be set just once. Another example is to disallow update of one or both foreign key columns of a many-to-many table. This is because a many-to-many table entry represents a relation between two table entries, and logically, a relation should either exist or not-exist. Updating a relationship just means to delete an old one and add a new relationship.</p>
	
	<h4>Constraining vs Saving</h4>
	<p id="1616831542">It is mentioned <a href="#1616556905" data-nav-id="1609472905">above</a> that in order to robustly enforce programmatic constraints, the application code must be written in a manner that all create or update or partial update of an entity object goes through a single method where validation is performed. Another method that should occur exactly once within the entity lifecycle, whether creating or updating or partial updating an entity object is the <code>save</code>, i.e. the method to actually persist the new or changed values in the database. Due to this correlation, it is very likely for the constraint validation logic to get added within the definition for <code>save</code> method. This section recomends keeping the logic for programmatic constraint validation separate from the logic of saving an entity. To m knowledge, at least in Django framework, this is made exlicit by having separate <a href="https://docs.djangoproject.com/en/3.1/ref/models/instances/#django.db.models.Model.clean" target="_blank" rel="noopener noreferrer"><code>clean()</code></a> and <a href="https://docs.djangoproject.com/en/3.1/ref/models/instances/#django.db.models.Model.save" target="_blank" rel="noopener noreferrer"><code>save()</code></a> methods. The reason for the difference is that former applies the programmatic constraint validation and the latter does additional tasks that must be executed when saving data. Saving the last modified date based on the value of last modified datetime is one such process that is better done as part of saving the entity rather than as part of constraint validation. Adding a process to create thumbnail of a profile image based on the image provided by the user is another example of process that sould be done when saving the entity, and not when performing validations on it. This being said, one must also take care to not change the entity after it has been validated and before it gets saved in database such that it breaks the programmatic constraints; This is also mentioned in the same paragraph <a href="#1616556905" data-nav-id="1609472905">above</a>.</p>
	
	<h3>Keep entity as much constrained</h3>
	<p id="1612756799">In context of the <a href="#1612649521" data-nav-id="1612649521">example application</a>, particularly the "<a href="#1612650690" data-nav-id="1612649521">Requirements - Part I</a>" section, it is mentioned that a <code>User</code> table will have a <code>username</code> column. Let's say the <code>username</code> is stored as a string within the entity, and as a text type field in database. Here's a question: should the <code>username</code> field in the entity be allow to have all <a href="https://home.unicode.org/" target="_blank" rel="noopener noreferrer">unicode characters</a>, or just a-z? How about A-Z in capitals? What about special characters like &gt;, &lt;, underscore, dash, etc.? By allowing storage of some special characters and then not handling it properly when rendering them on webpage, it is possible for the web application to become vulnerable to <a href="#1608866075" data-nav-id="1608343369">XSS attack</a>. Let's say that the <code>username</code> field is initially only allowed to have a-z, A-Z, 0-9 characters. However, when the business expanded to Germany, the users complained about not being able to add umlauts or <a href="https://en.wikipedia.org/wiki/%C3%9F" target="_blank" rel="noopener noreferrer">eszett</a>. Is it correct to expect that the developer should have anticipated that the application can be used in Germany and so the username field should be coded to enable storing umlauts? From my viewpoint, the answer is: No. Generally, <strong>one must NOT let a possibility of future use deviate the application from being designed, code and constrained to only support the known and current use cases.</strong> Only after new business requirements are presented, should the definitions of the entities being used in the application be expanded and the constrainst relaxed to accommodate the new features; It is not something that should be done pre-emptively even when a feature is not being asked for. This helps in restricting the scope of work being done by developers to only code and <strong>add unit tests for the features needed</strong> and no more. Not doing more work that needed is a good practice because with extra work that nobody asked for comes extra features and complexities that nobody wants and which are hard to maintain, waste time and money, and might get removed in future. This being said, if you feel that adding a feature would help the product become better and more robust, then discuss the idea with the product managers and the senior teachnical leads. Maybe, they'll like the idea and would want to inlude it, or maybe you had a misunderstanding about how the product works and the extra feature is not needed, or maybe they are aware of it and are just waiting for a more proper time when the new feature can be added. A quick side note: Preventing XSS attack by constraining the text that goes in the database is a side benefit of having a constrained design; Being able to prevent an attack via use of a constrained design should NOT be seen as a primary reason to constrain the design. The primary reason to constrain the design is to provide clear product goals to the developers so they can code AND TEST within the scope of business requriements.</p>
	<p id="1616906931">Other example of entity level data constraints are: allowing text data in specified format only, numeric entries should be within some reasonable minimum and maximum value and numeric value precision should be up to specified decimals and not arbitrary. <a href="#1614191105" data-nav-id="1609472905">Table and column constraints</a> and <a href="#1616555826" data-nav-id="1609472905">programmatic constraints</a> also help in constraining the entity definition. Also, <a href="#1614440246" data-nav-id="1609472905">as mentioned earlier</a>, when defining entity constraints, one must make sure that it relates to the field or table definition and not to business requirements.</p>
	
	<aside class="shown-individually-but-hidden-in-ebook"><i><strong>Read this article, and more, in ebook <a href="/productionizing/productionizing-backend-development/#1609472905">here</a>.</strong></i></aside>
</article>
